<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Broadcasting Adam</title>
    <link>http://broadcastingadam.com/</link>
    <atom:link href="http://broadcastingadam.com/rss.xml" rel="self" type="application/rss+xml" />
    <description>Thoughts on Modern Web Development</description>
    <language>en-us</language>
    <pubDate>Wed, 13 Jun 2012 12:49:31 +0200</pubDate>
    <lastBuildDate>Wed, 13 Jun 2012 12:49:31 +0200</lastBuildDate>

    
    <item>
      <title>Defining Gems, Plugins, Railties, and Engines</title>
      <link>http://broadcastingadam.com/2012/03/defining_plugins_gems_railties_and_engines</link>
      <pubDate>Fri, 30 Mar 2012 00:00:00 +0200</pubDate>
      <author>me@broadcastingadam.com (Adam Hawkins)</author>
      <guid>http://broadcasting.com/2012/03/defining_plugins_gems_railties_and_engines</guid>
      <description>&lt;p&gt;I listened to the Ruby Rogues &lt;a href='http://rubyrogues.com/048-rr-crafting-rails-applications-with-jose-valim/'&gt;podcast&lt;/a&gt;. One of the people on the show asked Jose when you should use a gem, railtie or an engine. I think that many people are unclear what defines each and when to use them.&lt;/p&gt;

&lt;h2 id='gems'&gt;Gems&lt;/h2&gt;

&lt;p&gt;A gem is a portable unit of Ruby code. It may contain &lt;code&gt;railties&lt;/code&gt; or &lt;code&gt;engines. Gems can bundle pretty much anything and do all sorts of
crazyness.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Use Cases&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;You want to distrube portable units of Ruby code.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id='plugins'&gt;Plugins&lt;/h2&gt;

&lt;p&gt;Plugins are an alias for Gems. However, there is another layer to this discussion. Prior to Rails 3.2 and officialy in Rails 4 there were things were officially called &amp;#8220;plugins.&amp;#8221; Plugins were usually smaller than Gems and lived inside &lt;code&gt;vendor/plugins&lt;/code&gt;. Essentially no one uses them anymore besides Heroku because they love raising deprecation errors in current applications. You can use &lt;code&gt;rails plugin new&lt;/code&gt; which will generate a new &lt;strong&gt;gem&lt;/strong&gt; that&amp;#8217;s connected to rails via &lt;strong&gt;railties&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Use Cases&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;None&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id='railties'&gt;Railties&lt;/h2&gt;

&lt;p&gt;The name itself defines its purpose. A &amp;#8220;railtie&amp;#8221; provides a connector for external code to tie into Rails. It allows you do things like define configuration for Rails or add initializers. Here are some common use cases suggested from the Railtie docs:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;configuring a Rails framework for the application, like setting a generator&lt;/li&gt;

&lt;li&gt;adding &lt;code&gt;config.*&lt;/code&gt; keys to the environment&lt;/li&gt;

&lt;li&gt;setting up a subscriber with &lt;code&gt;ActiveSupport::Notifications&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;adding rake tasks&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ActiveRecord, ActionPack, ActiveSupport are all connected to rails via railties. Railties connect separate sections of code into Rails. Here is an real life example of a simple Railtie in the wild:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module Cashier
  class Railtie &amp;lt; ::Rails::Railtie
    config.cashier = Cashier

    initializer &amp;quot;cashier.active_support.cache.instrumentation&amp;quot;
      ActiveSupport::Cache::Store.instrument = true
    end
  end
end&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Use Cases&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Connecting non rails code to rails&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id='engines'&gt;Engines&lt;/h2&gt;

&lt;p&gt;&amp;#8220;Engines&amp;#8221; are actually a &lt;code&gt;railtie&lt;/code&gt; subclass. They can do everything a railtie can do and more. Engines are essentially self contained rails applications. They can have all their own models, controllers, views, routes, and internal code. Engines can be packaged as gems. You can do everything in an engine that you can do in your application. That&amp;#8217;s because your Rails application is actually just an engine. You can generate a new engine like this: &lt;code&gt;rails plugin new foo --mountable&lt;/code&gt; (Yes plugin is confusing.)&lt;/p&gt;

&lt;p&gt;Examples:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href='https://github.com/plataformatec/devise'&gt;Devise&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='https://github.com/radar/forem'&gt;Forem&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Use Cases&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;You want make a self contained rails application that can be redistruted.&lt;/li&gt;

&lt;li&gt;You want to decompose your large rails application into smaller components&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>State of Writing API Servers with Rails</title>
      <link>http://broadcastingadam.com/2012/03/state_of_rails_apis</link>
      <pubDate>Wed, 28 Mar 2012 00:00:00 +0200</pubDate>
      <author>me@broadcastingadam.com (Adam Hawkins)</author>
      <guid>http://broadcasting.com/2012/03/state_of_rails_apis</guid>
      <description>&lt;p&gt;We&amp;#8217;ve been writing API&amp;#8217;s using Rails for a long time. It&amp;#8217;s nothing new. However, making the API the sole and only reason to exist shifts your application&amp;#8217;s purpose and architecture. This posts covers my experience writing pure JSON APIs with Rails.&lt;/p&gt;

&lt;h2 id='defining_an_api_server'&gt;Defining an &amp;#8220;API Server&amp;#8221;&lt;/h2&gt;

&lt;p&gt;This is what I consider a pure API server.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;All responses are JSON&lt;/li&gt;

&lt;li&gt;Authentication using some sort of tokens&lt;/li&gt;

&lt;li&gt;&lt;code&gt;ActionView&lt;/code&gt; is not present in the code base.&lt;/li&gt;

&lt;li&gt;&lt;code&gt;Sprockets&lt;/code&gt; is not present in the code base.&lt;/li&gt;

&lt;li&gt;Some concept of versioning (inputs and outputs)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I think this covers a pretty basic Rails app.&lt;/p&gt;

&lt;h2 id='existing_tries'&gt;Existing Tries&lt;/h2&gt;

&lt;p&gt;There are already a few things that try to make writing a API with rails easier. Basically they all just create less complicated version of &lt;code&gt;ApplicationController::Base&lt;/code&gt; and do some other basic stuff. &lt;a href='https://github.com/strobecorp/strobe-rails-ext'&gt;Strobe&amp;#8217;s Rails Extension&lt;/a&gt; does this. It&amp;#8217;s a basic solution, but not complete enough. There are a host of similar solutions out there. Take a peak around if you like.&lt;/p&gt;

&lt;h2 id='getting_in_the_door_authentication'&gt;Getting in the Door: Authentication&lt;/h2&gt;

&lt;p&gt;The primary method is using a token. The token is passed to the API through headers (preferred) or standard parameter passing. Here is the code I use to generate API keys in all my applications.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module HasApiToken
  extend ActiveSupport::Concern

  included do
    before_create :generate_api_key
  end

  private
  def generate_api_key
    self.api_key ||= Digest::SHA1.hexdigest(Time.now.to_s + attributes.inspect)
  end
end&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then you can authenticate a request using the token like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;User.find_by_api_key!(request.headers[&amp;#39;HTTP_X_API_TOKEN&amp;#39;] || params[:token])&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Easy. I&amp;#8217;m not sure if this pattern could be wrapped up in a gem because it&amp;#8217;s very simple but it doesn&amp;#8217;t change much. Either way, this technique gets the job done.&lt;/p&gt;

&lt;h2 id='getting_it_done_generating_json'&gt;Getting it Done: Generating JSON&lt;/h2&gt;

&lt;p&gt;Your API has return JSON. It&amp;#8217;s very surprising to me that some solutions make this so damn complicated (I&amp;#8217;m looking at you JBuilder and Rabl). Returning JSON is a very simple process. You only need to generate a Hash. This is done very easily via the Presenter pattern. The presenter also needs to take the &lt;code&gt;current_user&lt;/code&gt; into account since different people get to see different things. The presenter pattern is perfect because you can define a different presenter class for each resource and even scope them under different namespaces when you need to version things.&lt;/p&gt;

&lt;p&gt;I use &lt;a href='https://github.com/josevalim/active_model_serializers'&gt;ActiveModel::Serializers&lt;/a&gt; because it&amp;#8217;s the perfect solution. It&amp;#8217;s very easy to define schemas and test them independently of everything else. This is very important! It seems to me that people forget this. OOP is good. Use it!&lt;/p&gt;

&lt;p&gt;Here is an example serializer:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class BlogPostSerializer &amp;lt; ActiveModel::Serializer
  attributes :title, :content, :posted_at

  has_many :comments

  def attributes
    hash = super

    # include secret if the user is an admin
    hash[:secret] = object.secret if user.admin?
    hash
  end
end&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can test this very easily. Instantiate it with a blog post and user and test that &lt;code&gt;as_json&lt;/code&gt; returns the right stuff. No view layer. No bullshit. Just classes following SRP. If you use Ember (which is awesome), &lt;code&gt;ActiveModel::Serializers&lt;/code&gt; will be be the default format for the data store. Rails will automatically use the proper serializer when using &lt;code&gt;respond_with&lt;/code&gt; or &lt;code&gt;respond_to&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;I advise you to use ActiveModel::Serializers because it&amp;#8217;s a very simple solution. You can easily define &amp;#8220;partials&amp;#8221; in modules that declare more attributes. Unfortunately, there is only a 0.1.0 release out now. The project is still under active development.&lt;/p&gt;

&lt;h2 id='next_step_parameter_santization_and_authorization'&gt;Next Step: Parameter Santization and Authorization&lt;/h2&gt;

&lt;p&gt;&lt;a href='https://github.com/rails/strong_parameters'&gt;Strong Paramters&lt;/a&gt; is a good first step in moving authorization out of the model. I hope that dhh&amp;#8217;s strong paramters is merged into Rails 4. It&amp;#8217;s a basic variation on the slice pattern. It uses a method inside the controller to select the valid parameters that can be sent to the model.&lt;/p&gt;

&lt;p&gt;Here is the important example from the readme:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class PeopleController &amp;lt; ActionController::Base
  # This will raise an ActiveModel::ForbiddenAttributes exception because it&amp;#39;s using mass assignment
  # without an explicit permit step.
  def create
    Person.create(params[:person])
  end

  # This will pass with flying colors as long as there&amp;#39;s a person key in the parameters, otherwise
  # it&amp;#39;ll raise a ActionController::MissingParameter exception, which will get caught by 
  # ActionController::Base and turned into that 400 Bad Request reply.
  def update
    redirect_to current_account.people.find(params[:id]).tap do |person|
      person.update_attributes!(person_params)
    end
  end

  private
    # Using a private method to encapsulate the permissible parameters is just a good pattern
    # since you&amp;#39;ll be able to reuse the same permit list between create and update. Also, you
    # can specialize this method with per-user checking of permissible attributes.
    def person_params
      params.required(:person).permit(:name, :age)
    end
end&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I think that this is a step in the right direction, but I&amp;#8217;d like to see this logic moved into it&amp;#8217;s own class. StrongParameters doesn&amp;#8217;t consider authorizations that may happen outside of a controller. It does make it possible to extract the &lt;code&gt;person_params&lt;/code&gt; method into it&amp;#8217;s own class. You &lt;strong&gt;should&lt;/strong&gt; do this.&lt;/p&gt;

&lt;h2 id='action_authorization'&gt;Action Authorization&lt;/h2&gt;

&lt;p&gt;There is only one thing to say: &lt;a href='https://github.com/ryanb/cancan'&gt;CanCan&lt;/a&gt;. It is the best thing for this. I think CanCan is almost perfect.&lt;/p&gt;

&lt;h2 id='versioning'&gt;Versioning&lt;/h2&gt;

&lt;p&gt;Enter the no-mans land. I still haven&amp;#8217;t found any that will handle versioning in a clean way. I&amp;#8217;m looking for something that builds boundaries in my code. I&amp;#8217;m looking for something that completely separates the request input and request response. For example, say in version API version 2, the parameters to &lt;code&gt;POST /foos&lt;/code&gt; have changed. How do you handle that? IMO, you need a class that can convert the message. Same thing for output formats. How do you handle returning a different format for version 2? You &lt;em&gt;could&lt;/em&gt; be a slacker and namespace routes (&lt;code&gt;/api/v1/&lt;/code&gt;, &lt;code&gt;/api/v2&lt;/code&gt;). I don&amp;#8217;t think this is a good solution. The version should be passed in the headers, not in the URI. It would be perfect if I could find a gem that would take the Accept header and automatically use &lt;code&gt;V2::Messages&lt;/code&gt; and &lt;code&gt;V2::PostSerializer&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id='documentation'&gt;Documentation&lt;/h2&gt;

&lt;p&gt;Documenting programs is hard. It is always hard no matter the context. I think there are two different types of documentation. There is the exact technical documentation. For example, this route takes this parameter. This parameter must be this format or these values etc. These are return values etc. Then there is the high level user guide type documentation. Think the rails guides vs the API docs. You need both to create a successful platform.&lt;/p&gt;

&lt;p&gt;The major difference between them is that one is generated from documentation in the code and the other is written by humans. At this point it is infeasible that user guides can be generated automatically. It is feasible that technical documentation can be generated. Isn&amp;#8217;t the holy grail that you can change the code and have the documentation updated? The big problem with documentation is that it gets out of date because it&amp;#8217;s maintained in two separate places. What if could solve that problem?&lt;/p&gt;

&lt;p&gt;I think we can solve this problem. The first step, as with any code documentation, is to define a standard format and where to put it. I think you can put this code in the controller. Why the controller? Because the controller is where your API meets the outside world. The controller is what takes input and tells other classes to do stuff. Also, the controller may do specific logic on parameters to sanitize them or something else. The controller is the gatekeeper for your application and the entry rules should be written on the gate. Now you can combine this parameter declaration with parameter sanitization (ala StrongParamters) and you&amp;#8217;d really be onto something!&lt;/p&gt;

&lt;p&gt;Here is an example from &lt;a href='https://github.com/mifo/sinatra-rabbit'&gt;Rabbit&lt;/a&gt;. This doesn&amp;#8217;t do everything that I&amp;#8217;m talking about, but you&amp;#8217;ll see where I&amp;#8217;m going:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;operation :show do
  description &amp;quot;Index operation description&amp;quot;
  param :id,  :string, :required
  param :r1,  :string, :optional, &amp;quot;Optional parameter&amp;quot;
  param :v1,  :string, :optional, [ &amp;#39;test1&amp;#39;, &amp;#39;test2&amp;#39;, &amp;#39;test3&amp;#39; ], &amp;quot;Optional parameter&amp;quot;
  param :v2,  :string, :optional, &amp;quot;Optional parameter&amp;quot;
  control do
    &amp;quot;Hey #{params[:id]}&amp;quot;
  end
end&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this point you could load the code and read the declarations. Everything you need is there. You could write code to transform it into &lt;a href='http://petstore.swagger.wordnik.com/'&gt;http://swagger.wordnik.com/&lt;/a&gt;. How awesome would that be? This is just an example of what can be done. The important part is updating the code regenerates the documentation.&lt;/p&gt;

&lt;p&gt;We still have to handle the user guide level documentation. I think there are two ways to handle it. #1, you use something like &lt;a href='http://tomdoc.org/'&gt;Tomdoc&lt;/a&gt; in the controller for high level documentation. #2, you maintain it separately. I&amp;#8217;ve opted for #2 in my situation. I&amp;#8217;m using my own code here to write &lt;a href='https://github.com/threadedlabs/api_guides'&gt;api guides&lt;/a&gt;. It&amp;#8217;s heavily inspired by Stripe&amp;#8217;s &lt;a href='https://stripe.com/docs/api'&gt;docs&lt;/a&gt;. You can see an example &lt;a href='http://developer.radiumcrm.com'&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Unfortunately, I haven&amp;#8217;t been able to solve the generated technical documentation problem yet, but at least this is a start.&lt;/p&gt;

&lt;p&gt;I think there is a lot to be done on this front. If we as a community can solve this problem, I think that crafting API&amp;#8217;s will be much easier and more importantly, much faster.&lt;/p&gt;

&lt;h2 id='get_going'&gt;GET /going&lt;/h2&gt;

&lt;p&gt;I think there is still much work to be done on this front. I hope that Rails 4 takes some of these ideas and folds them into the core. I know that parameter authorization will be moved to the controller in Rails 4. I hope they address the serialization problem as well (by not using JBuilder). However, given DHH&amp;#8217;s love for it, I don&amp;#8217;t see that happening.&lt;/p&gt;

&lt;p&gt;I&amp;#8217;d really like to see the community address the documentation problem. I think there is a will too. It seems to me that more rails developers are building simple applications and aren&amp;#8217;t really interested in tackling the entire scope of the problem: How can build an HTTP API in rails, maintain it, and release it to the public. At Radium, we are building enterprise software. We think big. Working in this scope has made me tackle many large problems. I hope that my experience will help you as well.&lt;/p&gt;

&lt;p&gt;When building an API, just remember: Rails is not your code. Your application is separate. The controllers just talk to your code. Don&amp;#8217;t get the two confused!&lt;/p&gt;

&lt;h2 id='appendex'&gt;Appendex&lt;/h2&gt;

&lt;p&gt;I&amp;#8217;ve added this section to include links to things people have tweeted me or showed me on IRC.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href='https://github.com/intridea/grape'&gt;Grape&lt;/a&gt; - Github&lt;/li&gt;

&lt;li&gt;&lt;a href='https://github.com/mifo/sinatra-rabbit'&gt;Rabbit&lt;/a&gt; - Github&lt;/li&gt;

&lt;li&gt;&lt;a href='https://github.com/bploetz/versionist'&gt;Versionist&lt;/a&gt; - Github&lt;/li&gt;

&lt;li&gt;&lt;a href='http://freelancing-gods.com/posts/versioning_your_ap_is'&gt;Versioning RESTful APIs&lt;/a&gt; - Blog Post&lt;/li&gt;

&lt;li&gt;&lt;a href='http://designinghypermediaapis.com/'&gt;Hypermedia APIs&lt;/a&gt; - Book&lt;/li&gt;

&lt;li&gt;&lt;a href='https://github.com/rails/rails/commit/6db930cb5bbff9ad824590b5844e04768de240b1'&gt;Rails API Mode&lt;/a&gt; - Reverted Commit for API mode for rails&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id='sharing_is_caring'&gt;Sharing is Caring&lt;/h2&gt;

&lt;p&gt;Now in the vein of &amp;#8220;Sharing is Caring&amp;#8221;, here is my base API controller that I use:&lt;/p&gt;
&lt;script src='https://gist.github.com/2237832.js?file=api_controller.rb' /&gt;</description>
    </item>
    
    <item>
      <title>Deploy Scripts for Git &amp; Heroku Applications</title>
      <link>http://broadcastingadam.com/2012/03/deploy_scripts</link>
      <pubDate>Mon, 26 Mar 2012 00:00:00 +0200</pubDate>
      <author>me@broadcastingadam.com (Adam Hawkins)</author>
      <guid>http://broadcasting.com/2012/03/deploy_scripts</guid>
      <description>&lt;p&gt;Our company is growing. It&amp;#8217;s not longer just me. I&amp;#8217;m not the only one who deploys code anymore. All of our code is deployed to Heroku. You&amp;#8217;d think this is a very simple thing to do: &lt;code&gt;git push heroku master&lt;/code&gt;. It is on the surface. But think about everything you do &lt;strong&gt;before&lt;/strong&gt; you deploy? Do you tag commits? Do you merge into a production branch? Do you record the deployed commit? Do you test that things are green on your CI machine? There are lot of things you may do before. I used to do all these sort of these manually. But now that someone else needs to deploy code, it&amp;#8217;s time to automate it.&lt;/p&gt;

&lt;p&gt;I started out writing a Rake task. This became unweidly. I needed something more general for CLI applications. I thought about writing the scripts in bash, but I don&amp;#8217;t have enough experience to write good bash scripts or structure them to allow them to go. I do have plenty of experience with Ruby. I decided to write my deploy script using &lt;a href='https://github.com/wycats/thor'&gt;Thor&lt;/a&gt;. Thor includes many different utilities for interacting with the shell. For me, it feels like bash on steroids and in Ruby which is a win. I wanted to create a simple script so that I (or anyone else) could run:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./script/deploy&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That way there is no fancy invocations. It could easily be extended to: &lt;code&gt;./script/deploy (production|staging)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The basic structure is to:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Check all preconditions&lt;/li&gt;

&lt;li&gt;If all prereqs are green, then continue&lt;/li&gt;

&lt;li&gt;Compile assets&lt;/li&gt;

&lt;li&gt;Record a deploy commit&lt;/li&gt;

&lt;li&gt;Push to github&lt;/li&gt;

&lt;li&gt;Push to heroku&lt;/li&gt;

&lt;li&gt;Log all this stuff&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Here are the prereqs:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;There are no uncommited files&lt;/li&gt;

&lt;li&gt;User can ssh to github&lt;/li&gt;

&lt;li&gt;User can ssh to heroku&lt;/li&gt;

&lt;li&gt;HEAD is fast forward commit to master&lt;/li&gt;

&lt;li&gt;HEAD hasn&amp;#8217;t been deployed to heroku&lt;/li&gt;

&lt;li&gt;All required ENV variables are present on Heroku&lt;/li&gt;

&lt;li&gt;Assets compile correctly&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;And the deploy process&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Compile assets&lt;/li&gt;

&lt;li&gt;Record this commit and time in the deploy file&lt;/li&gt;

&lt;li&gt;Push commit to github&lt;/li&gt;

&lt;li&gt;Push commit to heroku&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Now that the structure and understanding is there, here is the base class for our deploy task.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;require &amp;quot;rubygems&amp;quot; # ruby1.9 doesn&amp;#39;t &amp;quot;require&amp;quot; it though
require &amp;quot;thor&amp;quot;

RAILS_ROOT = File.expand_path &amp;quot;../../&amp;quot;, __FILE__

LOG_FILE = &amp;quot;#{RAILS_ROOT}/deploy.log&amp;quot;

class Deploy &amp;lt; Thor
  include Thor::Actions

  class CommandFailed &amp;lt; StandardError ; end

  no_tasks do
    def run(command, options = {})
      `echo &amp;quot;#{command}&amp;quot; &amp;gt; #{LOG_FILE}`

      command = &amp;quot;#{command} &amp;gt; #{LOG_FILE} 2&amp;gt;&amp;amp;1&amp;quot; unless options[:capture]

      options[:verbose] ||= false

      super command, options
    end

    def run_with_status(command, options = {})
      run command, options
      $?
    end

    def success?(command, options = {})
      run_with_status(command, options).success?
    end

    def run!(command, options = {})
      raise CommandFailed, &amp;quot;Expected #{command} to return successfully, but didn&amp;#39;t&amp;quot; unless success?(command, options)
    end

    def pass(message)
      say_status &amp;quot;OK&amp;quot;, message, :green
      true
    end

    def abort_deploy(message)
      say_status &amp;quot;ABORT&amp;quot;, message, :red
      say &amp;quot;Deploy Failed! Check log file #{LOG_FILE}&amp;quot;
    end

    def failure(message)
      say_status &amp;quot;FAIL&amp;quot;, message, :red
      false
    end
  end
end&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;#8217;ve added some helper methods to make it easier to write my scripts. Mainly, to redefine &lt;code&gt;run&lt;/code&gt; to return &lt;code&gt;$?&lt;/code&gt; instead of whatever the script output. I did this because I needed the exit code to check preconditions and successful commands. &lt;code&gt;run!&lt;/code&gt; is important because it will raise an error if a command fails. This is for the deploy stage when all commands need to execute successfully for the deploy to succeed. The helpers it easier to log the deploy process.&lt;/p&gt;

&lt;p&gt;And now for the complete script:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env ruby
require &amp;quot;rubygems&amp;quot; # ruby1.9 doesn&amp;#39;t &amp;quot;require&amp;quot; it though
require &amp;quot;thor&amp;quot;

RAILS_ROOT = File.expand_path &amp;quot;../../&amp;quot;, __FILE__

LOG_FILE = &amp;quot;#{RAILS_ROOT}/deploy.log&amp;quot;

class Deploy &amp;lt; Thor
  include Thor::Actions

  class CommandFailed &amp;lt; StandardError ; end

  no_tasks do
    def run(command, options = {})
      `echo &amp;quot;#{command}&amp;quot; &amp;gt; #{LOG_FILE}`

      command = &amp;quot;#{command} &amp;gt; #{LOG_FILE} 2&amp;gt;&amp;amp;1&amp;quot; unless options[:capture]

      options[:verbose] ||= false

      super command, options
    end

    def run_with_status(command, options = {})
      run command, options
      $?
    end

    def success?(command, options = {})
      run_with_status(command, options).success?
    end

    def run!(command, options = {})
      raise CommandFailed, &amp;quot;Expected #{command} to return successfully, but didn&amp;#39;t&amp;quot; unless success?(command, options)
    end

    def pass(message)
      say_status &amp;quot;OK&amp;quot;, message, :green
      true
    end

    def abort_deploy(message)
      say_status &amp;quot;ABORT&amp;quot;, message, :red
      say &amp;quot;Deploy Failed! Check log file #{LOG_FILE}&amp;quot;
    end

    def failure(message)
      say_status &amp;quot;FAIL&amp;quot;, message, :red
      false
    end
  end

  desc &amp;quot;ensure_environment&amp;quot;, &amp;quot;Test Rails can boot&amp;quot;
  def ensure_environment
    inside RAILS_ROOT do
      if success? &amp;quot;RAILS_ENV=production bundle exec rake environment&amp;quot;
        return pass &amp;quot;Rails boots&amp;quot;
      else
        return failure &amp;quot;Make sure Rails can boot in Production locally&amp;quot;
      end
    end
  end

  desc &amp;quot;ensure_github_connection&amp;quot;, &amp;quot;Tests this user can ssh to github&amp;quot;
  def ensure_github_connection
    if run_with_status(&amp;quot;ssh -T git@github.com &amp;quot;).exitstatus == 1
      pass &amp;quot;Github conencted&amp;quot;
    else
      failure &amp;quot;SSH keys missing for Github&amp;quot;
    end
  end

  desc &amp;quot;ensure_heroku_connection&amp;quot;, &amp;quot;Tests this user can access heroku&amp;quot;
  def ensure_heroku_connection
    if success? &amp;quot;heroku config&amp;quot;
      pass &amp;quot;Heroku connected&amp;quot;
    else
      failure &amp;quot;SSH key missing or user is not a collabator&amp;quot;
    end
  end

  desc &amp;quot;ensure_clean&amp;quot;, &amp;quot;Test to see if the repo is clean&amp;quot;
  def ensure_clean
    if success? &amp;quot;git diff --exit-code&amp;quot;
      pass &amp;quot;No uncommited files&amp;quot;
    else
      failure &amp;quot;There are uncommited files&amp;quot;
    end
  end

  desc &amp;quot;ensure_heroku_outdated&amp;quot;, &amp;quot;Test to see if this code has been deployed or not&amp;quot;
  def ensure_heroku_outdated
    if !success? &amp;quot;git diff head heroku/master --exit-code&amp;quot;
      pass &amp;quot;Code not deployed&amp;quot;
    else
      failure &amp;quot;Code already deployed&amp;quot;
    end
  end

  desc &amp;quot;ensure_fast_forward&amp;quot;, &amp;quot;Tests if this is a fast forward commit&amp;quot;
  def ensure_head
    inside RAILS_ROOT do
      if success? &amp;quot;git pull origin master&amp;quot;
        return pass &amp;quot;Fast forwarded&amp;quot;
      else
        failure &amp;quot;Could not fast forward. Human required&amp;quot;
        run &amp;quot;git reset --hard HEAD&amp;quot;
        return false
      end
    end
  end

  desc &amp;quot;ensure_assets_compile&amp;quot;, &amp;quot;Tests assets compile correctly&amp;quot;
  def ensure_assets_compile
    inside RAILS_ROOT do
      if success? &amp;quot;bundle exec rake assets:precompile&amp;quot;
        pass &amp;quot;Assts compiled&amp;quot;
        run &amp;quot;git reset --hard HEAD&amp;quot;
        return true
      else
        return failure &amp;quot;Assets failed to compiled&amp;quot;
      end
    end
  end

  desc &amp;quot;compile_assets&amp;quot;, &amp;quot;Precompiles assets&amp;quot;
  def compile_assets
    inside RAILS_ROOT do
      run! &amp;quot;bundle exec rake assets:precompile&amp;quot;

      say_status &amp;quot;Assets&amp;quot;, &amp;quot;Compiled&amp;quot;
    end
  end

  desc &amp;quot;record&amp;quot;, &amp;quot;Records this deploy in deploys.md&amp;quot;
  def record
    inside RAILS_ROOT do
      commit_info = run(&amp;#39;git show --format=&amp;quot;format:%h - %an: %s&amp;quot;&amp;#39;, :capture =&amp;gt; true, :verbose =&amp;gt; false).split(&amp;quot;\n&amp;quot;)[0]

      run &amp;quot;touch #{LOG_FILE}&amp;quot;

      format = &amp;quot;* [%s] %s\n&amp;quot;

      existing_contents = File.read &amp;quot;#{RAILS_ROOT}/deploys.md&amp;quot;

      File.open &amp;quot;#{RAILS_ROOT}/deploys.md&amp;quot;, &amp;#39;w&amp;#39; do |f|
        f.puts format % [Time.now.strftime(&amp;quot;%Y-%m-%d %H:%M %z&amp;quot;), commit_info]
        f.puts existing_contents.chomp
      end

      say_status &amp;quot;Deploy Log&amp;quot;, commit_info
    end

    true
  end

  desc &amp;quot;commit&amp;quot;, &amp;quot;Commits assets and pushes to Github&amp;quot; 
  def commit
    inside RAILS_ROOT do
      run! &amp;quot;git add deploys.md&amp;quot;
      run! &amp;quot;git add public/assets&amp;quot;
      run! &amp;quot;git commit -m &amp;#39;[Deploy]&amp;#39;&amp;quot;
      @new_commit = true # so we can catch the failure and blow away the last commit
    end

    say_status &amp;quot;Deploy Files&amp;quot;, &amp;quot;Commited&amp;quot;
  end

  desc &amp;quot;run_deploy&amp;quot;, &amp;quot;Tests prereqs and runs a deploy&amp;quot;
  method_option :environment, :default =&amp;gt; &amp;quot;production&amp;quot;
  def run_deploy
    say &amp;quot;Checking prereqs...&amp;quot;

    prereqs = invoke(:ensure_clean) &amp;amp;&amp;amp;
      invoke(:ensure_github_connection) &amp;amp;&amp;amp;
      invoke(:ensure_heroku_connection) &amp;amp;&amp;amp;
      invoke(:ensure_heroku_outdated) &amp;amp;&amp;amp;
      invoke(:ensure_head) &amp;amp;&amp;amp;
      invoke(:ensure_environment) &amp;amp;&amp;amp;
      invoke(:ensure_assets_compile)

    if !prereqs
      abort_deploy &amp;quot;Failed prereqs&amp;quot;
      return false
    end

    say &amp;quot;Running predeploy tasks...&amp;quot;

    begin
      invoke :compile_assets
      invoke :record
      invoke :commit
    rescue CommandFailed =&amp;gt; ex
      abort_deploy &amp;quot;A deploy step failed to run: #{ex}&amp;quot;

      if @new_commit
        run &amp;quot;git reset HEAD~1&amp;quot;
      else
        run &amp;quot;git reset --hard HEAD&amp;quot;
      end

      return false
    end

    say &amp;quot;Deploying...&amp;quot;

    begin
      inside RAILS_ROOT do
        run! &amp;quot;git push origin master&amp;quot;
        say_status &amp;quot;Github&amp;quot;, &amp;quot;Pushed&amp;quot;

        run! &amp;quot;git push heroku master&amp;quot;
        say_status &amp;quot;Heorku&amp;quot;, &amp;quot;Deployed&amp;quot;
      end
    rescue CommandFailed =&amp;gt; ex
      abort_deploy &amp;quot;Push failed. Please check logs.&amp;quot;
    end
  end

  default_task :run_deploy
end

Deploy.start&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each step is wrapped in its own method. Thor makes each method available. This way you can easily test the individual sections. The deploy task checks all the prereqs, then does all the hard work. It also looks pretty while doing it thanks to built in colorization support from thor. Happy deploying!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;UPDATE&lt;/strong&gt;: Here is the link to simple expandable version in a &lt;a href='https://gist.github.com/2237714'&gt;gist&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Generating URLs Whenever &amp; Wherever You Want</title>
      <link>http://broadcastingadam.com/2012/03/generating_urls_whenever_and_wherever_you_want</link>
      <pubDate>Mon, 05 Mar 2012 00:00:00 +0100</pubDate>
      <author>me@broadcastingadam.com (Adam Hawkins)</author>
      <guid>http://broadcasting.com/2012/03/generating_urls_whenever_and_wherever_you_want</guid>
      <description>&lt;p&gt;One of my big gripes with Rails is that it makes it very hard to do things outside the request/response cycle. It is a web framework, but now we have an increasing amount of things happening outside of that workflow. You may have noticed that it&amp;#8217;s annoying to generate URLs when you&amp;#8217;re not in a view or a controller. There is one simple reason for this. They don&amp;#8217;t want to you to do that. There is also a reason why you cannot do that. The structure of the route helpers require the request because they know everything about where it came from, aka they know the host. You need to know the host to generate urls and do all that other stuff. If there is no request, there is no host.&lt;/p&gt;

&lt;p&gt;ActionMailer is one very common case for generating URL&amp;#8217;s outside of request/response. Links inside emails need the full URL because they don&amp;#8217;t live on webpage. This is why you have to set the default url options to use route helpers inside mailers. So since ActionMailer can generate URLs outside the request, we can do that do. Most applications are going to have ActionMailer configured anyways, so we can just piggy back off the configuration.&lt;/p&gt;

&lt;p&gt;Here&amp;#8217;s an example &lt;code&gt;Router&lt;/code&gt; class&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Router
  include Rails.application.routes.url_helpers

  def self.default_url_options
    ActionMailer::Base.default_url_options
  end
end

router = Router.new
router.posts_url  # http://localhost:3000/posts
router.posts_path # /posts

# all -2ez-&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you want to simply include routing support in any class you can easily combine this into a module&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module Routing
  extend ActiveSupport::Concern
  include Rails.application.routes.url_helpers

  included do
    def default_url_options
      ActionMailer::Base.default_url_options
    end
  end
end

class UrlGenerator
  include Routing
end

generator = UrlGenerator.new
generator.posts_url
generator.posts_path&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Happy routing!&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Introducing FrontendServer</title>
      <link>http://broadcastingadam.com/2012/02/introducing_frontend_server</link>
      <pubDate>Mon, 20 Feb 2012 00:00:00 +0100</pubDate>
      <author>me@broadcastingadam.com (Adam Hawkins)</author>
      <guid>http://broadcasting.com/2012/02/introducing_frontend_server</guid>
      <description>&lt;p&gt;Radium has turned out to be a real beast. After much delibration, we decided to move to a pure JS frontend written in &lt;a href='http://emberjs.com'&gt;Ember&lt;/a&gt;. He&amp;#8217;s written in JS and basic CSS. No coffeescript or SASS. We needed an easy way to compile all the JS and CSS files into two different files and host them on the web. We also have a few other requirements.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Frontend code is completly separate of backend API.&lt;/li&gt;

&lt;li&gt;Frontend code can be deployed and maintained independently.&lt;/li&gt;

&lt;li&gt;Enable SASS/Coffeescript. I freaking love SASS.&lt;/li&gt;

&lt;li&gt;Recompile assets in development&lt;/li&gt;

&lt;li&gt;API proxy to avoid CORS issues in development&lt;/li&gt;

&lt;li&gt;Easily deployable by non server guys.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;So me being the server side guy, I had to sort this out. Josh turned me on to: @wycats&amp;#8217;s &lt;a href='https://github.com/wycats/rake-pipeline-web-filters'&gt;rake-pipeline-web-filters&lt;/a&gt;. It&amp;#8217;s an extension to rake-pipeline. Rake-pipeline is essentially the Rails asset pipeline done in a less bitchy way. It&amp;#8217;s a rake extension that does what the rails asset pipeline does, except it&amp;#8217;s &lt;strong&gt;much&lt;/strong&gt; more powerful. You can easily define custom filters for things like minification.&lt;/p&gt;

&lt;p&gt;Rake::Pipeline::WebFilters provides the heavy lifting. I wrote a simple Rack app to serve the stuff based on sensible defaults (convention over configuration) and voilla! We have asset compilation and a development server. Combine some more glue code to connect a proxy and other bits and we have a more complete solution.&lt;/p&gt;

&lt;p&gt;Introducting &lt;a href='https://github.com/adman65/frontend_server'&gt;FrontendServer&lt;/a&gt;. Here&amp;#8217;s what it does:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Compile JS/CS into Minispade modules&lt;/li&gt;

&lt;li&gt;Compile LESS/SASS/CSS into css files&lt;/li&gt;

&lt;li&gt;Reload assets in development&lt;/li&gt;

&lt;li&gt;Proxy the backend API&lt;/li&gt;

&lt;li&gt;Compile into one public directory&lt;/li&gt;

&lt;li&gt;Deployable to heroku by any git user&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I&amp;#8217;ve used the classic Backbone todos app for an example. The example is running &lt;a href='http://warm-ocean-3185.herokuapp.com/'&gt;here&lt;/a&gt;. Source &lt;a href='https://github.com/adman65/frontend_server_example'&gt;here&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Rails 3.2, Heroku, &amp; rails_log_stdout</title>
      <link>http://broadcastingadam.com/2012/01/rails320_heroku_and_rails_log_stdout</link>
      <pubDate>Mon, 16 Jan 2012 00:00:00 +0100</pubDate>
      <author>me@broadcastingadam.com (Adam Hawkins)</author>
      <guid>http://broadcasting.com/2012/01/rails320_heroku_and_rails_log_stdout</guid>
      <description>&lt;p&gt;I try to keep my applications on the bleeding edge of Rails. After being stuck Rails 2 for almost 1.5 years after Rails 3 was released, it&amp;#8217;s been very nice. Of course the bleeding edge has it&amp;#8217;s drawbacks. Enter Rails 3.2.0rc2 and Heroku. &lt;code&gt;vendor/plugins&lt;/code&gt; is deprecated in Rails 3.2. Heroku dumps it&amp;#8217;s configuration plugins into &lt;code&gt;vendor/&lt;/code&gt;. This gives you a nice deprecration warning everytime a rails environment process starts.&lt;/p&gt;

&lt;p&gt;I had to do some debugging with developers using the API. This means I need to be able to see what their applications are sending in realtime. I&amp;#8217;ve been using Heroku for a long time, so I just fire up &lt;code&gt;heroku logs
--tail&lt;/code&gt; and watch away. Except, now with rails 3.2.0rc2 I don&amp;#8217;t see anything coming from rails. Only the start up messages and the request accepted message. Well, there is no parameter information.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2012-01-16T13:26:50+00:00 app[web.1]: Started POST &amp;quot;/todos&amp;quot; for 82.181.188.119 at 2012-01-16 13:26:50 +0000
2012-01-16T13:26:51+00:00 heroku[router]: POST api.radiumcrm.com/todos dyno=web.1 queue=0 wait=0ms service=212ms status=422 bytes=92&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Well shit. That doesn&amp;#8217;t really tell me anything at all. I want to see this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2012-01-16T13:26:50+00:00 app[web.1]: Started POST &amp;quot;/todos&amp;quot; for 82.181.188.119 at 2012-01-16 13:26:50 +0000
2012-01-16T13:26:50+00:00 app[web.1]: Processing by TodosController#create as JSON
2012-01-16T13:26:50+00:00 app[web.1]:   Parameters: {&amp;quot;todo&amp;quot;=&amp;gt;{&amp;quot;kind&amp;quot;=&amp;gt;&amp;quot;call&amp;quot;, &amp;quot;finish_by&amp;quot;=&amp;gt;&amp;quot;2012-05-01T18:52Z&amp;quot;}}
2012-01-16T13:26:51+00:00 app[web.1]: Completed 422 Unprocessable Entity in 208ms (Views: 0.3ms | ActiveRecord: 110.7ms)
2012-01-16T13:26:51+00:00 app[web.1]: cache: [POST /todos] invalidate, pass
2012-01-16T13:26:51+00:00 heroku[router]: POST api.radiumcrm.com/todos dyno=web.1 queue=0 wait=0ms service=212ms status=422 bytes=92&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Turns out there is problem with the &lt;code&gt;[rails_log_stdout](https://github.com/ddollar/rails_log_stdout)&lt;/code&gt; plugin heroku uses do it&amp;#8217;s business. The rails initialization process has changed slightly. &lt;code&gt;ActionController::Base.logger&lt;/code&gt; was being assisigned to the standard &lt;code&gt;log/production.log&lt;/code&gt; file somewhere before the std out logger was being set. Then through the magic of &lt;code&gt;||=&lt;/code&gt; it is already defined and not reassigned to the stdout logger. The plugin is one &lt;code&gt;init.rb&lt;/code&gt; file which is now deprecated. Time to fix this!&lt;/p&gt;

&lt;p&gt;I wrote a simple rails engine (rails 3+ only!) to fix this and stop the deprecation warnings. Hopefully heroku will use this code to make their platform rails 3.2 compatible. You can grab the code &lt;a href='https://github.com/adman65/rails_log_stdout'&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Then stick this bad boy in your Gemfile:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;group :production do
  gem &amp;#39;rails_log_stdout&amp;#39;, :git =&amp;gt; &amp;#39;git://github.com/Adman65/rails_log_stdout.git&amp;#39;
end&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you have &lt;strong&gt;also&lt;/strong&gt; have to tell Rails to explicitly load a whitelist of plugins. You can do this in &lt;code&gt;production.rb&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;config.plugins = [ :rails_serve_static_assets ] # ONLY load static assets plugin&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You&amp;#8217;ll still see depreaction warnings because heroku is injecting code into your source, but logging will work as you expect. If you are using any other plugins make sure you add them to the list.&lt;/p&gt;

&lt;p&gt;Happy log tailing!&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Generating Routes for API Documentation</title>
      <link>http://broadcastingadam.com/2012/01/generating_routes_for_api_documentation</link>
      <pubDate>Sat, 14 Jan 2012 00:00:00 +0100</pubDate>
      <author>me@broadcastingadam.com (Adam Hawkins)</author>
      <guid>http://broadcasting.com/2012/01/generating_routes_for_api_documentation</guid>
      <description>&lt;p&gt;I recentely came across this situation. I was updating the documenation for our main API. I have a section which includes all the routes grouped by resource with HTTP verb. I ran &lt;code&gt;rake routes&lt;/code&gt; and edited the output to get it how I wanted. Fast forward a few API revisions with new routes and routes removed. Doing this process over and over again would be very tedious. Here&amp;#8217;s what I wanted to generate:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GET    /accounts/:id
PUT    /accounts/:id

POST   /users/:user_id/follow
GET    /users/:user_id/feed
GET    /users
GET    /users/:id
PUT    /users/:id
DELETE /users/:id

POST   /contacts/:contact_id/deals
POST   /contacts/:contact_id/notes
POST   /contacts/:contact_id/todos
POST   /contacts/:contact_id/follow
GET    /contacts/:contact_id/feed
GET    /contacts
POST   /contacts
GET    /contacts/:id
PUT    /contacts/:id
DELETE /contacts/:id

POST   /todos/:todo_id/comments
POST   /todos/:todo_id/reminders
GET    /todos
POST   /todos
GET    /todos/:id
PUT    /todos/:id
DELETE /todos/:id

POST   /deals/:deal_id/comments
POST   /deals/:deal_id/todos
POST   /deals/:deal_id/follow
GET    /deals/:deal_id/feed
GET    /deals
GET    /deals/:id
PUT    /deals/:id
DELETE /deals/:id

POST   /groups/:group_id/todos
POST   /groups/:group_id/follow
GET    /groups/:group_id/feed
GET    /groups
POST   /groups
GET    /groups/:id
PUT    /groups/:id
DELETE /groups/:id

POST   /announcements/:announcement_id/comments
GET    /announcements
POST   /announcements
GET    /announcements/:id
PUT    /announcements/:id
DELETE /announcements/:id

POST   /emails/:email_id/comments
POST   /emails/:email_id/todos
GET    /emails
POST   /emails
GET    /emails/:id
PUT    /emails/:id
DELETE /emails/:id

POST   /sms/:sms_id/comments
POST   /sms/:sms_id/todos
POST   /sms/import
GET    /sms
POST   /sms
GET    /sms/:id
PUT    /sms/:id
DELETE /sms/:id

POST   /ims/:im_id/comments
GET    /ims
POST   /ims
GET    /ims/:id
PUT    /ims/:id
DELETE /ims/:id

POST   /meetings/:meeting_id/comments
POST   /meetings/:meeting_id/todos
POST   /meetings/:meeting_id/reminders
PUT    /meetings/:id/reschedule
PUT    /meetings/:id/cancel
GET    /meetings
POST   /meetings
GET    /meetings/:id
PUT    /meetings/:id
DELETE /meetings/:id

PUT    /invitations/:id/confirm
PUT    /invitations/:id/reject

POST   /phone_calls/:phone_call_id/todos
POST   /phone_calls/:phone_call_id/comments
POST   /phone_calls/import
GET    /phone_calls
GET    /phone_calls/:id
PUT    /phone_calls/:id
DELETE /phone_calls/:id

POST   /notes/:note_id/todos
GET    /notes
GET    /notes/:id
PUT    /notes/:id
DELETE /notes/:id

GET    /reminders
POST   /reminders
GET    /reminders/:id
PUT    /reminders/:id
DELETE /reminders/:id

POST   /campaigns/:campaign_id/follow
POST   /campaigns/:campaign_id/comments
POST   /campaigns/:campaign_id/notes
POST   /campaigns/:campaign_id/call_lists
GET    /campaigns/:campaign_id/feed
GET    /campaigns
POST   /campaigns
GET    /campaigns/:id
PUT    /campaigns/:id
DELETE /campaigns/:id

PUT    /followings/:id/approve
GET    /followings
POST   /followings
GET    /followings/:id
PUT    /followings/:id
DELETE /followings/:id

GET    /products
POST   /products
GET    /products/:id
PUT    /products/:id
DELETE /products/:id

GET    /call_lists
GET    /call_lists/:id
PUT    /call_lists/:id
DELETE /call_lists/:id

GET    /comments
POST   /comments
GET    /comments/:id
DELETE /comments/:id

POST   /bug

POST   /echo&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I also wanted to group them with spaces by the associated resource. This was actually pretty easy to do. I opened up github and hit &lt;code&gt;t&lt;/code&gt; and searched &lt;code&gt;routes.rake&lt;/code&gt; to find the source code. Then subclassed the generator and called it myself. Took a few tries to get all the bugs worked out. The code is pretty easy. Here&amp;#8217;s the finished product. Drop it in &lt;code&gt;api_routes.rake&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;desc &amp;#39;Print out all defined routes used for the api without rails specific information&amp;#39;
task :api_routes =&amp;gt; :environment do
  Rails.application.reload_routes!
  all_routes = Rails.application.routes.routes

  require &amp;#39;rails/application/route_inspector&amp;#39;

  class ApiRouteInspector &amp;lt; Rails::Application::RouteInspector
   def formatted_routes(routes)
      verb_width = routes.map{ |r| r[:verb].length }.max
      path_width = routes.map{ |r| r[:path].length }.max

      routes = routes.reject do |r|
        r[:reqs] =~ /#(new|edit)/
      end

      groups = routes.inject({}) do |set, r|
        section = r[:path].match(/\/([^\/|\(]+)/)[1]

        set[section] ||= []
        set[section] &amp;lt;&amp;lt; r
        set
      end

      groups.values.map do |rs|
        rs.map do |r|
          line = &amp;quot;#{r[:verb].ljust(verb_width)} #{r[:path].gsub(&amp;quot;(.:format)&amp;quot;, &amp;#39;&amp;#39;).ljust(path_width)}&amp;quot;
          line = &amp;quot;#{line}\n&amp;quot; if rs.last == r
          line
        end.join(&amp;quot;\n&amp;quot;)
      end
    end
  end

  inspector = ApiRouteInspector.new
  puts inspector.format(all_routes, ENV[&amp;#39;CONTROLLER&amp;#39;]).join &amp;quot;\n&amp;quot;
end&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then just run &lt;code&gt;bundle exec rake api_routes&lt;/code&gt; and you&amp;#8217;ll have some quick documentation to give to your devs.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Moving on from Rails: Part 2</title>
      <link>http://broadcastingadam.com/2011/12/moving_on_from_rails_part2</link>
      <pubDate>Sun, 04 Dec 2011 00:00:00 +0100</pubDate>
      <author>me@broadcastingadam.com (Adam Hawkins)</author>
      <guid>http://broadcasting.com/2011/12/moving_on_from_rails_part2</guid>
      <description>&lt;p&gt;I was quite surprised by how much feedback I received on the original &lt;a href='http://broadcastingadam.com/2011/11/moving_on_from_rails'&gt;post&lt;/a&gt;. You should read the first one before reading this. I&amp;#8217;m writing this post to respond to some common questions, points, and concerns.&lt;/p&gt;

&lt;h2 id='setting_the_record_straight'&gt;Setting The Record Straight&lt;/h2&gt;

&lt;p&gt;It seems the point of the previous post has been lost in the title. I guess this my fault. I am not quitting or bashing Rails. I am &amp;#8220;moving on from Rails&amp;#8221; because it is becoming increasingly less integral to how I construct my applications. My applications are JSON based communicating over HTTP. I still use Rails for all my web based projects with different components added/removed based on the application&amp;#8217;s requirements.&lt;/p&gt;

&lt;p&gt;Rails is becoming less important because I no longer rely on it to be my &lt;strong&gt;application.&lt;/strong&gt; I try to use &lt;code&gt;ActionPack&lt;/code&gt; as an interface to my code which is &lt;strong&gt;not&lt;/strong&gt; bound to Rails in anyway. In this setup, I do not the traditional full stack setup. I don&amp;#8217;t use &lt;code&gt;ActiveRecord&lt;/code&gt; and I don&amp;#8217;t use &lt;code&gt;ActionView&lt;/code&gt;. I continue to use Rails mainly because of &lt;code&gt;ActionPack&lt;/code&gt; since it&amp;#8217;s (from my experience) the easiest way to handle and respond to HTTP requests.&lt;/p&gt;

&lt;p&gt;Oh, I use &lt;code&gt;ActiveModel&lt;/code&gt; a ton because it&amp;#8217;s awesome as. I also use tons of pits and pieces from &lt;code&gt;ActiveSupport&lt;/code&gt; because &lt;code&gt;#present?&lt;/code&gt;, &lt;code&gt;#blank?&lt;/code&gt; and &lt;code&gt;#underscore&lt;/code&gt; etc are just too handy when you&amp;#8217;re doing programming with strings.&lt;/p&gt;

&lt;h2 id='alternatives'&gt;Alternatives&lt;/h2&gt;

&lt;p&gt;I was surprised (again) by how many blasted me about &lt;strong&gt;not suggesting&lt;/strong&gt; alternatives. I didn&amp;#8217;t know I supposed to. Still, I don&amp;#8217;t suggest any alternatives because I don&amp;#8217;t think there are any for the way I structure my applications. I could use Sinatra (and I do) in less complicated scenarios. I like controller classes. I like &lt;code&gt;routes.rb&lt;/code&gt;. With 30+ controllers and easily over 100 routes I think that would become an unweildly application. Sinatra is probably closer to what I want, but I&amp;#8217;d end up building stuff from &lt;code&gt;ActionPack&lt;/code&gt; into the application just to make it work. Someone also suggested: &lt;a href='http://reneerb.com/'&gt;Renee&lt;/a&gt; but I have yet to play with it.&lt;/p&gt;

&lt;h2 id='tunnel_vision'&gt;Tunnel Vision&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;This seems to be a recurring pattern with developers who have &amp;#8220;discovered&amp;#8221; design and architecture through frameworks and can not seem to separate that from the tools used.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I completely agree with that statement. I think this especially true of &lt;em&gt;any&lt;/em&gt; full stack framework. If you are introduced to web development through that stack and work with only that stack for a very long time, it will be very hard to separate yourself from that train of thinking. This has happened to me and only has significantly changed after building much larger and more complicated web applications.&lt;/p&gt;

&lt;p&gt;The other day I was speaking to someone who could not separate models from database tables. There is no actual MVC going on there. Many people think that models are just a wrapper around persistence. There is no concept what does this model actually &lt;strong&gt;do.&lt;/strong&gt; What does it represent in your application? How does it interact with other models? Does it even need to be persisted? Tunnel vision is not unique to Rails, but I think it effects many new programmers who fall in love with the framework and use it for years.&lt;/p&gt;

&lt;h2 id='php'&gt;PHP&lt;/h2&gt;

&lt;p&gt;I don&amp;#8217;t like PHP. I used to love PHP because it let me do all sorts of cool stuff. I could create variable variables (I have no idea why that exists.) plus all the other trickery you can do in the language. After having programmed in a few more languages over the years, now I think that PHP is fundamentally flawed as a language. Therefore, I have no interest in using it or following it.&lt;/p&gt;

&lt;p&gt;There are plenty of people who get paid good money write PHP. I&amp;#8217;m sure there are plenty of them who love PHP. I&amp;#8217;m sure there are plenty of them who love CakePHP or whatever framework they use (if they use it). Great for them. As long as &lt;strong&gt;you&lt;/strong&gt; are happy with whatever you do and whatever tools you use then good for you.&lt;/p&gt;

&lt;h2 id='replying_to_dor'&gt;Replying to Dor&lt;/h2&gt;

&lt;p&gt;Dor wrote his own &lt;a href='http://www.tikalk.com/incubator/blog/defense-rails-replying-moving-rails'&gt;post&lt;/a&gt; in response to mine. Since he was nice enough to write a post which is much longer than a tweet, I&amp;#8217;ll reply in long-form.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;So I think Adam is exaggerating and I think I can understand him but it seems to me he is looking for an answer at the wrong place. I am also not sure what is the alternative that he&amp;#8217;s suggesting&amp;#8230;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I&amp;#8217;ve found the answer to what I need. &lt;code&gt;ActionPack&lt;/code&gt; is the answer.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;During the last 6 years there were so many posts of that kind&amp;#8230; but the music is still on.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The music is still on, but the tune has drastically changed. You don&amp;#8217;t scaffold anymore. There was no MongoDB. There was no such things as &amp;#8220;JavaScript clients.&amp;#8221; New user expectations and technologies have changed the a web framework&amp;#8217;s role. You can see this with 3.1 with inclusion of the (much maligned) asset pipeline and seperation of ActiveModel into an abstract concept reusable in other applications.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I am nt sure why someone want to write such a negative post, to me it seems like a waste of time. Why don&amp;#8217;t you write how much you enjoy the new JackRobinson(tm) technology and its remarkable advantages over Rails&amp;#8230;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I don&amp;#8217;t consider it a negative post at all. I think it is an interesting post which talks about the changing structure of web applications.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;For example, the natural way in which CoffeeScript was made a default on Rails 3.1 stack. In many languages you can pull the first element of an array with the method &lt;span /&gt;#first. Did you know that in Rails you can also do &lt;span /&gt;.second, &lt;span /&gt;.third and so on until 40-something? DHH, before he&amp;#8217;s a technology guy, he&amp;#8217;s a great product and he thinks about the developers, that&amp;#8217;s what I like most about Rails. Man, he&amp;#8217;s the g&amp;#8211; d&amp;#8212; Steve Jobs of development.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Coffescript is ok. It&amp;#8217;s cool that decided to make assets first class citizens in Rails 3.1. However, I think the asset pipeline is not going to be used when developer API based applications. Why do I need the asset pipeline to serve assets if all care about is JSON? Hell, why would I even worry about keeping assets in source control? It doesn&amp;#8217;t make sense. These are two completely independent concepts. I use Rails to serve JSON. Something else does whatever else. You can have a single nginx box serving up static JS all day. I don&amp;#8217;t mess with that at all. That&amp;#8217;s what makes Rails &lt;strong&gt;great.&lt;/strong&gt; You can just that off. I turn it off and pay no attention to it. I think the asset pipeline is generally a useless feature for developing modern applications.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I agree today the web is much more about client-side but that&amp;#8217;s what backbone.js and spine.js are doing, extending Rails.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;These things have nothing to do with Rails at all. There is a complete separation of concerns. They do not extend Rails at all. They extend ANY HTTP based application. I could have an assembly program serving up JSON it makes no difference. Backbone/Spine/Knockout/what have you simply make it easier to create modern interactive UI&amp;#8217;s in the browser.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;As for Ruby, the 1.9x version is fast and slick&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Totally. 1.9.3 is a huge improvement over 1.8.7. I wish they would&amp;#8217;ve just skipped what 1.9.0,1,2 and went to right to 1.9.3 :D&lt;/p&gt;

&lt;p&gt;One final note about writing Rails applications: most of the fun and handy things you can do in code are done by ActiveSupport.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;All in all, I believe there is place for many flavours. Just like in real life, mongrels are better than pure-breeds. The environments learn from each other and so improve each other and everyone are happier :)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Agree. Rails developers will learn to adapt framework to fit there needs or they will simply move on.&lt;/p&gt;

&lt;h2 id='summing_it_up'&gt;Summing It Up&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;tl;dr - web development is changing, the frontend side of things is gaining significance, while the backend is moving to, well, the background. No reason to be surprised there, right?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;bphogan does a nice job cutting to the point as well:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This is less about moving on from Rails and more about moving on from building static pages from a database. Lots of web folks have been predicting this. I&amp;#8217;ve been saying for about two years now that the days of serving entire HTML pages from the serverside are numbered. With things like Backbone, I can bring up a Rails app without views and do something pretty awesome. &lt;strong&gt;And then it becomes a question as to what Rails offers.&lt;/strong&gt; (I bolded that for emphasis)&lt;/p&gt;

&lt;p&gt;I love Rails. It got me back into web app development in 2005 after nearly burning out. But Rails isn&amp;#8217;t exactly keeping up and people who need to move on are going to do that.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Div does a better job of summing up my thoughts than I can do. Props man:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;It seems like the title is a bit poorly chosen.&lt;/p&gt;

&lt;p&gt;The author talks about the importance of having a platform to cater to the multitude of devices and other apps out there, and that this means rails isn&amp;#8217;t the center of the universe anymore.&lt;/p&gt;

&lt;p&gt;To me, this does not necessarily mean moving on from rails.&lt;/p&gt;

&lt;p&gt;It does mean moving on from writing all code in rails.&lt;/p&gt;

&lt;p&gt;There could be a fullfledged backbone.js app powering a responsive ui, and a distributed clojure jobqueue making sure messages are fanned out to their destined networks in the backend. However, there is still room in this picture for Rails as a router of sorts.&lt;/p&gt;

&lt;p&gt;Rails still makes it easy to quickly build a solid REST api, and easy to delegate long-running jobs to a separate system, in this type of architecture, Rails would have roughly a third of the responsibility / code that it has in a Rails only architecture, but it&amp;#8217;s still a vital component.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I hope that his post clarified the original. Now we can all move on with our lives :D&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Moving on from Rails</title>
      <link>http://broadcastingadam.com/2011/11/moving_on_from_rails</link>
      <pubDate>Sat, 26 Nov 2011 00:00:00 +0100</pubDate>
      <author>me@broadcastingadam.com (Adam Hawkins)</author>
      <guid>http://broadcasting.com/2011/11/moving_on_from_rails</guid>
      <description>&lt;p&gt;I&amp;#8217;ve been doing Rails since 2006. My skill level and the framework as changed greatly since. I came from PHP web sites and Java through academics. Ruby was breath of fresh air. Rails was a thing a of beauty. It was exactly what I needed at the time. Now times are different.&lt;/p&gt;

&lt;h2 id='a_changing_web_yields_changing_requirements'&gt;A Changing Web Yields Changing Requirements&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;EDIT&lt;/strong&gt;: I&amp;#8217;ve written a follow up to this post that can be found &lt;a href='http://broadcastingadam.com/2011/12/moving_on_from_rails_part2'&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Web developers know there is an &lt;em&gt;incredibly&lt;/em&gt; high turnover rate in technologies. Think about to 6 months ago. Did you know about Coffeescript? What about backbone.js? What about websockets/push? Not all of those things are technologies. Coffeescript is not a technology, it&amp;#8217;s just a nice layer on top of Javascript. It is not a new technology like HTML5 Websockets. Socket based communications are not new by any means, but they are new for us since we can use them in the browser.&lt;/p&gt;

&lt;p&gt;Did you also notice how all the things I rattled off were purely related to JavaScript? This isn&amp;#8217;t a purely server side driven game anymore. The paradigm is shifting in how we architect modern internet applications. Before we got to where we are now we have to know where we came from.&lt;/p&gt;

&lt;p&gt;I was coming from PHP. PHP was shit then and is still shit now. I just I think this is a common story for many Rails guys. I didn&amp;#8217;t realize how shitty PHP as &lt;em&gt;language&lt;/em&gt; was until I started learning Ruby through Rails. At the time, Rails was exactly what many devs wanted. It made common tasks like generating basic CRUD interfaces. You could simply scaffold and start building (but I never recommend that), but you &lt;em&gt;could&lt;/em&gt; do it. It made managing a DB easy. There was &lt;code&gt;schema.rb&lt;/code&gt;. There were ActiveRecord associations. ActionController and AJAX handling. It did everything and it made a huge splash in the industry. Rails made such a big impact it was able to drive the growth of 37signals into a major powerhouse. There are hundreds of committers and the framework is still very popular and useful. It made building Web 2.0 quick and easy. Hell, the generated application greets you with: &amp;#8220;you&amp;#8217;re riding on Rails.&amp;#8221;&lt;/p&gt;

&lt;p&gt;I look back on those days fondly. It was a much more simple time. The barrier to enter the market was low. You could churn out SaaS services so quickly. Generate a rails app, throw up some scaffolds, and boom. There ya go. Zero to sixty faster than an R8. Now things are different.&lt;/p&gt;

&lt;p&gt;Think back to when Rails first came out. There was no iPhone. There was no Android. People still owned Nokias and actually bought stock in the damn company. Windows XP was still massively popular and we were &lt;strong&gt;fighting&lt;/strong&gt; to get a decent version of IE (but that will never end). There was no such thing as a mobile web. No one was thinking about tablets. How old is the iPad? Not very old. The web has drastically changed due to the smartphone explosion. This is only the first step in a true multiplatform internet. A few years ago you could get by with having a mobile version of your web app. Now that&amp;#8217;s not enough. That concept is almost laughable today. The bar is set pretty high. People expect applications for different devices. This is unfortunately our fault since we&amp;#8217;ve trained them. I was just on &lt;a href='http://www.lemon.com'&gt;lemon.com&lt;/a&gt; while showing it to my boss. There is a huge picture of numerous devices. People are off their computers now. Now it&amp;#8217;s simply not enough to build a web application. You need to build a service. You need to build your own platform to build your own applications off of. You will not survive if you don&amp;#8217;t. The changing web yields new requirements in how we design and structure modern applications.&lt;/p&gt;

&lt;h2 id='soa_platforms_then_applications'&gt;SoA Platforms then Applications&lt;/h2&gt;

&lt;p&gt;Service oriented architecture has always been very fascinating concept. Jeff Bezos was way ahead of his time when he basically pulled a Hitler and dictated that everything would switch over to SoA. We are at point in the web where platforms represent core business value. You need to have a platform that&amp;#8217;s accessible on any device either natively or with a browser. So now you&amp;#8217;re faced with a question. How can you develop your platform and expose to different devices: HTTP. I like HTTP and I make my platforms speak HTTP. We can use HTTP to create JS applications for browsers. We can also use HTTP to communicate with an external system through OS level code. You can build a native application on Android backed by an HTTP service. You can build your JS application backed by HTTP. Don&amp;#8217;t think that the browser is the only answer. Not every single application can exist in the browser. What if you need to write files? What if you need to access hardware? The browser is not the be-all &amp;amp; end all of internet applications. People will always be creating native applications. So don&amp;#8217;t look at everything purely through the: HTML5 and JS lens. Sometimes applications need more.&lt;/p&gt;

&lt;p&gt;I think many developers are realizing this. You can see it with things like Sproutcore (much love to SC) and Backbone. Less so than backbone and more so with SC &amp;lt; 2. There is this revolution in MVC on the client. Ya, you could call it that, but really it&amp;#8217;s the beginning of a wall being built between clients and servers. Backbone is becoming increasingly popular for good reasons. It allows developers to make javascript applications with nice MVC trimmings. But it&amp;#8217;s more than that. It makes people structure and organize their javascript as an application, and not simply a hodepodge of event bindings and AJAX related trickery. Applications are now being built in Javascript. This trend will only continue. Why? Because the interfaces are fucking fast. Things happen on the user&amp;#8217;s computer and can be persisted back to the server later. Hell, Sproutcore even abstracted HTTP persistence completely out of the framework. There is a clear separation of concerns. The platform processes data and serves up JSON. Then end programs actually do all the &amp;#8220;work&amp;#8221; by presenting UI&amp;#8217;s and all that good stuff. And now you&amp;#8217;ve built the first consumer for your platform. With Sproutcore you may even build the entire application without even conntecting it to a server. At that point, you&amp;#8217;re able to treat persistence as an implementation detail which drastically changes the way you think.&lt;/p&gt;

&lt;h2 id='http_backed_services'&gt;HTTP Backed Services&lt;/h2&gt;

&lt;p&gt;HTTP backed services are inherently easy to write and manage. They are much easier to write than traditional web applications because you do not have to worry about V&amp;#8211;just MC. From my experience, generating a good UI (V) takes orders of magnitude more than implementing M and C. HTTP is perfect because you only have to worry about garbage in and garbage out. In Rails, this means you really only care about &lt;code&gt;params&lt;/code&gt; and &lt;code&gt;respond_with&lt;/code&gt;. Data in and data out. Now, when I look at these API&amp;#8217;S I look at the responsibility to the end developer: return JSON. That is it. A single focus: return JSON. Of course there is processing involved but the main point is return JSON that end application can use for it&amp;#8217;s own purposes. That makes developing this very easy because it removes many other requirement and makes you think about a fundamental thing: HTTP is only how the outside talks to my code. My application is not HTTP and it&amp;#8217;s certainly not just HTML and JSON. This is only how I talk to the outside world. The code can be something totally different. You could have nginx talking to a haskell application. No one cares as long as the parameters and data coming out are according to spec. This has been extremely freeing for me because I no longer think &lt;strong&gt;rails is my application.&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id='changing_how_we_code'&gt;Changing How We Code&lt;/h2&gt;

&lt;p&gt;Avdi Grimm verbalized some of my current feelings in this regard. His object on Rails paper goes through the entire process of creating a blog using OOP techniques. The code is developed completely outside of Rails. Rails isn&amp;#8217;t even introduced. Models are derived completely on their own. Collaborators and responsibilities are defined as well. Slowly the system takes shape. First you need ActiveModel for some validations. Everything is going well. Eventually you&amp;#8217;re going to need persistence. He treats &lt;strong&gt;persistance&lt;/strong&gt; as an implementation details Mdoels are more than ActiveRecord! Your code is more than Rails. Rails is not your code. You can and &lt;strong&gt;should&lt;/strong&gt; develop the business logic completely on your own ISOLATED from whatever code you&amp;#8217;ll eventually use to allow the outside world to consume your service. Corey Haines started something called fast tests. Fast tests are great. Everyone loves them. They make tdd faster blah blah. His essential point was to move code out of Rails into Ruby modules that can be tested in isolation. This is a step in the right direction but I think it&amp;#8217;s a very small one. You should go all out and simply move your code out of &lt;em&gt;whatever&lt;/em&gt; framework you&amp;#8217;re eventually going to use. I highly recommend Avdi&amp;#8217;s paper on &lt;a href='http://avdi.org/devblog/2011/11/15/early-access-beta-of-objects-on-rails-now-available-2/'&gt;Objects on Rails&lt;/a&gt; to see a very refreshing approach. The continuing theme here is dividing parts of your eventual platform. Most important is splitting access from application.&lt;/p&gt;

&lt;h2 id='moving_away_from_rails'&gt;Moving Away From Rails&lt;/h2&gt;

&lt;p&gt;Rails has always been fantastic at one thing: accepting, handling, and returning body for a HTTP response. What you choose to put that body has always been up to you. Just recently, it&amp;#8217;s been assumed you&amp;#8217;re going to generate HTML. Now I just want to generate JSON. Designing my HTTP based services only require two things:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Accept http requests&lt;/li&gt;

&lt;li&gt;Give me a nice API for determine response code and response body.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Rails has always been fantastic at those two things. But now, I do the rest. I&amp;#8217;m not really worried about ActiveRecord. Let me handle the models. I don&amp;#8217;t need ActionView. There are a lot of things I don&amp;#8217;t need from Rails anymore. I think that&amp;#8217;s good. What makes Rails 3 great is you can modularize it by removing (or including) components. Now I can get the most out of Rails by making it fit my requirements. But that&amp;#8217;s it. I no longer think Rails is my application. It&amp;#8217;s just a nice thing for handling how it&amp;#8217;s accessed.&lt;/p&gt;

&lt;h2 id='moving_on_in_life'&gt;Moving on in Life&lt;/h2&gt;

&lt;p&gt;I&amp;#8217;ve become increasingly disinterested with Rails over the past while. This is nothing to do with the framework itself. It&amp;#8217;s just no longer related to my core interests. A few years ago, it was my only interest. It was simply how you build web applications. That time has come and gone. Now we are faced with applications with more diverse requirements. You may have a Rails based application for handling the majority of web requests working in conjunction with a Node process for evented stuff. Hell, you may at some point even have processes in different languages which have been optimized for different things. Look at Twitter with Scala. There are many permutations of different technologies for different requirements. There will be more permutation as the way we architect the modern web. For me, and I think many others, Rails will become and increasingly smaller piece of the puzzle. Why? Simply because their platform is more than Rails. Now I focus on other questions. Rails answers some of them, however I&amp;#8217;m finding it&amp;#8217;s the answer less and less.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Reviewing Rails 3 in Action</title>
      <link>http://broadcastingadam.com/2011/11/reviewing_rails3_in_action</link>
      <pubDate>Mon, 21 Nov 2011 00:00:00 +0100</pubDate>
      <author>me@broadcastingadam.com (Adam Hawkins)</author>
      <guid>http://broadcasting.com/2011/11/reviewing_rails3_in_action</guid>
      <description>&lt;p&gt;&lt;a href='http://ryanbigg.com/'&gt;Ryan Bigg&lt;/a&gt; is writing a book called &lt;a href='http://manning.com/katz/'&gt;Rails 3 In Action&lt;/a&gt;. I&amp;#8217;ve been lucky enough to help read the book and generally review its contents while it&amp;#8217;s been written. I consider myself an advanced Rails developer, so when I read books like this I look for them to cover specific things that new developers need to know and how well the example integrate best practices. In this post, I review &lt;a href='http://www.manning.com/katz/'&gt;Rails 3 in Action&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id='about_the_book'&gt;About the Book&lt;/h2&gt;

&lt;p&gt;Rails 3 in Action is written to give people interested in learning Rails an indepth look into creating a basic Rails application using TDD. The book is divided into three sections and one appendix. Here is the table of contents:&lt;/p&gt;

&lt;h3 id='part_1_getting_rolling'&gt;Part 1: Getting Rolling&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Ruby on Rails, the Framework&lt;/li&gt;

&lt;li&gt;Testing Saves Your Bacon&lt;/li&gt;

&lt;li&gt;Developing a Real Application&lt;/li&gt;

&lt;li&gt;Oh CRUD!&lt;/li&gt;

&lt;li&gt;Nested Resources&lt;/li&gt;

&lt;li&gt;Authentication and Basic Authorization&lt;/li&gt;

&lt;li&gt;More Authorization&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id='part_2_putting_on_the_bling'&gt;Part 2: Putting on the Bling&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;File Uploads&lt;/li&gt;

&lt;li&gt;Tracking State&lt;/li&gt;

&lt;li&gt;Tagging&lt;/li&gt;

&lt;li&gt;Sending Email&lt;/li&gt;

&lt;li&gt;Designing an API&lt;/li&gt;

&lt;li&gt;Deployment&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id='part_3_further_enhancements'&gt;Part 3: Further Enhancements&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Alternative Authentication&lt;/li&gt;

&lt;li&gt;Performance Enhancing Basics&lt;/li&gt;

&lt;li&gt;Engines&lt;/li&gt;

&lt;li&gt;Rack Applications&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I was really looking forward to this book because the authors planned on covering more advanced topics. That way, the new readers can go from zero knowledge to going through an overview on advanced topics. The beginning chapters are well written and cover all the basics. The advanced chapters are very imformative. The engines chapter is most likely the best documentation to how to write an engine except existing code. One reason I really like this book is because current and popular gems are covered throughout the book. Devise, Paperclip, Cucumber, and RSpec are used throughout the book. I think this gives the book a very current feel and reflects what developers are doing at this point.&lt;/p&gt;

&lt;h2 id='part_1_getting_rolling'&gt;Part 1: Getting Rolling&lt;/h2&gt;

&lt;p&gt;I can honestly say that the first four chapters of this book are the best at showing how to wire up a Rails application. New developers are often confused by all the various moving wheels. They have questions like: how can I call code from a URL? What is a route anyways? What goes in a controller? How do I make a new model? How do I make a form? These are all very basic questions that must be answered before anyone can start making real applications. Bigg answers all these questions and more. He starts by giving an overview of the Rails framework and covers these Rails principles:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Convention over Configuration&lt;/li&gt;

&lt;li&gt;REST&lt;/li&gt;

&lt;li&gt;MVC.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;It&amp;#8217;s very important to cover these ideas upfront so readers are well aware of recurring themes in the book. The author demonstrates how to create a very basic application. This is where the stage is set for creating the example application. All important steps and pieces are introduce before moving on to the next step. Ryan covers all these basic parts:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Installing&lt;/li&gt;

&lt;li&gt;Using a generator to create an application&lt;/li&gt;

&lt;li&gt;Starting&lt;/li&gt;

&lt;li&gt;Scaffolding&lt;/li&gt;

&lt;li&gt;Migration&lt;/li&gt;

&lt;li&gt;Views&lt;/li&gt;

&lt;li&gt;Validations&lt;/li&gt;

&lt;li&gt;Routing&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;These small portions are very effective because it demonstrates how to do common tasks. All new developers should know how to do these things before continuing onto the next step. This brings me to why this is &lt;strong&gt;my favorite Rails book I&amp;#8217;ve ever read.&lt;/strong&gt; The book uses pure TDD to develop the demo applications.&lt;/p&gt;

&lt;p&gt;The next chapter is &amp;#8220;Testing Saves Your Bacon.&amp;#8221; The author goes through a small example of using RSpec for unit testing. He describes BDD. BDD stands for &amp;#8220;Behavior Driven Development.&amp;#8221; It is essentially the same thing as TDD, except tests respresent documentation and are readable by stake holders. You can express this in code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class TestDriveDevelopment

  def strategy
    write_a_test(requirements)
    while(test_failing)
      write_implementation(test)
      run_test_suite
    end
  end
end

class BehaviorDrivenDevelopment &amp;lt; TestDrivenDevelopment
end&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The testing saves your bacon chapter is very short and suite. It&amp;#8217;s only real purpose it to introduce Cucumber and RSpec. (More information on BDD &lt;a href='http://pragprog.com/titles/achbd/the-rspec-book'&gt;here&lt;/a&gt;) Now that the reader knows the basics of using these test frameworks, they can move through an excerise in creating the scaffold for a real application.&lt;/p&gt;

&lt;p&gt;Before, the reader only used a generated application to move through the basic motions. Now it&amp;#8217;s time to set the stage for creating the application used throughout the book. I like this chapter because it covers things that are usually overlooked. The author mentions the book will use Git. I find it funny that this fact is given very little attention and is more annecdotal than anything else. Granted this is not a book on version control, but I think that spending more time on why developers should use version control would be beneficial&amp;#8211;especially because some readers may have no version control experience.&lt;/p&gt;

&lt;p&gt;The sample application is a ticket tracking app. It is a &lt;em&gt;very&lt;/em&gt; slimmed down version of &lt;a href='http://lighthouseapp.com/'&gt;Lighthouse&lt;/a&gt;. Ryan describes the application in high level terms that can be translated to automated acceptance tests. The rest of this section contists of writing cucumber features and then their implentation. This process is informative for new users.&lt;/p&gt;

&lt;p&gt;There is one downside to these early sections. A large number of new tools are introduced. This may be confusing for brand new Rails developers. I&amp;#8217;ve run into this problem before when I teach Rails. I use the same technique: Teach Rails using TDD with Cucumber and RSpec. I&amp;#8217;ve noticed that new developers think all these tools &lt;strong&gt;are Rails.&lt;/strong&gt; This is not the case. The case is also complicated by the fact that Cucumber uses Capybara to drive a browser. The line between all the different tools blurs for new developers. This is not a problem with this book, but a problem with any type of learning that overloads people with new things at the beginning. I don&amp;#8217;t think there is anyway to get around this. It is very important to introduce all these concepts and tools in the beginning. The book can spend more time clearly defining each role the tools plays. I&amp;#8217;ve found that the link between Cucumber and Capybara difficult. The readers will have a good understanding all the tools by the time they finish the book, but I think it&amp;#8217;s wise to put more time up front explaining each tool and why Rails developers use them.&lt;/p&gt;

&lt;p&gt;Now, that I have off my chest, I can cover the best examples for learning how to do basic CRUD I&amp;#8217;ve ever seen. Chapters 4 &amp;amp; 5 are magnificent peices of work. I wish I could give some my students these chapters because they cover creating/viewing/editing/deleting in TDD fashion so well. I think these chapters work so well for a few reason. Readers may have a basic idea through previous experience, but they generally are familar with creating a new record in a computer system. New Rails programmers do not know how to make this process work. They know what they want to do, but now how to do it. Since the author uses TDD, he writes the test case first. The test suite is run. This shows that system does not currently support that use case. At this point, the reader has a very clear idea of what they are adding to the system. Then the implementation is written to make the test case pass. &lt;strong&gt;This demonstrates precisly what code is required to do each use case.&lt;/strong&gt; This is process is very helpful because the reader will know &lt;strong&gt;exactly&lt;/strong&gt; what the did to complete the use case. It also demonstrates the power of having a test suite that covers the application so futher development does not break existing functionality. After finishing the reader finishes this chapter they will have good understanding of these concepts:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Implementing RESTful routes&lt;/li&gt;

&lt;li&gt;Using routing helpers to link to different pages&lt;/li&gt;

&lt;li&gt;How to render new views&lt;/li&gt;

&lt;li&gt;How to use partials&lt;/li&gt;

&lt;li&gt;How to connect routes to controllers&lt;/li&gt;

&lt;li&gt;And Most Importantly: How to do it all test first.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;These are the fundamental skills all Rails developers should have. I guartenee that after reading this chapter you will know how to do CRUD.&lt;/p&gt;

&lt;p&gt;The next chapter &amp;#8220;Nested Resources&amp;#8221; covers associations and building tickets for associated projects. This is essentially the same as the previous chapter, except for creating models that must be associated with other models. The Ticketee application has a &lt;code&gt;Project&lt;/code&gt; model. A &lt;code&gt;Project&lt;/code&gt; has many &lt;code&gt;Tickets&lt;/code&gt;. This chapter covers nested routes and the basic of handling models with associations. It covers all the CRUD options as well.&lt;/p&gt;

&lt;p&gt;After the &amp;#8220;Nested Resources&amp;#8221; chapter all foundation is there for creating a more complicated functionality. Every application allows users to log in. Once you can determine that someone is logged in, then it makes sense to allows specific users to do specific things. This describes authentications vs authorization. Part 1&amp;#8217;s final two chapters cover this topic in depth. And, god damn. These chapters are long.&lt;/p&gt;

&lt;p&gt;The book uses &lt;a href='https://github.com/plataformatec/devise'&gt;Devise&lt;/a&gt; to handle user registration/sign in/sign out/confirmation. It is currently the go-to solution for authenticating users inside Rails application. It is a Rails 3 engine. This fact is important because it it referenced later in the &amp;#8220;Engines&amp;#8221; chapter. The chapter follow the same flow as the others: Write a test for a new feature. Implement the code to make it pass. Chapter 6 covers creating users and allowing them to login. Basic access control is added. Namespaced controllers are introducted in this chapter. This is a helpful concept because it helps keep controllers organized. Once the groundwork is set, Admin users are created and a basic permissions system it implemented. This chapter is very informative. I felt it was much longer than it needed to be. Chapter 6 seems to drag on forever, where all the previous chapters are snappy and too the point. Once I got to part about creating Admin users, I had to skip ahead to see how much is left. I think the second half of this chapter could be split into it&amp;#8217;s own section. The author fits a ton of information into this chapter. It may be too much for some readers.&lt;/p&gt;

&lt;p&gt;Chapter 7 is the final chapter in part 1. It covers creating a more complicated persmission system using &lt;a href='https://github.com/ryanb/cancan'&gt;CanCan&lt;/a&gt;. This chapter is well written and thankfully shorter than the previous one. The information it presents is precise and useful.&lt;/p&gt;

&lt;p&gt;Part 1 is really quite good. I can say that first few chapters are some the best I&amp;#8217;ve read on on these topics. At this point the reader has transitioned to Rails newb to somewhere just before the intermediate level. Granted, they cannot be consider true developers until they have experience under their belt, but Part 1 covers all the skills people should have before moving onto the advanced stuff. This is where the book takes a different approach. In the beginning of the book, you did everything yourself. You wrote all the code and wrote all the tests. The last two chapters of part 1 and sections of part 2 focus on leveraging other people&amp;#8217;s code through gems.&lt;/p&gt;

&lt;h2 id='part_2_putting_on_the_bling'&gt;Part 2: Putting on the Bling&lt;/h2&gt;

&lt;p&gt;The first chapter in Part 2 covers uploading files with &lt;a href='https://github.com/thoughtbot/paperclip'&gt;Paperclip&lt;/a&gt;. I like this chapter because it covers adding a feature that is important to serious applications. I also like that the author choose to use popular gems because it reflects current practices. The chapter does a nice job of showing how to implement file uploading &lt;em&gt;and&lt;/em&gt; retreiving correctly. There is one thing I do not like about this chapter. It uses paperclip. Carrierwave would&amp;#8217;ve been a much better choice, but at the time the book was written, paperclip was the best choice. We all know things change fast in the tech world. It&amp;#8217;s very hard when writing a book. Writing a book takes forever by today&amp;#8217;s standards. Rails 3.1 was in development while this book was being written. Hard to stay current sometimes.&lt;/p&gt;

&lt;p&gt;The next two chapters add two features: state tracking and tagging. There is nothing too fancy about these chapters. The book covers writing a state tracking feature from scratch. I was suprised to see this, but I think it&amp;#8217;s good for the new developers to learn how to do this sort of thing. Tagging is very common too. It&amp;#8217;s not hard to implement, but it&amp;#8217;s generally a solved problem so there are plenty of gems. The book covers how to write your own tagging system. It does use the author&amp;#8217;s &lt;a href='http://rubydoc.info/gems/searcher/0.0.6/frames'&gt;searcher&lt;/a&gt; gem to implement simple searching. My guess is the gem was written specifically for the book. I think it was a good choice to write the tagging system by hand and use a gem to create simple search functionality. This doesn&amp;#8217;t distract from the main point: creating functionality to manage tags.&lt;/p&gt;

&lt;p&gt;Chapter 11 is all about email. It provides a well thoughout overview to implementating email functionality inside Ticketee. The reader will learn how to setup an observer (in &lt;code&gt;app/observers&lt;/code&gt; where they &lt;a href='http://broadcastingadam.com/2010/10/app_observers'&gt;should be&lt;/a&gt;). I&amp;#8217;ll admit I got a bit happy when I saw the author add chosen not to put them in &lt;code&gt;app/models&lt;/code&gt;. I mean, why would you? They&amp;#8217;re not models? They&amp;#8217;re not presisted, they are completely separate! I digress. I only have one negative comment to say about this chapter: The book specifically assumes you have a Gmail account. The author also uses the Gmail gem to fetch email from a gmail account. I think it would be better to use the built in Mail retreiver methods instead. This keeps the toolbox small and my be less confusing to new developers. The test cases also involve the network in tests. This should come with a big warning saying: HERE BE DRAGONS! It&amp;#8217;s not good to introduce the network into the test suite because it can create random failtures unrelated to the code. What happens if the connection goes down? Test fails. Is it the code or the network? This should be mentioned.&lt;/p&gt;

&lt;p&gt;When I first started to talk to Ryan about his book he mentioned that he was writing chapters on creating API&amp;#8217;s and deployment. I got really excited when I heard this. Why? Simply because you don&amp;#8217;t see these topics covered in many Rails books. You could write an entire book on only deploying Rails applications&amp;#8211;and they have. You could also write an entire text on creating well crafted HTTP API&amp;#8217;s. Luckily for readers, the author has compressed these very large topics down into manageable portions that you can learn from!&lt;/p&gt;

&lt;p&gt;I think the API chapter is damn good. It&amp;#8217;s simple and straight forward. I think it demonstrates how &lt;strong&gt;easy it is to write RESTful API&amp;#8217;s.&lt;/strong&gt; This is where Rails really shines through. It&amp;#8217;s so easy to return objects in XML or JSON. The author users JSON of course, then easily shows you can serve back XML if you are crazy enough. He also covers how to rate limit it. The RSpec tests read very nicely. The chapter also shows how to create versioned API&amp;#8217;s by using namespace. This chapter is very well put together overall and shows Rail&amp;#8217;s real strenghts. The author left one thing out: The params parser. It would&amp;#8217;ve been nice to create an example application showing how to use the API. The params parser allows developers to POST/GET/PUT/DELETE with JSON/XML as the body of the request. The params parser will parse the text and return the proper data structure. This is an execellent way to pass complicated parameters. This may be outside the scope of the book, but it covers so many cool things I felt this one was left out.&lt;/p&gt;

&lt;p&gt;The deployment chapter is awesome! I think these chapters really make this book stand out because it gives a &lt;strong&gt;complete&lt;/strong&gt; overview being a Rails developer. Here&amp;#8217;s the general process the author goes through:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Setup a VM&lt;/li&gt;

&lt;li&gt;Install RVM&lt;/li&gt;

&lt;li&gt;Install Ruby&lt;/li&gt;

&lt;li&gt;Create a deploy user&lt;/li&gt;

&lt;li&gt;Setup authentication w/SSH&lt;/li&gt;

&lt;li&gt;Install a database&lt;/li&gt;

&lt;li&gt;Using github for deployment (setting deploy keys)&lt;/li&gt;

&lt;li&gt;Using capistrano&lt;/li&gt;

&lt;li&gt;Configuring a web server&lt;/li&gt;

&lt;li&gt;Configuring passenger to serve the Rails application.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;There&amp;#8217;s not really too much to say about this chapter even though it&amp;#8217;s well done. It provides a blueprint for setting up a very basic application server. It is by &lt;strong&gt;no means&lt;/strong&gt; a guide on how to setup a true production grade box. It does show you take a barebones system and throw a Rails app on there. Every rails developer should know how to do this. I consider this a mandatory skill when I think about hiring people&amp;#8211;which is why I&amp;#8217;m so glad the book covers it. After reading this chapter you&amp;#8217;ll know how to do this: Setup Ubuntu with RVM, PostgreSQL, Nginx, and Passenger. This chapter is a good reference for anyone who&amp;#8217;s never done it before.&lt;/p&gt;

&lt;p&gt;That&amp;#8217;s the end of Part 2. Part 3 holds much promise. Personally, I would buy this book for part 3 since that has stuff I&amp;#8217;m interested in. The first two sections do not really apply to me. This is where we get into the advanced stuff&amp;#8211;and I like it.&lt;/p&gt;

&lt;h2 id='part_3_leveling_up'&gt;Part 3: Leveling Up&lt;/h2&gt;

&lt;p&gt;If you already know Rails and want to learn more then this section is for you. It covers some cool stuff that&amp;#8217;s covered in Rails books. This book is book about developing Rails applications and not an exhaustive reference of the framework. Now we get to see how we can start to make our application do much more cool things.&lt;/p&gt;

&lt;p&gt;The first chapter in part 3 describes how to setup external authentication using Devise + OmniAuth (which is seriously awesome). This is a very short chapter because it doesn&amp;#8217;t need to be any longer! That&amp;#8217;s how easy it is to implement third party authentication. After this chapter you&amp;#8217;ll know how to integrate GitHub and Twitter authentication. Not bad for a short chapter.&lt;/p&gt;

&lt;p&gt;The next chapter is on &amp;#8220;Basic Performance Enhancements&amp;#8221;. I think this is the weakest chapter in the entire book. I have a lot of experience working with caching and there are technique that I hoped the author would present, but did not. The title is &amp;#8220;Basic Performance Enhancements&amp;#8221;. The techniques in this chapter &lt;em&gt;are basic&lt;/em&gt; and do not represent performance minded approach. The chapter focuses around the three out of the four Rails caching strategies: Page, Action, and Fragment Caching. The fourth involves Rails.cache which is essentially manual cache operation, but very powerful since you can store anything you like. Ticketee is a very basic application. It needs to be for the purposes of the book. Since it&amp;#8217;s simple, you can use very simple caching techniques. Expiring with sweepers is very easy to do in a simple application. However, it does not account for associated events. For example, say you have a comments controller and tickets controller. If a comment is for a ticket, you&amp;#8217;d have to sweep the ticket from the comments controller. This is not the case in the book, but is the case with using action caching and cache sweepers. I would&amp;#8217;ve liked to see more discussion on these matters.&lt;/p&gt;

&lt;p&gt;Fragment caching is discussed breifely, but not in major detail. It does not into detail on creating different keys for different fragment, but relies on Rails to do the dirty work. This hides some power from the reader. Page caching is mentioned, but rarely application to any legitmate web application. You can read my take on &lt;a href='http://broadcastingadam.com/2011/05/advanced_caching_in_rails'&gt;Advanced Caching in Rails&lt;/a&gt; if you want to see what I think is important. This information is outside the scope of the book. I&amp;#8217;ve included the link as example of how complicated it can become and to show why things were left out of the book.&lt;/p&gt;

&lt;p&gt;The author descides not to use memcached. I think this is a very bad decision. He uses default which provides functionality not available to memcached. The vast majority of people use memcached in production. If they follow the code provided in this chapter it will not work in production systems with memcached. The author uses cache expiration based on a regular expression. This makes it easy to address problems that arise from using cache sweepers. However, it is only applicable to cache stores that can iterate over all keys. Memcached cannot do this. I think this is the chapters biggest flaw because it uses techniques that are not suitable to production applications.&lt;/p&gt;

&lt;p&gt;There is good news. It seems the author is working on addressing these problems. I think he is adding a section on memcached and how to use Rails.cache. I was suprised to see that he did not cover using the cache manually. All the examples are focused around caching HTML or preventing web request from hitting the server. He does not cover using Rails.cache in the model layer for complicated queries for example. I think this bad omission and hopefully will be added before the second printing.&lt;/p&gt;

&lt;p&gt;He discusses two other enhancments. He address the N+1 problem and uses database indexes. The N+1 problem is a very basic performance enhancment. I think it should&amp;#8217;ve been covered earlier in the text because it is not a true performance technique in the sense of implementing caching throughout an application. It does help with performance, but I don&amp;#8217;t think it needs it&amp;#8217;s own section.&lt;/p&gt;

&lt;p&gt;The book also considers pagination a performance enhancment. I don&amp;#8217;t think this is a performance enhancment. Granted, it will increase performance by cutting down the number of objects returned, but it seems more of a usability thing than anything else. Pagination is very simple and should be covered earlier on in the text.&lt;/p&gt;

&lt;p&gt;I can easily forget about the &amp;#8220;Basic Performance Enhancements&amp;#8221; chapter because the &amp;#8220;Engines&amp;#8221; chapter is straigh GODLIKE. I think this chapter is the best one in the book by good measure for a few resons:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;It provides excellent documenation and guidelines for creating engines. This is hard to find at the time of this writing.&lt;/li&gt;

&lt;li&gt;The chapter shows how to test and develop Rails engines correctly.&lt;/li&gt;

&lt;li&gt;It demonstrates Capybara&amp;#8217;s raw power as a browser driver.&lt;/li&gt;

&lt;li&gt;It makes you think about componentizing your application.&lt;/li&gt;

&lt;li&gt;It shows you to release it as a gem. How many other books have you seen do this? It&amp;#8217;s this kind of thing that makes this book awesome.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The only downside is: it&amp;#8217;s god damn long. There is a ton of information in this chapter. It doesn&amp;#8217;t feel long like the Authentication &amp;amp; Authorization chapter. It just owns. If you want to learn about engines. &lt;strong&gt;Read this chapter&lt;/strong&gt;. It&amp;#8217;s that good.&lt;/p&gt;

&lt;p&gt;The &amp;#8220;Rack-Based Applications&amp;#8221; chapter is nicely written. It opens the hood to some of the undercover magic going on between Rails and the webserver. It&amp;#8217;s a relativly short chapter, but does a nice job introduction conepts and showing you how you can write the most basic rack application. It shows you can you mount Rack applications in Rails and most importantly introduces middleware. It would be nice to see a real application of middleware, but it&amp;#8217;s hard to find one for a simple application. The book shows how you can inject a peice of middleware to jumble the links. Nothing serious really&amp;#8211;just a proof concept. I&amp;#8217;m not sure what else the book could add to this chapter.&lt;/p&gt;

&lt;h2 id='part_4_wrapping_up'&gt;Part 4: Wrapping Up&lt;/h2&gt;

&lt;p&gt;There are some interesting tidbits in the end, but nothing really worth mentioning. The meat the book is the first 10 chapters. Things after that become more complicated and therefore take more time to cover and increase the scope of text. For instance: Deployment and designing an API can be separate books. It&amp;#8217;s very hard to do them justice in a small time frame. That being said, the first chapters are absolutely fantastic! I think the first chapters do a wonderful job of teaching people how to build basic rails application. This is by no means a guide to building advanced applications but it will teach noobies how to get going.&lt;/p&gt;

&lt;h2 id='who_should_buy_this_book'&gt;Who Should Buy This Book?&lt;/h2&gt;

&lt;p&gt;You should buy this book if you are a newbie with little to no knowledge on Rails. This book will teach you everything you need to know to help you start your journey. You will also become familar with some intermediate concepts along the way. You will also learn it all test first which will help you in the long run.&lt;/p&gt;

&lt;p&gt;Finally Shoutout: To Ryan Bigg for letting my get in on the writing process and helping him make his book better.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;You can buy the book &lt;a href='http://www.manning.com/katz/'&gt;here&lt;/a&gt;.&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Dear God?! What is this Bug?</title>
      <link>http://broadcastingadam.com/2011/10/dear_god_what_is_this_bug</link>
      <pubDate>Fri, 28 Oct 2011 00:00:00 +0200</pubDate>
      <author>me@broadcastingadam.com (Adam Hawkins)</author>
      <guid>http://broadcasting.com/2011/10/dear_god_what_is_this_bug</guid>
      <description>&lt;p&gt;A few days ago I had to do a very trivial task. One of my coworkers has translated our Rails app into finnish. He sent me the &lt;code&gt;fi.yml&lt;/code&gt; file for me to add the application. I thought this process would take maybe ~30 mins. Turns out it took me &lt;strong&gt;5 hours&lt;/strong&gt;. I&amp;#8217;ll tell you why.&lt;/p&gt;

&lt;h2 id='it_all_started_on_windows'&gt;It All Started on Windows&lt;/h2&gt;

&lt;p&gt;I sent my coworker the existing yml file. I told him to replace the text with the finnish version. He had a hard time just working with the yml file so he made an excel spreadsheet so he could see the existing english text in context. Then he put the finnish version next to it. When he was done he wrote a script to take the finnish columns and create the yml file. Sounds reasonable. I knew there would be formatting mistakes related to tabs, spaces, :&amp;#8217;s etc. So I figured I&amp;#8217;d just have to clean up the file before adding it to the locales. After a few days he sent me the file. Then after a few weeks I had time to put it in&amp;#8211;so I downloaded &lt;code&gt;fi.yml&lt;/code&gt; from gmail and off I went.&lt;/p&gt;

&lt;p&gt;Drop the file in &lt;code&gt;config/locales&lt;/code&gt; and start the server. BOOM. Syntax error. Line #4. Ok, np, open up the file, figure there would be a missing : or something. Nothing jumps out. Stare at it for about 30 minutes. Hmmm&amp;#8230;there&amp;#8217;s &lt;em&gt;got&lt;/em&gt; to be something going on here. Open the file up in textmate so I can see &amp;#8220;invisibles.&amp;#8221; Nothing seems out of place. I convert all tabs to spaces (I know YML parsers are bitchy when it comes to this). Run the server again. Syntax error line #4. Le fu. At this point I have no clue what it could be. I save the file in UTF8 (just to be sure) and convert all line breaks to unix format. Sill no luck. At this point I&amp;#8217;m out of ideas. So I just deleted the first block of text and retyped it. Syntax error line 79! &lt;strong&gt;HUZZAH!&lt;/strong&gt; Progress. Head over to line 79. There are odvious issues which I take care off. All in all it took little over an hour to clean up the 1,000+ line yml file.&lt;/p&gt;

&lt;h2 id='the_server_starts_finally'&gt;The Server Starts Finally&lt;/h2&gt;

&lt;p&gt;Now I&amp;#8217;m ready to see the wondeful finnish version of the application. I open up the settings page and switch the locale to Suomen. Refresh the page and voilla! It&amp;#8217;s in English. Hmmm, this is prolly just a dumb thing I did like forgetting the &lt;code&gt;before_filter&lt;/code&gt; to set the locale or forgetting to save the form. Ya know, something &lt;strong&gt;simple&lt;/strong&gt;. Do the quick status check. Everything is in proper order. My locale is set to &lt;code&gt;fi&lt;/code&gt; in the DB. The &lt;code&gt;before_filter :set_locale&lt;/code&gt; is being hit. Everything on my end seems to be as it should be. Now I have to do the fun stuff which happens way to often on this project: debug framework code. It&amp;#8217;s time to take a dive into &lt;code&gt;I18n.translate&lt;/code&gt; which of &lt;em&gt;course&lt;/em&gt; is modified by Rails for trickery.&lt;/p&gt;

&lt;h2 id='into_the_rabbit_hole'&gt;Into the Rabbit Hole&lt;/h2&gt;

&lt;p&gt;At this point, I just want to find out if the right locale and key is being passed into I18n. After another bit of reading code (and learning about I18n fallbacks) and I see that &lt;code&gt;:fi&lt;/code&gt; is being passed into the various translate functions. So at this point, I know these things.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;My code to manage the locale is correct&lt;/li&gt;

&lt;li&gt;My locale is set to :fi&lt;/li&gt;

&lt;li&gt;The :fi locale is correctly being passed into I18n.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Now that I know this, I&amp;#8217;m able to try to figure out why &lt;strong&gt;every single key&lt;/strong&gt; is falling back to english. After some more code reading I look squarely at this method: (source taken from I18n code)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def lookup(locale, key, scope = [], options = {})
  init_translations unless initialized?
  keys = I18n.normalize_keys(locale, key, scope, options[:separator])

  keys.inject(translations) do |result, _key|
    _key = _key.to_sym
    return nil unless result.is_a?(Hash) &amp;amp;&amp;amp; result.has_key?(_key)
    result = result[_key]
    result = resolve(locale, _key, result, options.merge(:scope =&amp;gt; nil)) if result.is_a?(Symbol)
    result
  end
end&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The underlying code is pretty simple. It loops over the translation keys like: &lt;code&gt;[en, dashboard, subkey, key, key]&lt;/code&gt; to find the actual value in the translations hash. Ok, seems easy enough (recurring theme over the course of this task), throw a debugger in and see what&amp;#8217;s happening.&lt;/p&gt;

&lt;p&gt;So I put a debugger here:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def lookup(locale, key, scope = [], options = {})
  init_translations unless initialized?
  keys = I18n.normalize_keys(locale, key, scope, options[:separator])

  keys.inject(translations) do |result, _key|
    _key = _key.to_sym
    debugger # &amp;lt;---------- Debugger added
    return nil unless result.is_a?(Hash) &amp;amp;&amp;amp; result.has_key?(_key)
    result = result[_key]
    result = resolve(locale, _key, result, options.merge(:scope =&amp;gt; nil)) if result.is_a?(Symbol)
    result
  end
end&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So I restart the server and go to page. My perfectly placed debugger hits and I get the nice rdb prompt. This is where my brain &lt;strong&gt;starts to question everything it knows about Ruby&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id='1__1__1'&gt;1 + 1 = 1&lt;/h2&gt;

&lt;p&gt;Now that I&amp;#8217;m in my debugger I can see that &lt;code&gt;locale == :fi =&amp;gt; true&lt;/code&gt;. I want to know why the key &lt;code&gt;fi.navigation.dashboard&lt;/code&gt; is returning english. So I &lt;strong&gt;step.&lt;/strong&gt; and the method exists. Hmm. Apparently the translations hash does not have the &lt;code&gt;:fi&lt;/code&gt; key. What follows is something straight out of the X-Files.&lt;/p&gt;

&lt;p&gt;I quit the process and start over again. This time I don&amp;#8217;t step but inspect what&amp;#8217;s going on in memory. Here&amp;#8217;s me in the debugger&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(rdb:2) translations.keys
[:&amp;quot;en-us&amp;quot;, :&amp;quot;de-ch&amp;quot;, :en, :fi :&amp;quot;en-gb&amp;quot;]
(rdb:2) translations[:fi]
nil
(rdb:2) translations[:en]
{:invitation_mailer=&amp;gt;{:rejection_notification=&amp;gt;{:description=&amp;gt;&amp;quot;%{name} has reje...
(rdb:2)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Well this is looking &lt;strong&gt;very&lt;/strong&gt; suspect. I&amp;#8217;m thinking symbols are globally unique! A &lt;code&gt;:fi&lt;/code&gt; anywhere in any ruby source file in the same process is equal to any other &lt;code&gt;:fi&lt;/code&gt; in the same process. How can this possibly be! Well, perhaps &lt;code&gt;translations&lt;/code&gt; isn&amp;#8217;t a simple &lt;code&gt;Hash&lt;/code&gt; but something like &lt;code&gt;HashWithIndifferentAccess&lt;/code&gt; or other trickery. A check to &lt;code&gt;translations.class&lt;/code&gt; returns &lt;code&gt;Hash&lt;/code&gt;. At this point I&amp;#8217;m absolutely fucking confused because &lt;code&gt;translations[:fi]&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt; but &lt;code&gt;translations[:en]&lt;/code&gt; is correct. &lt;strong&gt;AND&lt;/strong&gt; &lt;code&gt;translations.keys&lt;/code&gt; has &lt;code&gt;:fi&lt;/code&gt; in the damn thing. So I start running around the room bouncing off walls and other thing that don&amp;#8217;t make any sense because for some reason all I know about Ruby symbols is wrong and that&amp;#8217;s causing my brain to meltdown.&lt;/p&gt;

&lt;p&gt;I start playing in the debugger more.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(rdb:2) translations[translations.keys.first]
# a ton of finnish
(rdb:2) translations.keys[:fi]
nil # wait wut.&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Does. Not. Compute. Brain shutting down. More debugging:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(rdb:2) translations.keys
[:fi, :&amp;quot;en-gb&amp;quot;, :en, :&amp;quot;en-us&amp;quot;, :&amp;quot;de-ch&amp;quot;]
(rdb:2) translations.keys.first == :fi # HMMMM. Highly suspect &amp;lt;------------ WTF!
false
(rdb:2) translations.keys.first
:fi
(rdb:2) translations.keys[2] == :en
true
(rdb:2) translations[:en]
# a ton of english
(rdb:2) translations[:fi]
# nil
(rdb:2) translations[translations.keys.first]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;GAH. I cannot handle this. There has got to be some completly sinister going on here. Something I&amp;#8217;ve never heard about. Something that only exists in comp.lang.c. Something that is out side of releam. Something going in the C implementation. Just something fucking crazy.&lt;/p&gt;

&lt;p&gt;This sort of bug induced comma has been going on for a few hours now. Nearing the end of my rope I try some more things in the debugger:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/Users/adam/.rvm/gems/ree-1.8.7-2011.03/gems/i18n-0.6.0/lib/i18n/backend/simple.rb:33
locale = locale.to_sym
(rdb:1) locale
&amp;quot;fi&amp;quot;
(rdb:1) locale == &amp;quot;fi&amp;quot;
false
(rdb:1) locale &amp;lt;=&amp;gt; &amp;quot;fi&amp;quot;
1
(rdb:1) locale.length
5
(rdb:1) &amp;quot;fi&amp;quot;.length
2&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;HOLY CHRISTMAS&lt;/strong&gt;. There is the sinister bit! The keys are actually different! This is completely masked by any call to &lt;code&gt;puts&lt;/code&gt; or &lt;code&gt;to_sym&lt;/code&gt;. Now I have to figure out why in god&amp;#8217;s name is the key for finnish in the &lt;code&gt;translations&lt;/code&gt; 5 characters. There is only one other place that can cause this problem: Where the YML files are parsed and put into the translations file. I track that down and enter the debugger:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(rdb:1) locale.bytes
#&amp;lt;Enumerable::Enumerator:0x10ba360b8&amp;gt;
(rdb:1) locale.bytes.map(&amp;amp;:to_s)
[&amp;quot;239&amp;quot;, &amp;quot;187&amp;quot;, &amp;quot;191&amp;quot;, &amp;quot;102&amp;quot;, &amp;quot;105&amp;quot;]
(rdb:1) &amp;quot;fi&amp;quot;.bytes.map(&amp;amp;:to_s)
[&amp;quot;102&amp;quot;, &amp;quot;105&amp;quot;]&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='encodings_youve_done_it_to_me_again'&gt;Encodings, You&amp;#8217;ve Done it to me Again!&lt;/h2&gt;

&lt;p&gt;Astute readers will notice that is there is a BOM in the key that&amp;#8217;s used in the &lt;code&gt;translations&lt;/code&gt; hash! So when I pass the string &amp;#8220;fi&amp;#8221; into &lt;code&gt;I18n.translate&lt;/code&gt; of course it doesn&amp;#8217;t have the BOM in it which essentially equates to I18n thining that there is no such thing as that locale. There are more sinister things at play here. I18n will call &lt;code&gt;to_sym&lt;/code&gt; for all keys that are entered into the translations hash. &lt;em&gt;However&lt;/em&gt;, ruby will not remove the BOM from the string when &lt;code&gt;to_sym&lt;/code&gt; is called. When you inspect that symbol in the debugger it will show as &lt;code&gt;:fi&lt;/code&gt;. When you call &lt;code&gt;locale.to_s&lt;/code&gt; it will show &lt;code&gt;&amp;quot;fi&amp;quot;&lt;/code&gt; so everything &lt;em&gt;seems&lt;/em&gt; right on the surface. Underneath the covers it is horribly wrong. Now I have to figure out if the problem is with my files or somee other piece of code. Let&amp;#8217;s get a hex dump and figure out for sure.&lt;/p&gt;

&lt;p&gt;Here is the hex dump of the &lt;code&gt;en.yml&lt;/code&gt; file.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cs181226081:crm adam$ od config/locales/en.yml 
0000000    067145  005072  020040  067554  060543  062554  035163  020012&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have the eternally lovely &lt;code&gt;fi.yml&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cs181226081:crm adam$ od -ax config/locales/fi.yml 
0000000    ?   ?   ?   f   i   :  nl  sp  sp   l   o   c   a   l   e   s
         bbef    66bf    3a69    200a    6c20    636f    6c61    7365&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Dear god&lt;/strong&gt;. There is a BOM at the start of the file. That was it?! Yes folks, that was the problem. There was a BOM at the start of my locale file. YAML (however it&amp;#8217;s coded) consumes the bytes and turns them to a key for hash. Question: how come BOM are used to create keys to this hash? Answer: Because I&amp;#8217;m using Ruby 1.8.7 and everything&amp;#8217;s wrong!&lt;/p&gt;

&lt;p&gt;People bitch about the YML parser on 1.9. I welcome it&amp;#8217;s strictness. I don&amp;#8217;t think this would&amp;#8217;ve happend on 1.9. There was some interesting twist of fate in how Ruby 1.8.7 handles BOM&amp;#8217;s, encodings, and YAML. I don&amp;#8217;t remember exactly what it was but I know this: It was the perfect storm of everything going the exactly wrong direction to create the most annoying bug I&amp;#8217;ve ever seen. I like to describe these sitations with this phrase: &amp;#8220;a long and constant stream of unfortunate mistakes.&amp;#8221;&lt;/p&gt;

&lt;h2 id='squashing_the_bug'&gt;Squashing the Bug&lt;/h2&gt;

&lt;p&gt;I don&amp;#8217;t hold anything aganist anyone. This is most likely some odd edge case. I attribute this to the file coming from Windows, generated then edited in god knows what way. I attribute it to encoding conversions. There are a lot of possible ways this situation could happen. One thing is for sure: any YML library on any version of Ruby should &lt;strong&gt;not&lt;/strong&gt; allow BOM markers in keys! This is crazy! I cannot think of any use case for this behavior.&lt;/p&gt;

&lt;p&gt;After I finally got my head around what exactly what had happened I could move forward. I copied the text to the clipboard and deleted the existing file. I made a new file in the ever trustworthy VIM and pasted it in. &lt;code&gt;:w&lt;/code&gt;, then &lt;code&gt;./script/server&lt;/code&gt;, and a refresh later: I see my application in Finnish. Jesus christ. That took my a little over 5 hours. By this time I was completely mentally spent. A few fixes and commits later I deployed a finnish version of the application&amp;#8211;then I didn&amp;#8217;t work on Rails for the rest of the day.&lt;/p&gt;

&lt;h2 id='moral_of_the_story'&gt;Moral of the story&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Use Ruby 1.9&lt;/li&gt;

&lt;li&gt;Don&amp;#8217;t trust files from Windows&lt;/li&gt;

&lt;li&gt;Turn invisibles on in your editor when editing YML files&lt;/li&gt;

&lt;li&gt;Be sure to remove the BOM&lt;/li&gt;

&lt;li&gt;Upgrade from Ruby 1.8.7&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;P.S. Here are the gists if you want to relive the horror.&lt;/p&gt;

&lt;p&gt;&lt;a href='https://gist.github.com/1319411'&gt;Debugging Session&lt;/a&gt; &lt;a href='https://gist.github.com/1319579'&gt;Hex Dumps&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Handling Legacy APIs</title>
      <link>http://broadcastingadam.com/2011/10/handling_legacy_apis</link>
      <pubDate>Wed, 19 Oct 2011 00:00:00 +0200</pubDate>
      <author>me@broadcastingadam.com (Adam Hawkins)</author>
      <guid>http://broadcasting.com/2011/10/handling_legacy_apis</guid>
      <description>&lt;p&gt;Well, it&amp;#8217;s been a while since I&amp;#8217;ve written a post to my blog. I&amp;#8217;m on a plane back to Helsinki for some intense work. I&amp;#8217;ve got some trance on so I figure I&amp;#8217;ll scratch and itch and try to get something written.&lt;/p&gt;

&lt;p&gt;There are few things poeple never mention when they are teaching rails to rookies, or hell, really even talk about in general. Rails gets a lot of play for how easy it is to write RESTful APIs. It deserves it. However, no one ever mentions what it &lt;em&gt;actually means&lt;/em&gt; to write a web API. I haven&amp;#8217;t see anyone talk about freezing input formats or output formats. The common approach is to just throw in &lt;code&gt;respond_to :json&lt;/code&gt; then go on your merry way. It works, but it&amp;#8217;s got some problems.&lt;/p&gt;

&lt;h2 id='dealing_with_changes'&gt;Dealing with Changes&lt;/h2&gt;

&lt;p&gt;Let&amp;#8217;s first examine the most basic and widely adverised Rails RESTful API controlller.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class FoosController &amp;lt; ApplicationController
  respond_to :json

  def new
    respond_with Foo.create(params[:foo])
  end

  def show
    respond_with Foo.find params[:id]
  end

  def index
    respond_with Foo.all
  end

  def update
    foo = Foo.find params[:id]

    respond_with foo.update_attributes(params[:foo])
  end

  def destroy
    foo = Foo.find params[:id]

    respond_with foo.destroy
  end
end&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Zomg!&lt;/strong&gt; You have an API! Well, no. You&amp;#8217;ve just defined a simple webservice that communicates with JSON. You have not met the two fundamental requirements for writing an API:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Input parameters stay the same forever for a given API version&lt;/li&gt;

&lt;li&gt;Output formats stay the same forever for a given API version.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Let&amp;#8217;s say you change an attribute on the &lt;code&gt;Foo&lt;/code&gt; class. You&amp;#8217;ll likely be smacked with a lof of &lt;code&gt;UnknownAttribute&lt;/code&gt; errors. Then on the other end, there previous parameter will be renamed in the outputted JSON. Congratulations, you&amp;#8217;ve just made an API that has Facebook consistency. As the developer, you need to take steps to ensure that you&amp;#8217;re API stays to the standards you&amp;#8217;ve written.&lt;/p&gt;

&lt;p&gt;You have two ways to handle this problem. You can build logic into the underlying model to handle deprecated methods. You could code some logic into the controller to convert legacy input parameters. You could write a middleware that will handle some changes. There are a few ways to tackel this problem. I&amp;#8217;ll share how I did it for Radium.&lt;/p&gt;

&lt;h2 id='handling_legacy_api_input_parameters'&gt;Handling Legacy API Input Parameters&lt;/h2&gt;

&lt;p&gt;A long time ago. I wrote a webservice for a Symbian (kill it with fire) application. The API was supposed to exist for maybe a few months for prototyping. Turns out it&amp;#8217;s taken over 1.5 years to develop (and it&amp;#8217;s not done yet) the application. In that time, my simple API interface to some common models has had to stay the same. You can imagine over the course of 1.5 years the underyling schema and model layer will undergo changes. For examples, one record use to a series to timestamps and a state machine to track it&amp;#8217;s progress. Now there is a simple boolean flag. Attributes have been renamed. Classes have changed. The underlying data model has matured but the API hadn&amp;#8217;t. Now I&amp;#8217;m facing a problem with supporting legacy input parameters and legacy output formats. I was using the wonderful &lt;code&gt;to_json&lt;/code&gt; method.&lt;/p&gt;

&lt;p&gt;I needed to take different param hashes, change values, rename keys, and some various other massaging to fit current model. So I decided to write a class for each different type of API call. There are todos, contacts, and meetings. Here is a snippet of one of the classes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module SymbianAPI
  class LegacyTodoConverter
    def self.convert(params)
      params[:finished] = true if params.delete(:finished_at)
      params[:description] = params.delete :task
      params[:finish_by] = params.delete :due_at

      # more stuff

      params
    end
  end
end&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I ended up writing 3 of these type&amp;#8217;s of classes. They massage the legacy params for the API request and update them to fit the current model.&lt;/p&gt;

&lt;p&gt;I took a more complicated route implementing them. I wanted my controllers to look as vanilla as possible. I didn&amp;#8217;t want to have to reference these classes in every request or write a &lt;code&gt;before_filter&lt;/code&gt;. I just wanted the controller to know that &lt;code&gt;params[:foo]&lt;/code&gt; is good to go. I dedecied to write a middleware that would automatically convert the legacy parameters based on the route. So if the route mataches &lt;code&gt;/api/customers&lt;/code&gt;, then I would use my LegacyCustomerConvertor to merge in the new params. There is some other trickery going on here, but I figure I&amp;#8217;d share the code for anyone who is interested.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class SymbianApiAdapter
  def initialize(app)
    @app = app
  end

  def call(env)
    if request_for_symbian_api?(env)
      @app.call convert_legacy_input(env)
    else
      @app.call env
    end
  end

  private 
  def request_for_symbian_api?(env)
    parts = env[&amp;#39;PATH_INFO&amp;#39;].split(&amp;#39;/&amp;#39;)
    parts[1] == &amp;#39;api&amp;#39; &amp;amp;&amp;amp; parts[2] != &amp;#39;v2&amp;#39;
  end

  def convert_legacy_input(env)
    # No fucking clue why we have to do this trickery for PUTS
    if env[&amp;#39;REQUEST_METHOD&amp;#39;] == &amp;#39;PUT&amp;#39;
      params = Rack::Request.new(env).POST
    else
      params = env[&amp;#39;rack.request.form_hash&amp;#39;]
    end

    if params.present? &amp;amp;&amp;amp; params[&amp;#39;xml&amp;#39;].present?
      adapter = case env[&amp;#39;PATH_INFO&amp;#39;]
                when &amp;#39;/api/todos/sync&amp;#39;
                  Api::Adapters::TodosAdapter
                when /todo/
                  Api::Adapters::TodoAdapter
                when &amp;#39;/api/meetings/sync&amp;#39;
                  Api::Adapters::MeetingsAdapter
                when /meeting/
                  Api::Adapters::MeetingAdapter
                when &amp;#39;/api/customers/sync&amp;#39;
                  Api::Adapters::CustomersAdapter
                when /customer/
                  Api::Adapters::CustomerAdapter
                end

      env[&amp;#39;rack.request.form_hash&amp;#39;] || {}

      if adapter
        xml = params.delete &amp;#39;xml&amp;#39;
        hash = Hash.from_xml(xml)

        if hash.values.first.is_a?(Hash)
          converted_params = {}
          converted_params[hash.keys.first] = adapter.convert(hash.values.first.with_indifferent_access)
          env[&amp;#39;rack.request.form_hash&amp;#39;].merge! converted_params
        elsif hash.values.first.is_a?(Array)
          env[&amp;#39;rack.request.form_hash&amp;#39;].merge! adapter.convert(hash)
        end
      end
    end

    env
  end
end&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This keeps my controllers small since they don&amp;#8217;t have to worry about handling the paramters. They are just correct when the request finally hits the controller. Now there is also a wall between what comes in from the request and what actually hits the models. This makes it much easier to &lt;strong&gt;ensure future support&lt;/strong&gt;. All I need to do is update those convertor classes and things will continue. Now at this point I can write this controller action and never worry about the params.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class FoosController &amp;lt; ApplicationController
  respond_to :json

  def create
    reapond_with Foo.create(params[:foo])
  end
end&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='handling_legacy_api_output_formats'&gt;Handling Legacy API Output Formats&lt;/h2&gt;

&lt;p&gt;There has finally been some talk about this sort of thing. There needs to be a way to easily generate different blocks of JSON depending on what API version is in use&amp;#8211;essentially different &lt;strong&gt;views&lt;/strong&gt;. There are a few ways to do this. You could use a fancy new JSON builder like Rabl. I have not used Rabl. I investigated it, but I find that using builders in views is cumbersom when you need to write some code. (And code doesn&amp;#8217;t belong the view anyway). I opted for an easier approach. (And given that this is currently a Rails 2 app, there are no other options). I wrote another three classes that take the record to be returned and generate an output hash. That hash can then be used for &lt;code&gt;to_json&lt;/code&gt; or &lt;code&gt;to_xml&lt;/code&gt;. Here&amp;#8217;s how they work.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module Api
  class LegacyContactAdapter
    def self.convert(contact)
     {
      :town =&amp;gt; contact.city, # API was specified to return a &amp;#39;town&amp;#39; attribute
      :postcode =&amp;gt; contact.zip_code # API specificed a &amp;#39;postcode&amp;#39; attribute

      # so on and so forth. Build up the hash with the specified
      # attributes
    }
  end
end&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, the controller can use that class to return the required JSON.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def create
  foo = Foo.create params[:foo]

  if foo.save
    respond_to do |wants|
      wants.json { render :json =&amp;gt; Api::LegacyContactAdapter.convert(contact), :status =&amp;gt; :created }
    end
  else
    respond_to do |wants|
      wants.json { render :json =&amp;gt; contact.errors, :status =&amp;gt; :unprocessable_entity }
    end
  end&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using that classes ensure that it&amp;#8217;s easy(ier) to support the legacy API into the future because there is a wall in the code. Also, if the contact model ever changes, or the api needs a new output paramter, you can just throw it into the various &lt;code&gt;Adapter&lt;/code&gt; classes.&lt;/p&gt;

&lt;h2 id='wrapping_it_up'&gt;Wrapping it Up&lt;/h2&gt;

&lt;p&gt;Writing API&amp;#8217;s is serious business. They represent a contact between your system and external developers. You need to do everything in your power to ensure that you hold up your end of the baragin. You need to ensure that the input parameters are always accepted and that you stick to the given output format no matter what changes. I&amp;#8217;ve showed you some different ways you can hold up your end of the contract. A middleware based solution may not work in every situation. I could&amp;#8217;ve easily used a &lt;code&gt;before_filter&lt;/code&gt; but I didn&amp;#8217;t like that. The important thing is to build walls between the API and the other parts of your code that way it&amp;#8217;s easier to ensure support in the future.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Present Yourself - Presenters in Rails</title>
      <link>http://broadcastingadam.com/2011/06/present_yourself</link>
      <pubDate>Fri, 10 Jun 2011 00:00:00 +0200</pubDate>
      <author>me@broadcastingadam.com (Adam Hawkins)</author>
      <guid>http://broadcasting.com/2011/06/present_yourself</guid>
      <description>&lt;p&gt;Presenters are one of those interesting things that you don&amp;#8217;t hear about very much. They are mentioned, and then flutter in the wind. If you google &amp;#8220;presenters rails&amp;#8221; you&amp;#8217;ll get some links from a few years ago and that&amp;#8217;s about it. There is perhaps some useful information there. Maybe you find something on cells. That&amp;#8217;s most likely not what you want. I&amp;#8217;m taking about presenters (insert Alan Iverson practice voice). Presenters are object designed to encapsulate information required to create a view. They slim down controllers and encourage view reusability. This post describes how I started using presenters and why it worked.&lt;/p&gt;

&lt;h2 id='the_backstory__thats_a_god_damn_ton_of_instance_variables'&gt;The Backstory - That&amp;#8217;s a God Damn Ton of Instance Variables&lt;/h2&gt;

&lt;p&gt;I work on a complex project. It&amp;#8217;s not one of those cookie-cutter Rails apps that deals with practically generated code. There is some real business going on here. Views are complicated things and it takes a fair amount of information to render views for certain objects. Here is an example of what I&amp;#8217;m talking about for one page.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The record itself.&lt;/li&gt;

&lt;li&gt;All the associated notes&lt;/li&gt;

&lt;li&gt;All the associated todos&lt;/li&gt;

&lt;li&gt;All the associated extra fields (think EAV)&lt;/li&gt;

&lt;li&gt;All the associated deals&lt;/li&gt;

&lt;li&gt;All the associate activities (with fancy filtering. This alone is massive where each activity as it&amp;#8217;s own forms and required stuff)&lt;/li&gt;

&lt;li&gt;Statistics (3 different tables, 30 different statistics, custom ranges)&lt;/li&gt;

&lt;li&gt;A new email&lt;/li&gt;

&lt;li&gt;A new sms&lt;/li&gt;

&lt;li&gt;A new meeting&lt;/li&gt;

&lt;li&gt;A new deal&lt;/li&gt;

&lt;li&gt;The list goes on&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Everyone is used to seeing this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def show
  @customer = Customer.find params[:id]
end&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;#8217;s all well in good for simple applications. What if you have this?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def show
  @customer = Customer.find params[:id]

  # insert 30 more lines of instantiation
  # and other trickery to get the view to render
end&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;#8217;s gonna get old real quick&amp;#8211;especially if you have to do that for many different pages. The controller is becoming ove run run with logic &lt;strong&gt;only&lt;/strong&gt; required for the view. All of that extra cruft is not related to the actual controller action of taking params and finding and object. &lt;strong&gt;It&amp;#8217;s just noise.&lt;/strong&gt; The solution is to move all that stuff into an object that knows how to &lt;em&gt;present&lt;/em&gt; that specific view. Why do you want to to this? I think there are a few reasons.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Keep controllers small and stupid. They should be kept small.&lt;/li&gt;

&lt;li&gt;Extract logic into a class where it&amp;#8217;s easily testable&lt;/li&gt;

&lt;li&gt;Encourage view/template reusability since a view requires an object not a random assortment of instance variables.&lt;/li&gt;

&lt;li&gt;Keep views stupid since they depend on one object for everything.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Now many of my previous complex controller actions look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def show
  customer = Customer.find params[:id]
  @presenter = CustomerPresenter.new customer, current_user
end&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this point, the presenter does all the required instantiation and other trickery that the view needs.&lt;/p&gt;

&lt;h2 id='looking_at_a_presenter'&gt;Looking at a Presenter&lt;/h2&gt;

&lt;p&gt;I created a common base class for all the presenters in my application. I call it ApplicationPresenter. Here&amp;#8217;s the code: (Rails 2.3)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class ApplicationPresenter
  extend ActiveSupport::Memoizable
  include ActionController::UrlWriter
  include ActionController::RecordIdentifier

  def self.default_url_options
    ActionMailer::Base.default_url_options
  end

  private
  def t(*args)
    I18n.translate(*args)
  end
end&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code enables me to do a few things:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Memoize all methods so instantiation/querying only happens once&lt;/li&gt;

&lt;li&gt;Use named route helpers &amp;amp; url_for/polymorphic_url etc in the presenter&lt;/li&gt;

&lt;li&gt;User &lt;code&gt;dom_id&lt;/code&gt; and things like that. I use &lt;code&gt;dom_id&lt;/code&gt; a ton in this project.&lt;/li&gt;

&lt;li&gt;Provide &lt;code&gt;t&lt;/code&gt; in the presenters. This is mostly to prevent the views from figuring out how to find text themselves.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The application is very compontentized. Pages are composed of different components. Each component has their own presenter. A page presenter will provide an interface for getting a presenter for each component. That presenter is passed into the partial as a local variable. It works out pretty well. Here is an example view. Most of the views look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-# This is the dashboard type view

- title @presenter.title

= render :partial =&amp;gt; &amp;#39;announcements/announcement&amp;#39;, :locals =&amp;gt; {:presenter =&amp;gt; @presenter.announcement_presenter}

= render :partial =&amp;gt; &amp;quot;activities/activities&amp;quot; , :locals =&amp;gt; {:presenter =&amp;gt; @presenter.activities_presenter}

= render_statistics @presenter.statistics_presenter

- content_for :sidebar do

  = render :partial =&amp;gt; &amp;quot;todos/widget&amp;quot;, :locals =&amp;gt; { :presenter =&amp;gt; @presenter.todo_widget_presenter }

  = render :partial =&amp;gt; &amp;#39;users/widget&amp;#39;, :locals =&amp;gt; { :presenter =&amp;gt; @presenter.user_widget_presenter }

  = render :partial =&amp;gt; &amp;#39;customers/search_widget&amp;#39;

  = render :partial =&amp;gt; &amp;#39;companies/widget&amp;#39;, :locals =&amp;gt; {:presenter =&amp;gt; @presenter.company_widget_presenter}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you know what a basic view looks like, here&amp;#8217;s the code for that page&amp;#8217;s presenter.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class DashboardPresenter &amp;lt; ApplicationPresenter
  def initialize(user)
    @user = user
  end

  def user_widget_presenter
    UserWidgetPresenter.new @user 
  end
  memoize :user_widget_presenter

  def company_widget_presenter
    CompanyWidgetPresenter.new @user
  end
  memoize :company_widget_presenter

  def todo_widget_presenter
    TodoWidgetPresenter.new @user, @user
  end
  memoize :todo_widget_presenter

  def announcement_presenter
    AnnouncementPresenter.new @user
  end
  memoize :announcement_presenter

  def activities_presenter
    DashboardActivitiesPresenter.new @user, @user
  end
  memoize :activities_presenter

  def statistics_presenter
    DashboardStatisticsPresenter.new @user
  end
  memoize :statistics_presenter

  def title
    t &amp;#39;dashboard.page_title&amp;#39;
  end
  memoize :title
end&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The main page presenters really don&amp;#8217;t have much to them. The just create presenters for all the different components I want on that page. However, some of the individual presenters can get pretty hairy. I&amp;#8217;ll share a simple one first:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class NotesPresenter &amp;lt; ApplicationPresenter
  def initialize(record)
    @record = record
  end

  def notes
    @record.notes.all(:include =&amp;gt; :user)
  end
  memoize :notes

  def show_explanation?
    @record.notes.count == 0
  end
  memoize :show_explanation?

  def explanation
    t(&amp;#39;explanations.notes&amp;#39;)
  end
  memoize :explanation
end&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now for the hairy one:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class DealsPresenter &amp;lt; ApplicationPresenter

  PER_PAGE = 35

  def initialize(user, params)
    @user = user
    @params = params
  end

  def deals
    if @user.is_a?(Manager)
      bucket = account.deals
    else
      bucket = @user.deals
    end

    case filter
    when &amp;#39;user&amp;#39;
      bucket = bucket.with_user(account.users.find(@params[:user_id]))
    when &amp;#39;status_pending&amp;#39;
      bucket = bucket.pending
    when &amp;#39;status_closed&amp;#39;
      bucket = bucket.closed
    when &amp;#39;status_rejected&amp;#39;
      bucket = bucket.rejected
    when &amp;#39;status_paid&amp;#39;
      bucket = bucket.paid
    when &amp;#39;due_this_week&amp;#39;
      bucket = bucket.due_between(Time.zone.now.beginning_of_week..Time.zone.now.end_of_week)
    when &amp;#39;due_this_month&amp;#39;
      bucket = bucket.due_between(Time.zone.now.beginning_of_month..Time.zone.now.end_of_month)
    when &amp;#39;due_overdue&amp;#39;
      bucket = bucket.overdue
    else
      bucket
    end

    bucket.paginate :order =&amp;gt; &amp;quot;#{ordered_column} #{sort_direction}&amp;quot;,
                    :include =&amp;gt; [{:customer =&amp;gt; :company}, :user],
                    :page =&amp;gt; @params[:page],
                    :per_page =&amp;gt; PER_PAGE
  end
  memoize :deals

  def filters_presenter
    presenter = FiltersPresenter.new

    presenter.filter I18n.translate(&amp;#39;deals.filters.all_deals&amp;#39;), deals_path, :class =&amp;gt; (filter == &amp;#39;all&amp;#39; ? &amp;#39;selected&amp;#39; : &amp;#39;unselected&amp;#39;)

    text = case filter
           when &amp;#39;user&amp;#39;
             I18n.translate(&amp;#39;deals.filters.filtered_by_user&amp;#39;, :user =&amp;gt; account.users.find(@params[:user_id]))
           else
             I18n.translate(&amp;#39;deals.filters.by_user&amp;#39;)
           end

    if @user.is_a?(Manager)
      presenter.dropdown text, :class =&amp;gt; (filter == &amp;#39;user&amp;#39; ? &amp;#39;selected&amp;#39; : &amp;#39;unselected&amp;#39;) do |drop_down|
        account.users.alphabetical.except(@user).each do |user|
          drop_down.filter user, deals_path(:filter =&amp;gt; :user, :user_id =&amp;gt; user.id)
        end
      end
    end

    text = case filter
           when &amp;#39;status_pending&amp;#39;
             I18n.translate(&amp;#39;deals.filters.status_pending&amp;#39;)
           when &amp;#39;status_closed&amp;#39;
             I18n.translate(&amp;#39;deals.filters.status_closed&amp;#39;)
           when &amp;#39;status_paid&amp;#39;
             I18n.translate(&amp;#39;deals.filters.status_paid&amp;#39;)
           when &amp;#39;status_rejected&amp;#39;
             I18n.translate(&amp;#39;deals.filters.status_rejected&amp;#39;)
           else
             I18n.translate(&amp;#39;deals.filters.status&amp;#39;)
           end

    presenter.dropdown text, :class =&amp;gt; (filter =~ /status/ ? &amp;#39;selected&amp;#39; : &amp;#39;unselected&amp;#39;) do |drop_down|
      %w(pending closed paid rejected).each do |status|
        drop_down.filter I18n.translate(&amp;quot;deals.states.#{status}&amp;quot;), deals_path(:filter =&amp;gt; &amp;quot;status_#{status}&amp;quot;) if filter != status
      end
    end

    presenter
  end
  memoize :filters_presenter

  def deal
    Deal.new
  end
  memoize :deal

  def sortable_options
    @params.slice(:filter, :user_id)
  end
  memoize :sortable_options

  def sort_column
    %w(user customer company amount due_on status).include?(@params[:sort]) ? @params[:sort] : &amp;#39;user&amp;#39;
  end
  memoize :sort_column

  def sort_direction
    @params[:direction] == &amp;#39;desc&amp;#39; ? &amp;#39;desc&amp;#39; : &amp;#39;asc&amp;#39;
  end
  memoize :sort_direction

  def ordered_column
    case sort_column
    when &amp;#39;user&amp;#39;
      &amp;#39;users.name&amp;#39;
    when &amp;#39;customer&amp;#39;
      &amp;#39;customers.name&amp;#39;
    when &amp;#39;company&amp;#39;
      &amp;#39;companies.name&amp;#39;
    when &amp;#39;amount&amp;#39;
      &amp;#39;deals.value&amp;#39;
    when &amp;#39;status&amp;#39;
      &amp;#39;deals.state&amp;#39;
    when &amp;#39;due_on&amp;#39;
      &amp;#39;deals.due_by&amp;#39;
    end
  end
  memoize :ordered_column

  def title
    I18n.translate &amp;#39;plurals.deals&amp;#39;
  end
  memoize :title

  def statistics_presenter

  end
  memoize :statistics_presenter

  private
  def filter
    %w(user status_pending status_closed status_rejected status_paid
      due_this_week due_this_month due_overdue all).include?(@params[:filter]) ? @params[:filter] : &amp;#39;all&amp;#39;
  end
  memoize :filter

  def account
    @user.account
  end
  memoize :account
end&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; this particular presenter is waiting to be refactored. But it does give you an idea of some of the logic that I removed from the controlller. It also testifies to the logic required to construct a view and why it&amp;#8217;s nice to remove it from the controller.&lt;/p&gt;

&lt;h2 id='testing_presenters'&gt;Testing Presenters&lt;/h2&gt;

&lt;p&gt;I like moving logic out of the controllers because testing controllers is such a pain in the ass. (I stopped doing it completely actually). Once your controller starts to do some real work, whatever mocks/stubs you had in place become too cumbersome to maintain. Sometimes I simply want to test that a new instance variable is created. Using my presenter, I could write a test like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class NotesPresenter &amp;lt; ApplicationPresenter
  def note
    Note.new
  end
  memoize :note
end

describe NotesPresenter do
  it &amp;quot;should provide a new note for a form&amp;quot; do
    subject.note.should be_new_record
    subject.note.should be_a(Note)
  end
end&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Good luck doing that in a controller action with more complex logic. It&amp;#8217;s very easy to test in an isolate class.&lt;/p&gt;

&lt;p&gt;Most of my test cases don&amp;#8217;t do heavy assertions, but verify that a specific interface is implemented. Most of the logic inside the method is trivial enough to ignore writing a test case. Instead, I use rspec&amp;#8217;s &lt;code&gt;it_should_behave_like&lt;/code&gt; to specify the presenter provides a certain interface. Here is the test for the previously mentioned &lt;code&gt;DashboardPresenter&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;require &amp;#39;spec_helper&amp;#39;

describe DashboardPresenter do
  def mock_user(stubs = {})
    @mock_user ||= mock_model(User, stubs)
  end

  subject { DashboardPresenter.new(mock_user) }

  it_should_behave_like &amp;quot;a presenter with activities&amp;quot;

  it_should_behave_like &amp;quot;a presenter with todos&amp;quot;

  it_should_behave_like &amp;quot;a presenter with stats&amp;quot;

  it_should_behave_like &amp;quot;a presenter with companies&amp;quot;

  it_should_behave_like &amp;quot;a presenter with a page title&amp;quot;

  it { should respond_to(:user_widget_presenter) }

  it { should respond_to(:announcement_presenter) }
end&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now for a component presenter:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;require &amp;#39;spec_helper&amp;#39;

describe NotesPresenter do
  fixtures :customers

  subject { NotesPresenter.new customers(:teemu) }

  it_should_behave_like &amp;quot;a presenter with an explanation&amp;quot;

  it { should respond_to(:notes) }
end&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='closing_thoughts'&gt;Closing Thoughts&lt;/h2&gt;

&lt;p&gt;I&amp;#8217;m very happy I did this. It makes my view layer much easier to maintain. It also makes my controllers easy to maintain because of how simple they are. It also gives me a common object I can pass off to a view if I need to render it. This happens to me a lot actually. There are ajax forms that hit different controllers on one page. For example, if you are on &amp;#8216;companies/1&amp;#8217; there is a form to add a todo. Naturally this goes to &lt;code&gt;TodosController&lt;/code&gt;. Now the UI for the company page has to be updated from the &lt;code&gt;TodosController&lt;/code&gt; in a &lt;code&gt;js.erb&lt;/code&gt; template. I can simply instantiate the todos component presenter has use that to rerender the partial. I don&amp;#8217;t have to know anything else&amp;#8211;the presenter does all the work for me.&lt;/p&gt;

&lt;p&gt;You can learn more about presenters in this &lt;a href='http://www.codeschool.com/courses/rails-best-practices'&gt;course&lt;/a&gt;. You can also learn more about presenters by reading Martin Flower&amp;#8217;s &lt;a href='http://www.google.com/search?sourceid=chrome&amp;amp;ie=UTF-8&amp;amp;q=martin+fowler+presenter'&gt;papers&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Advanced Caching in Rails</title>
      <link>http://broadcastingadam.com/2011/05/advanced_caching_in_rails</link>
      <pubDate>Fri, 06 May 2011 00:00:00 +0200</pubDate>
      <author>me@broadcastingadam.com (Adam Hawkins)</author>
      <guid>http://broadcasting.com/2011/05/advanced_caching_in_rails</guid>
      <description>&lt;p&gt;Caching in Rails is covered occasionally. It is covered in very basic detail in the caching &lt;a href='http://guides.rubyonrails.org/caching_with_rails.html'&gt;guide&lt;/a&gt;. Advanced caching is left to reader. Here&amp;#8217;s where I come in. I recently read part of Ryan Bigg&amp;#8217;s &lt;a href='http://www.manning.com/katz/'&gt;Rails 3 in Action&lt;/a&gt; upcoming Rails book (review in the works) where he covers caching. He does a wonderful job of giving the reader the basic sense of how you can use page, action, and fragment caching. The examples only work well in a simple application like he&amp;#8217;s developing in the book. I&amp;#8217;m going to show you how you can level up your caching with some new approaches.&lt;/p&gt;

&lt;h2 id='different_caching_layers'&gt;Different Caching Layers&lt;/h2&gt;

&lt;p&gt;First, let&amp;#8217;s start with a brief overview of the different types of caching:&lt;/p&gt;

&lt;p&gt;1. Page Caching: &lt;strong&gt;PRAISE THE GODS&lt;/strong&gt; if you actually can use page caching in your application. Page caching is the holy grail. Save the entire thing. Don&amp;#8217;t hit the stack &amp;amp; give some prerendered stuff back. Great for worthless applications without authentication and other highly dynamic aspects.&lt;/p&gt;

&lt;p&gt;2. Action Caching: Essentially the same as page caching, except all the before filters are run allowing you to check authentication and other stuff that may have prevented the request for rendering.&lt;/p&gt;

&lt;p&gt;3. Fragment Caching: Store parts of views in the cache. Usually for caching partials or large bits of HTML that are independent from other parts. IE, a list of top stories or something like that.&lt;/p&gt;

&lt;p&gt;4. Rails.cache: All cached content &lt;strong&gt;except cached pages&lt;/strong&gt; are stored in the Rails.cache. Cached pages are stored as HTML on disk. We&amp;#8217;ll use the fact that all the cached action and fragment content are simply stored in Rails.cache. You can cache arbitrary content in the Rails cache. You may cache a large complicated query that you don&amp;#8217;t want to wait to reinstantiate a ton of AR::Base objects.&lt;/p&gt;

&lt;h2 id='under_the_hood'&gt;Under the Hood&lt;/h2&gt;

&lt;p&gt;All the caching layers are built on top of the next one. Page caching is the only exception because it does not use &lt;code&gt;Rails.cache&lt;/code&gt; it writes content to disk. The cache is essentially a key-value store. Different things can be persisted. Strings are most common (for HTML fragments). More complicated objects can be persisted as well. Let&amp;#8217;s go through some examples of manually using the cache to store things. I am using memcached with dalli for all these examples. Any driver that implements the cache store pattern should work.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Rails.cache.write takes two value: key and a value
&amp;gt; Rails.cache.write &amp;#39;foo&amp;#39;, &amp;#39;bar&amp;#39;
=&amp;gt; true

# We can read an object back with read
&amp;gt; Rails.cache.read &amp;#39;foo&amp;#39;
=&amp;gt; &amp;quot;bar&amp;quot;

# We can store a complicated object as well
&amp;gt; hash = {:this =&amp;gt; {:is =&amp;gt; &amp;#39;a hash&amp;#39;}}
&amp;gt; Rails.cache.write &amp;#39;complicated-object&amp;#39;, object
&amp;gt; Rails.cache.read &amp;#39;complicated-object&amp;#39;
=&amp;gt; {:this=&amp;gt;{:is=&amp;gt;&amp;quot;a hash&amp;quot;}}

# If we want something that doesn&amp;#39;t exist, we get nil
&amp;gt; Rails.cache.read &amp;#39;we-havent-cached-this-yet&amp;#39;
=&amp;gt; nil

# &amp;quot;Fetch&amp;quot; is the most common pattern. You give it a key and a block
# to execute to store if the cache misses. The block is not executed
# if there is a cache hit.
&amp;gt; Rails.cache.fetch &amp;#39;huge-array&amp;#39; do
    huge_array = Array.new
    1000000.times { |i| huge_array &amp;lt;&amp;lt; i }
    huge_array # retrun value is stored in cache
  end
=&amp;gt; [huge array] # took some time to generate
&amp;gt; Rails.cache.read &amp;#39;huge-array&amp;#39;
=&amp;gt; [huge array] # but returned instantly

# You can also delete everything from the cache
&amp;gt; Rails.cache.clear 
=&amp;gt; [true]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Those are the basics of interacting withe the Rails cache. The rails cache is a wrapper around whatever functionality is provided by the underlying storage system. Now we are ready to move up a layer.&lt;/p&gt;

&lt;h2 id='understanding_fragment_caching'&gt;Understanding Fragment Caching&lt;/h2&gt;

&lt;p&gt;Fragment caching is taking rendered HTML fragments and storing them in the cache. Rails provides a &lt;code&gt;cache&lt;/code&gt; view helper for this. It&amp;#8217;s most basic form takes no arguments besides a block. Whatever is rendered during the block will be written back to the cache. The basic principle behind fragment caching is that it takes much less time fetch pre-rendered HTML from the cache, then it takes to generate a fresh copy. This is very true. If you haven&amp;#8217;t noticed, view generation can be very costly. Let&amp;#8217;s say you have generated a basic scaffold for a post:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rails g scaffold post title:string content:text author:string
# that will generate some views to play with&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;#8217;s start with the most common use case: caching information specific to one thing. IE: One post. Here is a show view:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!-- nothing fancy going on here --&amp;gt;
&amp;lt;p&amp;gt;
  &amp;lt;b&amp;gt;Title:&amp;lt;/b&amp;gt;
  &amp;lt;%= @post.title %&amp;gt;
&amp;lt;/p&amp;gt;

&amp;lt;p&amp;gt;
  &amp;lt;b&amp;gt;Content:&amp;lt;/b&amp;gt;
  &amp;lt;%= @post.content %&amp;gt;
&amp;lt;/p&amp;gt;

&amp;lt;p&amp;gt;
  &amp;lt;b&amp;gt;Author:&amp;lt;/b&amp;gt;
  &amp;lt;%= @post.author %&amp;gt;
&amp;lt;/p&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;#8217;s say we wanted to cache fragment. Simple wrap it in &lt;code&gt;cache&lt;/code&gt; and Rails will do it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;%= cache &amp;quot;post-#{@post.id}&amp;quot; do %&amp;gt;
  &amp;lt;p&amp;gt;
    &amp;lt;b&amp;gt;Title:&amp;lt;/b&amp;gt;
    &amp;lt;%= @post.title %&amp;gt;
  &amp;lt;/p&amp;gt;

  &amp;lt;p&amp;gt;
    &amp;lt;b&amp;gt;Content:&amp;lt;/b&amp;gt;
    &amp;lt;%= @post.content %&amp;gt;
  &amp;lt;/p&amp;gt;

  &amp;lt;p&amp;gt;
    &amp;lt;b&amp;gt;Author:&amp;lt;/b&amp;gt;
    &amp;lt;%= @post.author %&amp;gt;
  &amp;lt;/p&amp;gt;
&amp;lt;% end %&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first argument is the key for this fragment. The rendered HTML is stored with this key: &lt;code&gt;views/posts-1&lt;/code&gt;. Wait what? Where did that &amp;#8216;views&amp;#8217; come from? The &lt;code&gt;cache&lt;/code&gt; view helper automatically prepends &amp;#8216;view&amp;#8217; to all keys. This is important later. When you first load the page you&amp;#8217;ll see this in the log:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Exist fragment? views/post-2 (1.6ms)
Write fragment views/post-2 (0.9ms)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can see the key and the operations. Rails is checking to see if the specific key exists. It will fetch it or write it. In this case, it has not been stored so it is written. When you reload the page, you&amp;#8217;ll see a cache hit:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Exist fragment? views/post-2 (0.6ms)
Read fragment views/post-2 (0.0ms)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There we go. We got HTML from the cache instead of rendering it. Look at the response times for the two requests:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Completed 200 OK in 17ms (Views: 11.6ms | ActiveRecord: 0.1ms)
Completed 200 OK in 16ms (Views: 9.7ms | ActiveRecord: 0.1ms)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Very small differences in this case. 2ms different in view generation. This is a very simple example, but it can make a world of difference in more complicated situations.&lt;/p&gt;

&lt;p&gt;You are probably asking the question: &amp;#8220;What happens when the post changes?&amp;#8221; This is an excellent question! What well if the post changes, the cached content will &lt;strong&gt;not&lt;/strong&gt; be correct. It is up to &lt;strong&gt;us&lt;/strong&gt; to remove stuff from the cache &lt;strong&gt;or&lt;/strong&gt; figure out a way to get new content from the cache. Let&amp;#8217;s assume that our blog posts now have comments. What happens when a comment is created? How can handle this?&lt;/p&gt;

&lt;p&gt;This is a very simple problem. What if we could figured out a solution to this problem: How can we create a cache miss when the associated object changes? We&amp;#8217;ve already demonstrated how we can explicitly set a cache key. What if we made a key that&amp;#8217;s dependent on the time the object was last updated? We can create a key composed of the record&amp;#8217;s ID and it&amp;#8217;s updated_at timestamp! This way the cache key will change as the content changes &lt;strong&gt;and we will not have to expire things manually.&lt;/strong&gt; (We&amp;#8217;ll come back to sweepers later). Let&amp;#8217;s change our cache key to this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;% cache &amp;quot;post-#{@post.id}&amp;quot;, @post.updated_at.to_i do %&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can see we have a new cache key that&amp;#8217;s dependent on the objects timestamps. Check out the rails log:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Exist fragment? views/post-2/1304291241 (0.5ms)
Write fragment views/post-2/1304291241 (0.4ms)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cool! Now let&amp;#8217;s make it so creating a comment updates the post&amp;#8217;s timestamp:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Comment &amp;lt; ActiveRecord::Base
  belongs_to :post, :touch =&amp;gt; true
end&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now all comments will touch the post and change the &lt;code&gt;updated_at&lt;/code&gt; time stamp. You can see this in action by &lt;code&gt;touch&lt;/code&gt;&amp;#8216;ing a post.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Post.find(1).touch

Exist fragment? views/post-2/1304292445 (0.4ms)
Write fragment views/post-2/1304292445 (0.4ms)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This concept is known as: &lt;strong&gt;auto expiring cache keys.&lt;/strong&gt; You create a composite key with the normal key and a time stamp. This will create some memory build up as objects are updated and no longer create cache hits. For example. You have that fragment. It is cached. Then someone updates the post. You now have two versions of the fragment cached. If there are 10 updates, then there are 10 different versions. Luckily for you, this is not a problem for memcached! Memcached uses a LRU replacement policy. LRU stands for Least Recently Used. That means the key that hasn&amp;#8217;t been request in the longest time will be replaced with new content needs to be stored. For example, assume your cache can only hold 10 posts. The next update will create a new key and hence new content. Version 0 will be deleted and version 11 will be stored in the cache. The total amount of memory is cycled between things that are requested. There are two things to consider in this approach. 1: You will not be able to ensure that content is kept in the cache as long as possible. 2. You will never have to worry about expiring things manually as long as timestamps are updated in the model layer. I&amp;#8217;ve found it is orders of magnitude easier to add a few &lt;code&gt;:touch =&amp;gt; true&lt;/code&gt;&amp;#8217;s to my relationships than it is to maintain sweepers. More on sweepers later. We must continue exploring cache keys.&lt;/p&gt;

&lt;p&gt;Rails uses auto-expiring cache keys by &lt;strong&gt;default.&lt;/strong&gt; The problem is they are not mentioned at all the documentation or in the guides. There is one very handy method: &lt;code&gt;ActiveRecord::Base.cache_key&lt;/code&gt;. This will generate a key like this: &lt;code&gt;posts/2-20110501232725&lt;/code&gt;. &lt;strong&gt;This is the exact same thing we did ourselves.&lt;/strong&gt; This method is very important because depending on what type of arguments you pass into the &lt;code&gt;cache&lt;/code&gt; method it will be called on them. For the time being, this code is functionally equal to our previous examples.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;%= cache @post do %&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;cache&lt;/code&gt; helper takes different forms for arguments. Here are some examples:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cache &amp;#39;explicit-key&amp;#39;      # views/explicit-key
cache @post               # views/posts/2-1283479827349
cache [@post, &amp;#39;sidebar&amp;#39;]  # views/posts/2-2348719328478/sidebar
cache [@post, @comment]   # views/posts/2-2384193284878/comments/1-2384971487
cache :hash =&amp;gt; :of_things # views/localhost:3000/posts/2?hash_of_things&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If an &lt;code&gt;Array&lt;/code&gt; is the first arguments, Rails will use cache key expansion to generate a string key. This means calling doing logic on each object then joining each result together with a &amp;#8217;/&amp;#8217;. Essentially, if the object responds to &lt;code&gt;cache_key&lt;/code&gt;, it will use that. Else it will do various things. Here&amp;#8217;s the source for &lt;code&gt;expand_cache_key&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def self.expand_cache_key(key, namespace = nil)
  expanded_cache_key = namespace ? &amp;quot;#{namespace}/&amp;quot; : &amp;quot;&amp;quot;

  prefix = ENV[&amp;quot;RAILS_CACHE_ID&amp;quot;] || ENV[&amp;quot;RAILS_APP_VERSION&amp;quot;]
  if prefix
    expanded_cache_key &amp;lt;&amp;lt; &amp;quot;#{prefix}/&amp;quot;
  end

  expanded_cache_key &amp;lt;&amp;lt;
    if key.respond_to?(:cache_key)
      key.cache_key
    elsif key.is_a?(Array)
      if key.size &amp;gt; 1
        key.collect { |element| expand_cache_key(element) }.to_param
      else
        key.first.to_param
      end
    elsif key
      key.to_param
    end.to_s

  expanded_cache_key
end&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is where all the magic happens. Our simple fragment caching example could easily be converted into an idea like this: The post hasn&amp;#8217;t changed, so cache the entire result of /posts/1. You can do with this action caching or page caching.&lt;/p&gt;

&lt;h2 id='moving_on_to_action_caching'&gt;Moving on to Action Caching&lt;/h2&gt;

&lt;p&gt;Action caching is an around filter for specific controller actions. It is different from page caching since before filters are run and may prevent access to certain pages. For example, you only want to cache if the user is logged in. If the user is not logged in they should be redirect to the log in page. This is different than page caching. Page caching bypasses the rails stack completely. Most web applications for legitimate complexity cannot use page caching. Action caching is the next logical step for most web applications. Let&amp;#8217;s break the idea down: If the post hasn&amp;#8217;t changed, return the entire cached page as the HTTP response, else render the show view, cache it, and return that as the HTTP response. Or in code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Rails.cache.fetch &amp;#39;views/localhost:3000/posts/1&amp;#39; do
  @post = Post.find params[:id]
  render :show
end&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Declaring action caching is easy. Here&amp;#8217;s how you can cache the show action:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class PostsController &amp;lt; ApplicationController

  caches_action :show

  def show
    # do stuff
  end
end&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now refresh the page and look at what&amp;#8217;s been cached.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Started GET &amp;quot;/posts/2&amp;quot; for 127.0.0.1 at 2011-05-01 16:54:43 -0700
  Processing by PostsController#show as HTML
  Parameters: {&amp;quot;id&amp;quot;=&amp;gt;&amp;quot;2&amp;quot;}
Read fragment views/localhost:3000/posts/2 (0.5ms)
Rendered posts/show.html.erb within layouts/application (6.1ms)
Write fragment views/localhost:3000/posts/2 (0.5ms)
Completed 200 OK in 16ms (Views: 8.6ms | ActiveRecord: 0.1ms)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that the show action for post #2 is cached, refresh the page and see what happens.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Started GET &amp;quot;/posts/2&amp;quot; for 127.0.0.1 at 2011-05-01 16:55:27 -0700
  Processing by PostsController#show as HTML
  Parameters: {&amp;quot;id&amp;quot;=&amp;gt;&amp;quot;2&amp;quot;}
Read fragment views/localhost:3000/posts/2 (0.6ms)
Completed 200 OK in 1ms&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Damn. 16ms vs 1ms. You can see the difference! You can also see Rails reading that cache key. &lt;strong&gt;The cache key is generated off the url with action caching.&lt;/strong&gt; Action caching is a combination of a before and around filter. The around filter is used to capture the output and the before filter is used to check to see if it&amp;#8217;s been cached. It works like this:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Execute before filter to check to see if cache key exists?&lt;/li&gt;

&lt;li&gt;Key exists? - Read from cache and return HTTP Response. This triggers a &lt;code&gt;render&lt;/code&gt; and &lt;strong&gt;prevents any further code from being executed.&lt;/strong&gt;&lt;/li&gt;

&lt;li&gt;No key? - Call all controller and view code. Cache output using Rails.cache and return HTTP response.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Now you are probably asking the same question as before: &amp;#8220;What do we do when the post changes?&amp;#8221; We do the same thing as before: we create a composite key with a string and a time stamp. The question now is, how do we generate a special key using action caching?&lt;/p&gt;

&lt;p&gt;Action caching generates a key from the current url. You can pass extra options using the &lt;code&gt;:cache_path&lt;/code&gt; option. Whatever is in this value is passed into &lt;code&gt;url_for&lt;/code&gt; using the current parameters. Remember in the view cache key examples what happened when we passed in a hash? We got a much different key than before:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;views/localhost:3000/posts/2?hash_of_things&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Rails generated a URL based key instead of the standard views key. This is because you may different servers and things like that. This ensures that each server has it&amp;#8217;s own cache key. IE, server one does not collide with server 2. We could generate our own url for this resource by doing something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;url_for(@post, :tag =&amp;gt; @post.updated_at.to_i)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will generate this url:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://localhost:3000/posts/1?tag=234897123978&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice the &amp;#8216;?tag=23481329847&amp;#8217;. Look familiar from anywhere? Rails uses this method to tag GET urls for static assets. That way the browser does not send a new HTTP request when it sees &amp;#8216;application.css?1234&amp;#8217; since it is caching it. We can use this strategy to with action caching as well.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;caches_action :show, :cache_path =&amp;gt; proc { |c|
  # c is the instance of the controller. Since action caching
  # is declared at the class level, we don&amp;#39;t have access to instance
  # variables. If cache_path is a proc, it will be evaluated in the
  # the context of the current controller. This is the same idea
  # as validations with the :if and :unless options
  #
  # Remember, what is returned from this block will be passed in as
  # extra parameters to the url_for method.
  post = Post.find c.params[:id]
  {:tag =&amp;gt; post.updated_at.to_i}
end&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This calls &lt;code&gt;url_for&lt;/code&gt; with the parameters already assigned by it through the router and whatever is returned by the block. Now if you refresh the page, you&amp;#8217;ll have this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Started GET &amp;quot;/posts/2&amp;quot; for 127.0.0.1 at 2011-05-01 17:11:22 -0700
  Processing by PostsController#show as HTML
  Parameters: {&amp;quot;id&amp;quot;=&amp;gt;&amp;quot;2&amp;quot;}
Read fragment views/localhost:3000/posts/2?tag=1304292445 (0.5ms)
Rendered posts/show.html.erb within layouts/application (1.7ms)
Write fragment views/localhost:3000/posts/2?tag=1304292445 (0.5ms)
Completed 200 OK in 16ms (Views: 4.4ms | ActiveRecord: 0.1ms)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And volia! Now we have an expiring cache key for our post! Let&amp;#8217;s dig a little deeper. We know the key. Let&amp;#8217;s look into the cache and see what it actually is! You can see the key from the log. Look it up in the cache.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; Rails.cache.read &amp;#39;views/localhost:3000/posts/2?tag=1304292445&amp;#39;
=&amp;gt; &amp;quot;&amp;lt;!DOCTYPE html&amp;gt;\n&amp;lt;html&amp;gt;\n&amp;lt;head&amp;gt;.....&amp;quot;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;#8217;s just a straight HTML string. Easy to use and return as the body. This method works well for singular resources. How can we handle the index action? I&amp;#8217;ve created 10,000 posts. It takes a good amount of time to render that page on my computer. It takes over 10 seconds. The question is, how can we cache this? We could use the most recently updated post for the time stamp. That way, when one post is updated, it will move to the top and create a new cache key. Here is the code without any action caching:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Started GET &amp;quot;/posts&amp;quot; for 127.0.0.1 at 2011-05-01 17:18:11 -0700
  Processing by PostsController#index as HTML
  Post Load (54.1ms)  SELECT &amp;quot;posts&amp;quot;.* FROM &amp;quot;posts&amp;quot; ORDER BY updated_at DESC LIMIT 1
Dalli::Server#connect localhost:11212
Read fragment views/localhost:3000/posts?tag=1304292445 (1.5ms)
Rendered posts/index.html.erb within layouts/application (9532.3ms)
Write fragment views/localhost:3000/posts?tag=1304292445 (36.7ms)
Completed 200 OK in 10088ms (Views: 9535.6ms | ActiveRecord: 276.2ms)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now with action caching:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Started GET &amp;quot;/posts&amp;quot; for 127.0.0.1 at 2011-05-01 17:20:47 -0700
  Processing by PostsController#index as HTML
Read fragment views/localhost:3000/posts?tag=1304295632 (1.0ms)
Completed 200 OK in 11ms&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;#8217;s the code for action caching:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;caches_action :index, :cache_path =&amp;gt; proc {|c|
  post = Post.order(&amp;#39;updated_at DESC&amp;#39;).limit(1).first
  {:tag =&amp;gt; post.updated_at.to_i}
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These are simple examples designed to show you who can create auto expiring keys for different situations. At this point we have not add to expire any thing ourselves! The keys have done it all for us. However, there are some times when you want more precise control over how things exist in the cache. Enter Sweepers.&lt;/p&gt;

&lt;h2 id='sweepers'&gt;Sweepers&lt;/h2&gt;

&lt;p&gt;Sweepers are HTTP request dependent observers. They are loaded into controllers and observer models the same way standard observers do. However there is one very important different. &lt;strong&gt;They are only used through HTTP requests.&lt;/strong&gt; This means if you have things being created outside the context of HTTP requests sweepers will do you know good. For example, say you have a background process running that syncs with an external system. Creating a new model will not make it to any sweeper. So, if you have anything cached. It is up to you to expire it. Everything I&amp;#8217;ve demonstrated so far can be done with sweepers.&lt;/p&gt;

&lt;p&gt;Each &lt;code&gt;cache_*&lt;/code&gt; method has an opposite &lt;code&gt;expire_*&lt;/code&gt; method. Here&amp;#8217;s the mapping:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;caches_page , expire_page&lt;/li&gt;

&lt;li&gt;caches_action , expire_action&lt;/li&gt;

&lt;li&gt;cache , expire_fragment&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Their arguments work the same with using cache_key_expansion to find a key to read or delete. Depending on the complexity of your application, it may be very to use sweepers or it may be impossible. Our simple examples can use sweepers easily. We only need to tie into the save event. For example, when a update or delete happens we need to expire the cache for that specific post. When a create, update, or delete happens we need to expire the index action. Here&amp;#8217;s what a the sweeper would look like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class PostSweeper &amp;lt; ActionController::Caching::Sweeper
  observe Post

  def after_create(post)
    expire_action :index
    expire_action :show, :id =&amp;gt; post
    # this is the same as the previous line
    expire_action :controller =&amp;gt; :posts, :action =&amp;gt; :show, :id =&amp;gt; @post.id
  end
end

# then in the controller, load the sweeper
class PostsController &amp;lt; ApplicationController
  cache_sweeper :post_sweeper
end&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I will not go into much depth on sweepers because they are the only thing covered in the rails caching guide. The work, but I feel they are clumsy for complex applications. Let&amp;#8217;s say you have comments for posts. What do you do when a comment is created for a post? Well, you have to either create a comment sweeper or load the post sweeper into the comments controller. You can do either. However, depending on the complexity of your model layer, it may quickly infeasible to do cache expiration with sweepers. For example, let say you have a Customer. A customer has 15 different types of associated things. Do you want to put the sweeper into 15 different controllers? You can, but you may forget to at some point.&lt;/p&gt;

&lt;p&gt;The real problem with sweepers is that they cannot be used once your application works outside of HTTP requests. They can also be clumsy. I personally feel it&amp;#8217;s much easier to create auto expiring cache keys and only uses sweepers when I want to tie into very specific events.&lt;/p&gt;

&lt;p&gt;Now you should have a good grasp on how the Rails caching methods work. We&amp;#8217;ve covered how fragment caching uses the current view to generate a cache key. We introduced the concept of auto expiring cache keys using &lt;code&gt;ActiveRecord#cache_key&lt;/code&gt; to automatically expire cached content. We introduced action caching and how it uses &lt;code&gt;url_for&lt;/code&gt; to generate a cache key. Then we covered how you can pass things into &lt;code&gt;url_for&lt;/code&gt; to generate a time stamped key to expire actions automatically. We&amp;#8217;ve skipped page caching because it&amp;#8217;s not applicable to many Rails applications. Now that we understand how caching works we can address shortcomings in the system.&lt;/p&gt;

&lt;h2 id='moving_away_from_the_http_request'&gt;Moving Away from the HTTP Request&lt;/h2&gt;

&lt;p&gt;Now we&amp;#8217;re going to write some code to address problems in the Rails caching system. We know that action caching is dependent on URLS. Fragment caching is dependent on the view being rendered. However, we know that both of these methods use &lt;code&gt;Rails.cache&lt;/code&gt; under the covers to store content. We can use &lt;code&gt;Rails.cache&lt;/code&gt; any where in our code. Unlike &lt;code&gt;caches_path&lt;/code&gt;, &lt;code&gt;caches_action&lt;/code&gt; and &lt;code&gt;cache&lt;/code&gt; that will no hit the cache if &lt;code&gt;perform_caching&lt;/code&gt; is set to false, the &lt;code&gt;Rails.cache&lt;/code&gt; methods will &lt;strong&gt;always&lt;/strong&gt; execute against the cache. Ideally, it would be nice to create a simple observer for our models. What it would be cool if we had a class like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Cache 
  def self.expire_page(*args)
    # do stuff
  end

  def self.expire_action(*args)
    # do stuff
  end

  def self.expire_fragment(*args)
    # do stuff
  end
end&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we can use that utility class anywhere in our code to expire different things we have cached. First, we need to be able to generate URL&amp;#8217;s from something other than a controller. You may be familiar with this problem. Mailers are not controllers, but you can still generate URL&amp;#8217;s. You need a host name to generate paths. The controller have this information because they accept HTTP requests which have that information. Mailer do not. That&amp;#8217;s why the host name must be configured in the different environments. We can create a frankenstein class that takes parts of ActionMailer to generate URLS. Once we can generate URL&amp;#8217;s we can expire pages and actions. URL generation is included this module &lt;code&gt;Rails.application.routes.url_helpers&lt;/code&gt;. That&amp;#8217;s a shortcut method for the generated module which contains &lt;code&gt;url_for&lt;/code&gt;, &lt;code&gt;path_for&lt;/code&gt; and all the named route helpers. We also need a class level variable for the host name. Here&amp;#8217;s what we can do so far:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Cache
  include Rails.application.routes.url_helpers # for url generation

  def self.default_url_options
    ActionMailer::Base.default_url_options
  end

  def expire_action(*args)
    # do stuff
  end

  def expire_fragment(*args)
    # do stuff
  end
end&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can pull in some knowledge on how the cache system works to fill in the gaps. Some of this comes from reading the various source files and observation in generating the cache keys. Here is the complete class:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# will not work in Rails 2 -- Rails 3 only!
class Cache
  include Rails.application.routes.url_helpers # for url generation

  def self.default_url_options
    ActionMailer::Base.default_url_options
  end

  def expire_action(key, options = {})
    expire(key, options)
  end

  def expire_fragment(key, options={})
    expire(key, options)
  end

  private
  def caching_enabled?
    return ActionController::Base.perform_caching
  end

  def expire(key, options = {})
    return unless caching_enabled?
    Rails.cache.delete expand_cache_key(key), options
  end

  def expand_cache_key(key)
    # if the key is a hash, then use url for
    # else use expand_cache_key like fragment caching
    to_expand = key.is_a?(Hash) ? url_for(key).split(&amp;#39;://&amp;#39;).last : key
    ActiveSupport::Cache.expand_cache_key to_expand, :views
  end
end&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since action and fragment caching all use Rails.cache under the hood, we can simply generate the keys ourselves and remove them manually&amp;#8211;all without the fuss of HTTP Requests. Now you can create an initializer to define a method on your application namespace so it&amp;#8217;s globally accessible. I like this way because it&amp;#8217;s easy to reference in any piece of code.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# config/initializers/cache.rb
require &amp;#39;cache&amp;#39;

module App # whatever you application module is
  class &amp;lt;&amp;lt; self
    def cache
      @cache ||= Cache.new
    end

    def expire_fragment(*args)
      cache.expire_fragment(*args)
    end

    def expire_action(*args)
      cache.expire_fragment(*args)
    end
  end
end&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can merrily go about our business expiring cached content from &lt;strong&gt;anywhere.&lt;/strong&gt; Here are some examples:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;App.cache # reference to a Cache instance

App.expire_fragment @post
App.expire_fragment [@post, &amp;#39;sidebar&amp;#39;]
App.expire_fragment &amp;#39;explicit-key&amp;#39;

# in a controller
App.expire_fragment post_url(@post)
# Have to pass in the hash since it&amp;#39;s most likely
# that you won&amp;#39;t have access to the url helpers
# in whatever scope your&amp;#39;re in.
App.expire_action :action =&amp;gt; :show, :controller =&amp;gt; :posts, :id =&amp;gt; @post, :tag =&amp;gt; @post.updated_at.to_i&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;expire_fragment&lt;/code&gt; and &lt;code&gt;expire_action&lt;/code&gt; methods work just like the ones described in the Rails guides. Only difference is, you can use them anywhere. Now we can easily call this code in an observer. The observer events will fire every time they happen &lt;strong&gt;anywhere in the codebase.&lt;/strong&gt; Here&amp;#8217;s an example. I am assuming a todo is created outside an HTTP request through a background process. The observer will capture the event.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class TodoObserver &amp;lt; ActivRecord::Observer
  def after_create
    App.expire_fragment :controller =&amp;gt; :todos, :action =&amp;gt; :index
  end
end&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The beauty here is that we can use this code anywhere. If you have more complicated cache expirations you may have to use a background job. This may not be acceptable because of processing time, but in some situations you can afford a sweeping delay if the sweeping process takes a long time. You could easily use this code with DelayedJob or Resque if needed. After all, the generated rails code does reference a cache observer&amp;#8211;now you know how to write one.&lt;/p&gt;

&lt;h2 id='tagged_based_caching'&gt;Tagged Based Caching&lt;/h2&gt;

&lt;p&gt;This is an approach I came up with to work in this situation:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Maintain control over how long things are cached&lt;/li&gt;

&lt;li&gt;Large number of different associations. Actions or fragments no longer related to a specific resource.&lt;/li&gt;

&lt;li&gt;Content could be invalidated through HTTP requests or any number of background process.&lt;/li&gt;

&lt;li&gt;Hard to maintain specific keys. I thought of it as &amp;#8220;resources&amp;#8221;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;There is a ton of cached content in the system. Many different actions and fragments. There was also a cache hierarchy. Expiring a specific fragment would have to expire an action (so a cache miss would occur when a page was requested thus, causing the new fragment to be displayed) while other things on pages are still cached. One question to ask, is how can I expire groups of things based on certain events? Well, first you need a way to associate different keys. Once you can associate different keys, then you can expire them together. Since you&amp;#8217;re tracking the keys being sent to &lt;code&gt;Rails.cache&lt;/code&gt;, you can simply use &lt;code&gt;Rails.cache&lt;/code&gt; to delete them. All of this is possible through one itty-bitty detail of the Rails caching system.&lt;/p&gt;

&lt;p&gt;You may have noticed something in the &lt;code&gt;Cache&lt;/code&gt; class in the previous section. There is a second argument for &lt;code&gt;options&lt;/code&gt;. Anything in the &lt;code&gt;option&lt;/code&gt; argument is passed to the cache store. This is where can tie in the grouping logic. Also, since action and fragment caching use the same mechanism to write to the cache, we simply have to override the &lt;code&gt;write_fragment&lt;/code&gt; method to add our tagging logic.&lt;/p&gt;

&lt;p&gt;Through all of this trickery, you&amp;#8217;ll be able to express this type of statement:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;App.cache.expire_tag &amp;#39;stats&amp;#39; 
App.cache.expire_tag @account&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The content could from anywhere, but all you know is that&amp;#8217;s stale.&lt;/p&gt;

&lt;p&gt;This is exactly where &lt;a href='http://rubygems.org/gems/cashier'&gt;Cashier&lt;/a&gt; comes in. It is (my gem) that allows you associate actions and fragments with one or more tags, then expire based of tags. Of course you can expire the cache from anywhere in your code. Here are some examples:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;caches_action :stats, :tag =&amp;gt; proc {|c|
  &amp;quot;account-#{Account.find(c.params[:id]).id}&amp;quot;
}

caches_action :show, :tag =&amp;gt; &amp;#39;account&amp;#39;
caches_cation :show, :tag =&amp;gt; %w(account customer)

&amp;lt;%= cache @post, :tag =&amp;gt; &amp;#39;customer&amp;#39; do %&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then you can expire like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Cashier.expire &amp;#39;account&amp;#39; # wipe all keys tagged &amp;#39;account&amp;#39;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All this is possible through this module:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module Cashier
  module ControllerHelper
    def self.included(klass)
      klass.class_eval do
        def write_fragment_with_tagged_key(key, content, options = nil)
          if options &amp;amp;&amp;amp; options[:tag] &amp;amp;&amp;amp; Cashier.perform_caching? 
            tags = case options[:tag].class.to_s
                   when &amp;#39;Proc&amp;#39;, &amp;#39;Lambda&amp;#39;
                     options[:tag].call(self)
                   else 
                     options[:tag]
                   end
            Cashier.store_fragment fragment_cache_key(key), *tags
          end
          write_fragment_without_tagged_key(key, content, options)
        end
        alias_method_chain :write_fragment, :tagged_key
      end
    end
  end
end&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I higly recommend you checkout &lt;a href='http://rubygems.org/gems/cashier'&gt;Cashier&lt;/a&gt;. It may be useful in your application especially if you have complicated relationships with high performance requirements.&lt;/p&gt;

&lt;h2 id='caching_complicated_actions_or_methods'&gt;Caching Complicated Actions (or Methods)&lt;/h2&gt;

&lt;p&gt;Let&amp;#8217;s say you have an index action. However, it&amp;#8217;s more complicated than a normal scaffold index. The user can search, filer, sort and apply different query options. Think for example a form build with MetaWhere or Sunspot. There are infinite number of combinations, but the data is always the same. That is, a search for &amp;#8220;EC2&amp;#8221; will always have the same results as another search for &amp;#8220;EC2&amp;#8221; as long as the underlying data hasn&amp;#8217;t changed. We could easily cache the index action if we could figured how to represent each unique combination of input parameters as a key value. Memcached also has a key length limit. I don&amp;#8217;t know what it is off the top of my head, but you should try to keep the key short. How can we do this? We use a &lt;strong&gt;cryptographic hash.&lt;/strong&gt; A cryptographic hash is guaranteed to be unique given a unique set of input parameters. This means there no collisions.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hash(key1) != hash(key2) # will always be true&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Ruby Standard Library comes with SHA1. SHA1 is good hashing function so we&amp;#8217;ll have no problems using it for these examples. It takes a string input and generates a hash. We&amp;#8217;ll create a composite key with a timestamp and string representation of the input parameters.&lt;/p&gt;

&lt;p&gt;require &amp;#8216;digest/sha1&amp;#8217;&lt;/p&gt;

&lt;p&gt;class ComplicatedSearchController &amp;lt; ApplicationController&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;caches_action :search, :cache_path =&amp;gt; proc {|c|
  timestamp = Model.most_recently_updated.updated_at
  string = timestamp + c.params.inspect
  {:tag =&amp;gt; Digest::SHA.hexdigest(string)}
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;end&lt;/p&gt;

&lt;p&gt;That will cache every combination of input parameters you can throw at it. This is perfect for actions with pagination as well. It&amp;#8217;s perfect for anything that uses the same underlying data based on input parameters. This can save your bacon if a search takes a few seconds. If one user just did the same search, the second user won&amp;#8217;t have to wait at all. Hell, they might even be impressed.&lt;/p&gt;

&lt;h2 id='bringing_caching_into_the_model_layer'&gt;Bringing Caching into the Model Layer&lt;/h2&gt;

&lt;p&gt;Caching isn&amp;#8217;t just for views. Some DB operations or methods make be computationally intensive. We can use &lt;code&gt;Rails.cache&lt;/code&gt; inside the models to make them more efficient. Let&amp;#8217;s say you wanted to cached the listing of all the top 100 posts on reddit.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Post
  def self.top_100
    timestamp = Post.most_recently_updated.updated_at
    Rails.cache.fetch [&amp;#39;top-100&amp;#39;, timestamp.to_i&amp;#39;].join(&amp;#39;/&amp;#39;) do
      order(&amp;#39;vote_count DESC&amp;#39;).limit(100).all
    end
  end
end&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;#8217;ve used the &lt;code&gt;most_recently_updated&lt;/code&gt; method a few times. It is not a defined method, but a method named so that you understand what it is doing. We can use these concepts to do more fun stuff. My main project has companies and customers. An account has many customers and companies. It&amp;#8217;s typical that I need to retrieve all the customers per an account. This can be 10000 records. That takes time. ActiveRecord instantiation on that order is not free. However, I only care about customers or companies in the scope of a specific account. That means, I only use the account and customers/companies association. Rails gives you the ability to specific a different attribute for &lt;code&gt;:touch&lt;/code&gt; on &lt;code&gt;belongs_to&lt;/code&gt;. I use this to my advantage to create an &amp;#8216;association_name_updated_at&amp;#8217; column. Then specify :touch =&amp;gt; &amp;#8216;association_name_updated_at&amp;#8217;. Here&amp;#8217;s how it looks in code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Account &amp;lt; ActiveRecord::Base
  has_many :customers
end

class Customers &amp;lt; ActiveRecord::Base
  belongs_to :account, :touch =&amp;gt; :customers_updated_at
end&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That gives me a timestamp I can use to generate all keys. Now I can use Rails.cache to fetch different queries and keep them all cached. You can wrap this functionality in a module and include in other associations.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;require &amp;#39;digest/sha1&amp;#39;

module CachedFinderExtension
  def cached(options = {})
    key = Digest::SHA1.hexdigest(options.to_s)
    association_name = proxy_reflection.name
    owner_key = [proxy_owner.class.to_s.underscore, proxy_owner.id].join(&amp;#39;/&amp;#39;)
    tag = proxy_owner.send(&amp;quot;#{association_name}_updated_at&amp;quot;).to_i

    Rails.cache.fetch [owner_key, association_name, tag, key].join(&amp;#39;/&amp;#39;) do
      all options
    end
  end
end&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;all&lt;/code&gt; is a method that takes many options. We don&amp;#8217;t really care what&amp;#8217;s passed in, we just need to be able to generate a cache key based on the input parameters. Since we know when the association was last updated, the method will return fresh content depending if records have been modified. Include the extension in your association and you&amp;#8217;re on your way!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Account &amp;lt; ActiveRecord::Base
  has_many :customers, :extend =&amp;gt; CachedFinderExentsion
end

# all find&amp;#39;s now automatically cached and expired
@account.customers.cached(:conditions =&amp;gt; {:name =&amp;gt; &amp;#39;Adam&amp;#39;})
@account.customers.cache(:order =&amp;gt; &amp;#39;name ASC&amp;#39;, :limit =&amp;gt; 10})&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These are just examples of what you can do with caching in the model layer. You could even write the type of cached finder extension for ActiveRecord::Base. This is different from SQL caching since it only persists through request&amp;#8211;this is cached throughout the entire application.&lt;/p&gt;

&lt;h2 id='csrf_and_form_authenticty_token'&gt;CSRF and form_authenticty_token&lt;/h2&gt;

&lt;p&gt;Rails uses a CSRF (Cross Site Request Forgery) token and a form authentic token to protect your application against attacks. These are generated per request and each pages get unique values each time. &lt;code&gt;protect_from_forgery&lt;/code&gt; is added by default to &lt;code&gt;ApplicationController&lt;/code&gt;. You may have run into the problem before. You may have tried to submit a POST and received an Unauthorized response. This is the &lt;code&gt;form_authenticity_token&lt;/code&gt; in action. You can fiddle with it and see what happens to your application.&lt;/p&gt;

&lt;p&gt;These tokens cause problems (depending on what Rails version) you&amp;#8217;re using with cached HTML. Caching a page or an action with a form may generate unauthorized errors because the tokens were for a different session or request. There are parts of the cached pages that need to be &lt;em&gt;replaced&lt;/em&gt; with new values before the application can be used. This is a simple process, but it will take another HTTP request.&lt;/p&gt;

&lt;p&gt;You&amp;#8217;ll need to create a controller to server up some configuration related information that&amp;#8217;s never cached. That way, a cached action will load, then a separate request will be made for correct tokens.&lt;/p&gt;

&lt;p&gt;NOTE: You may run into more problems with on Rails 2. This is because Rails 3 uses a form authenticity token and CSRF in a meta tag in the HEAD of the document. This is for AJAX requests. You may notice the rails.js file appends them to all AJAX requests. Forms submitted with AJAX with something like &lt;code&gt;$(form).serialize()&lt;/code&gt; will send the &lt;code&gt;form_authenticty_token&lt;/code&gt; since it&amp;#8217;s automatically included in all forms generated with &lt;code&gt;form_for&lt;/code&gt; or &lt;code&gt;form_tag&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You need to create a new controller that responds_to JavaScript and return some JS for the browser to evaluate. Here&amp;#8217;s how you can replace the information in the meta tag for Rails 3. You can also use this logic to update all &lt;code&gt;form_authenticty_token&lt;/code&gt; inputs on the page.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(&amp;quot;meta[name=&amp;#39;csrf-token&amp;#39;]&amp;quot;).attr(&amp;#39;content&amp;#39;, &amp;#39;&amp;lt;% Rack::Utils.escape_html(request_forgery_protection_token) %&amp;gt;&amp;#39;);
$(&amp;quot;meta[name=&amp;#39;csrf-param&amp;#39;]&amp;quot;).attr(&amp;#39;content&amp;#39;, &amp;#39;&amp;lt;% Rack::Utils.escape_html(form_authenticity_token) %&amp;gt;&amp;#39;);

// you may also want to supply current application status as well.
// for example, you may want to know the current users&amp;#39;s ID
// for use in your application JS
MyApp.userId = &amp;#39;&amp;lt;%= current_user.id %&amp;gt;&amp;#39;;&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='dealing_with_relative_dates_or_other_content'&gt;Dealing with Relative Dates (or other content)&lt;/h2&gt;

&lt;p&gt;Many Rails applications use &lt;code&gt;distance_of_times_in_words&lt;/code&gt; throughout their application. This can cause major problems for any cached content with a data. For example, you have a fragment cached. That fragment was cached 1 month ago. 2 months ago, it&amp;#8217;s still in the cache. Since you stored a relative date in the cache, the fragment contains &amp;#8216;1 month ago&amp;#8217;. This is no good. You can solve this problem easily with JavaScript.&lt;/p&gt;

&lt;p&gt;JavaScript is better for handling dates/times than Rails is. This is because Rails needs to know what the user&amp;#8217;s time zone is, then marshal all times into that time zone. JavaScript is better because it use the local time zone by default. How often do you want to display a time in a different zone than user&amp;#8217;s current locale? You can dump the UTC representation of the date into the DOM, then use JS to parse them into relative or something like &lt;code&gt;strftime&lt;/code&gt;. I&amp;#8217;ve encapsulated this process in a helper in my Rails applications. Once all the data is in the DOM, you can do all the parsing in JavaScript.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def timestamp(time, options = {})
  classes = %w(timestamp)
  classes &amp;lt;&amp;lt; &amp;#39;past&amp;#39; if time.past?
  classes &amp;lt;&amp;lt; &amp;#39;future&amp;#39; if time.future?

  options[:class] ||= &amp;quot;&amp;quot;
  options[:class] += classes.join(&amp;#39; &amp;#39;)

  content_tag(:span, time.utc.iso8601, options)
end&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, when the page loads you can use a library like date.js to create more user friendly dates.&lt;/p&gt;

&lt;h2 id='time_to_cash_out'&gt;Time to Cash Out&lt;/h2&gt;

&lt;p&gt;I&amp;#8217;ve covered a ton of material in this article. I&amp;#8217;ve given a through explanation of how all the Rails cache layers fit together and how to use the lowest level to it&amp;#8217;s full potential. I&amp;#8217;ve provided a solution for managin the cache outside the HTTP request cycle as well as shown you how to bring caching into the model layer. This is not the be-all-and-all of caching in Rails. It is a indepth look at caching in a Rails application. I&amp;#8217;ll leave you with a quick summary of everything covered and some few goodies.&lt;/p&gt;

&lt;h3 id='page_caching'&gt;Page Caching&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;The honest to goodness best caching ever. Bypass Rails completely.&lt;/li&gt;

&lt;li&gt;Usually not applicable to any web application. Have a form? No good, the &lt;code&gt;form_authenticity_token&lt;/code&gt; will be no good and Rails will reject it.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id='action_caching'&gt;Action Caching&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Most bang for the buck. Can usually be applied in many different circumstances.&lt;/li&gt;

&lt;li&gt;Uses fragment caching under the covers.&lt;/li&gt;

&lt;li&gt;Generates a cache key based off the current url and whatever other options are passed in&lt;/li&gt;

&lt;li&gt;Get more mileage by caching actions with an composite timestamped key.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id='fragment_caching'&gt;Fragment Caching&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Good for caching reusable bits of HTML. Think shared partials or forms.&lt;/li&gt;

&lt;li&gt;Use a good cache key for each cache block.&lt;/li&gt;

&lt;li&gt;Don&amp;#8217;t go overboard. Requests to memcached are not free. Maximize benefits by caching a small number of large fragments instead of a large number of small fragments.&lt;/li&gt;

&lt;li&gt;Use auto expiring cache keys to invalidate the cache automatically.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id='general_points'&gt;General Points&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Don&amp;#8217;t worry about sweepers unless you have too.&lt;/li&gt;

&lt;li&gt;Understand the limitations of Rail&amp;#8217;s HTTP request cycle&lt;/li&gt;

&lt;li&gt;Use cryptographic hashes to generate cache keys when permutations of input parameters are invloved.&lt;/li&gt;

&lt;li&gt;Don&amp;#8217;t be afraid to use Rails.cache in your models.&lt;/li&gt;

&lt;li&gt;Only use sweepers when you have to.&lt;/li&gt;

&lt;li&gt;Tagged based caching is useful in certain situations.&lt;/li&gt;

&lt;li&gt;Conslidate your cache expritation logic in one place so it&amp;#8217;s easily testable.&lt;/li&gt;

&lt;li&gt;Test with caching turned on in complex applications.&lt;/li&gt;

&lt;li&gt;Look into &lt;a href='http://www.varnish-cache.org/'&gt;Varnish&lt;/a&gt; for more epic wins.&lt;/li&gt;

&lt;li&gt;belongs to with &lt;code&gt;:touch =&amp;gt; true&lt;/code&gt; is your friend.&lt;/li&gt;

&lt;li&gt;Use association timestamps&lt;/li&gt;

&lt;li&gt;Spend time upfront considering your cache strategy.&lt;/li&gt;

&lt;li&gt;Be weary of examples with expire by regex. This only works on cache stores that have the ability to iterate over all keys. &lt;strong&gt;Memcached&lt;/strong&gt; is not one of those.&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>Learning Rails: A Glossary</title>
      <link>http://broadcastingadam.com/2011/04/rails_glossary</link>
      <pubDate>Sun, 24 Apr 2011 00:00:00 +0200</pubDate>
      <author>me@broadcastingadam.com (Adam Hawkins)</author>
      <guid>http://broadcasting.com/2011/04/rails_glossary</guid>
      <description>&lt;p&gt;I&amp;#8217;ve been teaching Rails to some people. One thing that&amp;#8217;s hard for them to get straight is the large number of tools involved in Rails development. This post is glossary of terms you may come across. Hopefully it will clarify things for you.&lt;/p&gt;

&lt;h2 id='acceptance_testing'&gt;Acceptance Testing&lt;/h2&gt;

&lt;p&gt;Acceptancing testing is the act of testing use cases. Test cases are written in a way that describes a use case. Then a test case is passing it can be accepted. Cucumber is a good tool for acceptance testings. Work with your stake holder to develop tests that represent use cases. When the test is complete the feature should be accepted. Acceptance testing is focused around people outside the code development accepting features.&lt;/p&gt;

&lt;h2 id='application_servers__thin_mongrel_passenger_unicorn'&gt;Application Servers - Thin, Mongrel, Passenger, Unicorn&lt;/h2&gt;

&lt;p&gt;These are all application servers. They interact with your Ruby code and respond to requests. They are integrated with web servers like Nginx or Apache to server you application on the internet.&lt;/p&gt;

&lt;h2 id='authentication'&gt;Authentication&lt;/h2&gt;

&lt;p&gt;Authentication is the process of matching credentials to a person and verifying them. Authentication is purely about identifiying who the user is&amp;#8211;and not what they can do. Devise is an example of an authentication library.&lt;/p&gt;

&lt;h2 id='authorization'&gt;Authorization&lt;/h2&gt;

&lt;p&gt;Authorization is the process for determine what a specific user can do. Authorization usually involves permission or role based systems. CanCan is an example of an authorization library.&lt;/p&gt;

&lt;h2 id='behavior_driven_development_bdd'&gt;Behavior Driven Development (BDD)&lt;/h2&gt;

&lt;p&gt;Is essentially the same as TDD except using a different set of tools to express code in terms of user facing behavior. Rspec and Cucumber are part of the BDD toolbox.&lt;/p&gt;

&lt;h2 id='bundler'&gt;Bundler&lt;/h2&gt;

&lt;p&gt;Bundler reads a Gemfile and calculates a set of version requirements to make all the specified gems live happily together. It will prevent version conflicts and infamous &amp;#8216;gem already activated error&amp;#8217;. It allows you to install git gems or standard gems from rubygems.org. It does not require libraries, it simply makes them available. It is up to you require them in your programs. Bundler can be used outside of rails. You should use bundler when you do any ruby work.&lt;/p&gt;

&lt;h2 id='capistrano'&gt;Capistrano&lt;/h2&gt;

&lt;p&gt;Capistrano is a tool for executing command one groups of remote (or local) serves over SSH. It is primary used to deploy Ruby (on Rails) application. It has support for multistage environments. Example, staging and production. You can easily write your own tasks similar to writing rake task. It is the preferred way deploy Rails applications.&lt;/p&gt;

&lt;h2 id='capybara'&gt;Capybara&lt;/h2&gt;

&lt;p&gt;Capybara is a gem designed to provide an abstraction layer between different browser drivers. It is primarily used in integration testing to interact with the web server. It provides an API to navigate between pages, click buttons, fill in forms, and other user interactions. It has adapters for many different browser drivers. Notable drivers include Selenium, rack-test and webrat.&lt;/p&gt;

&lt;h2 id='compass'&gt;Compass&lt;/h2&gt;

&lt;p&gt;Compass is a library built around SASS abstractions. It provides mixins for many common things like styling buttons and forms. It is also easy to extend and comes with many built in functions. The blueprint CSS framework is bundled by default.&lt;/p&gt;

&lt;h2 id='cucumber'&gt;Cucumber&lt;/h2&gt;

&lt;p&gt;Cucumber is a test framework for creating plain english acceptance tests. The tests can be executed automatically. Cucumber is used for integration testing web applications. The test suite is often used in CI (Continuous Integration). Cucumber uses a language called Gherkin to parse files into lines and match them against regular expressions. Regular expressions are matched with code blocks. Your test code lives in these blocks.&lt;/p&gt;

&lt;p&gt;Cucumber tests are divided up into &amp;#8220;Feature&amp;#8221; files. Each feature has many &amp;#8220;scenarios.&amp;#8221; Features are like use cases. Scenarios are different permutations of that use case. Here is an example Feature file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Feature: Make Widthdrawls from Accounts
  As an account holder
  I want to use my money
  In order to use it buy thing

  Background:
    Given I have account under &amp;quot;RubyX&amp;quot;
    And my account is activated

  Scenario: There is enough money in my account
    Given my account has &amp;quot;$1,000&amp;quot;
    And I&amp;#39;m at the bank
    When I widthdraw &amp;quot;$500&amp;quot;
    Then my account should have &amp;quot;$500&amp;quot;

  Scenario: There is not enough money in my account
    Given my account has &amp;quot;$1,000&amp;quot;
    And I&amp;#39;m at the bank
    When I widthdraw &amp;quot;$500&amp;quot;
    Then the teller should reject my transaction&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is an example step definition:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Given /I&amp;#39;m at the bank/ do
  # set up pre conditions
end

Then /the teller should reject my transaction/ do
  # assert on things
end&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='dsl'&gt;DSL&lt;/h2&gt;

&lt;p&gt;DSL stands for Domain Specific Language. They are crafted to solve one or more problems very eloquently and nothing more. For example, a DSL created to declare work order would be horrible suited for writing Photoshop. DSLs are usually wrappers around more complicated methods that make it easier to express the intent of the underlying code from a programmer&amp;#8217;s perspective. You may have used a DSL before and not realized it. Here is an example from Sunspot&amp;#8217;s search functionality. It&amp;#8217;s designed for describing a search and nothing more:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Post.search do
  fulltext &amp;#39;best pizza&amp;#39;
  with :blog_id, 1
  with(:published_at).less_than Time.now
  order_by :published_at, :desc
  paginate :page =&amp;gt; 2, :per_page =&amp;gt; 15
  facet :category_ids, :author_id
end&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='erb'&gt;ERB&lt;/h2&gt;

&lt;p&gt;ERB is Embedded Ruby. ERB is built into the Ruby core. It allows to to place Ruby inside other files. For example, placing Ruby inside HTML. Here is an example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;&amp;lt;%= @ticket.state %&amp;gt;&amp;quot;
  &amp;lt;p&amp;gt;&amp;lt;%= @ticket.message %&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='factories__factorygirl__machinist'&gt;Factories - FactoryGirl &amp;amp; Machinist&lt;/h2&gt;

&lt;p&gt;These are two popular libraries for creating object factories. They are usually used in test suites and population scripts. They provide a default set of attributes and allow programmers to specify the attributes they care about at creation time.&lt;/p&gt;

&lt;h2 id='git'&gt;Git&lt;/h2&gt;

&lt;p&gt;Git is a distributed version control system. Each user has a complete copy of the repository. Changes can be pushed back to the remote repositories for others to pull or push from. Linus Torvalds created Git because he was unsatisfied with other version control systems like CVS or SVN. Do not get GitHub confused with Git. GitHub is simply a service for hosting the main Git repository. You can use git independent of github, however most Ruby developers use github exclusively.&lt;/p&gt;

&lt;h2 id='haml'&gt;HAML&lt;/h2&gt;

&lt;p&gt;HAML is an HTML abstraction language. It&amp;#8217;s great for structuring documents and horrible to content. It will autoclose tags and lets you specify attributes as a hash. You can also include ruby code inside the templates. Here is an example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.post#post_5 
  .content= simple_format(@post.content)&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='heroku'&gt;Heroku&lt;/h2&gt;

&lt;p&gt;Ruby PaaS (Platform as a Service). They provide free cloud hosting for Rack applications with paid plans for increased resources. It is a very easy way to deploy your first application. Beware, they are easily owned by Amazon&amp;#8217;s AWS failure.&lt;/p&gt;

&lt;h2 id='metaprogramming'&gt;Metaprogramming&lt;/h2&gt;

&lt;p&gt;Metaprogramming is a term for dynamically generating code at runtime. Metaprogramming is why Rails feel the way it does. ActiveRecord associations to dynamically add methods to your classed based on how to declare them. Metaprogramming is possible in Ruby because it&amp;#8217;s a dynamic language interpreted at run time.&lt;/p&gt;

&lt;h2 id='open_classes__monkey_patching'&gt;Open Classes &amp;amp; Monkey Patching&lt;/h2&gt;

&lt;p&gt;Ruby has open classes. This means you can simply declare methods insides a class that&amp;#8217;s already been defined. ActiveSupport uses open classes to add all those nice methods to core Ruby objects. This is how you can add a method to the &lt;code&gt;String&lt;/code&gt; class:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class String
  def wtf?
    puts &amp;quot;wtf? &amp;quot; * self.length
  end
end&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='rake'&gt;Rake&lt;/h2&gt;

&lt;p&gt;Rake is like the Ruby version of make. You can create custom tasks that can be executed from the command line. &lt;code&gt;rake db:migrate&lt;/code&gt; is a classic example. You can create as many tasks as you want. They can have prerequisites. They can also be in namespaces. A &amp;#8217;:&amp;#8217; designates tasks in different namespace. &lt;code&gt;db:migrate&lt;/code&gt; means &amp;#8216;db&amp;#8217; namespace, &amp;#8216;migrate&amp;#8217; task. Multiple tasks can be executed in one go like so: &lt;code&gt;rake db:create
schema:load&lt;/code&gt;. They will be executed in the order they are listed. Rake was originally designed to be like make, but is often used to execute arbitrary code outside an application context. A cron job is a perfect example.&lt;/p&gt;

&lt;h2 id='rjs_ruby_javascript'&gt;RJS (Ruby JavaScript)&lt;/h2&gt;

&lt;p&gt;RJS is an abomination. Don&amp;#8217;t use it. RJS uses ruby helpers to generate JavaScript to dump into HTML attributes violating UJS.&lt;/p&gt;

&lt;h2 id='rspec'&gt;RSpec&lt;/h2&gt;

&lt;p&gt;Rspec is a unit testing framework. It is based around the idea that test should describe behavior of classes in an english like way. Test files are called &amp;#8220;specs&amp;#8221;. Spec files are divided into &amp;#8220;examples.&amp;#8221; Examples contain matchers. Spec files can share examples. Here is an example spec_file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;require &amp;#39;spec_helper&amp;#39;

describe Post do
  it { should have_many(:comments) }

  describe &amp;quot;Post#out_dated?&amp;quot; do
    subject { Post.new :created_at =&amp;gt; 2.months.ago }

    it { should be_outdated }
  end
end&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='rvm'&gt;RVM&lt;/h2&gt;

&lt;p&gt;Rvm stands for Ruby Version Manager. It is a set of bash script designed to allow you switch out Ruby interpreters on the fly. It manages installed ruby interpreters and makes is very easy to install different implementations. It also manages Gemsets. Gemsets are groups of gemsets that are distinct from other groups (except the global gemset which shares gems between different ruby interpreters).&lt;/p&gt;

&lt;h2 id='sass__scss'&gt;SASS &amp;amp; SCSS&lt;/h2&gt;

&lt;p&gt;SASS and SCSS are CSS abstraction languages. They are compiled down to CSS. They allow you use variables, modules and include other files. In short, they make it much easier to write and main large amounts of CSS.&lt;/p&gt;

&lt;h2 id='selenium'&gt;Selenium&lt;/h2&gt;

&lt;p&gt;Selenium is a library that simulates user interaction with a browser. It runs the full browser. Selenium works best in FireFox, but can work in Chrome and other browsers. Commands are sent across as JavaScript which the browser evaluates to complete each action. Selenium is the most complete solution for simulating a user for your web application.&lt;/p&gt;

&lt;h2 id='test_driven_development_tdd'&gt;Test Driven Development (TDD)&lt;/h2&gt;

&lt;p&gt;The practice of writing a failing test first then completing the implementation. This makes the developer spend more time thinking about the code upfront while providing a solid test suite for the entire application. You can use Test::Unit for TDD in Ruby.&lt;/p&gt;

&lt;h2 id='testunit'&gt;Test::Unit&lt;/h2&gt;

&lt;p&gt;Test::Unit is a unit test framework built into Ruby 1.8. It is known as MiniTest in 1.9. It provides functionality for writing test cases with standard setup and tear down. Rails generates test files built in Test::Unit by default. It provides basic assertions. It&amp;#8217;s similar to jUnit or any member of the xUnit family. Here is an example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;require &amp;#39;test_helper&amp;#39;

class PostTest &amp;lt; Test::Unit::TestCase 

  def test_out_dated? do
    post = Post.new :created_at =&amp;gt; 2.months.ago
    assertTrue(post.out_dated?)
  end
end&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='ujs_unobstrusive_javascript'&gt;UJS (Unobstrusive JavaScript)&lt;/h2&gt;

&lt;p&gt;Unobtrusive JavaScript means separating JavaScript from the HTML. Specifying an &lt;code&gt;onClick&lt;/code&gt; attribute in HTML is consider obtrusive because it obfuscates the markup. It is also hard to maintain because your javascript is harder to maintain. You can do the same thing unobtrusively by using jQuery to find the element by a class name and applying a click handler. Essentially UJS means keep JavaScript in .js files and HTML in .html files. Separation of church and state if you will.&lt;/p&gt;

&lt;h2 id='webrat'&gt;Webrat&lt;/h2&gt;

&lt;p&gt;Webrat is the original headless browser. It&amp;#8217;s similar to selenium, but much more implemented. It does not execute JavaScript and does not execute in a GUI. It is the most basic driver and is perfect for interacting with simple websites.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Sproutcore Login Tutorial</title>
      <link>http://broadcastingadam.com/2011/04/sproutcore_login_tutorial</link>
      <pubDate>Mon, 04 Apr 2011 00:00:00 +0200</pubDate>
      <author>me@broadcastingadam.com (Adam Hawkins)</author>
      <guid>http://broadcasting.com/2011/04/sproutcore_login_tutorial</guid>
      <description>&lt;p&gt;Sproutcore is probably the coolest thing I&amp;#8217;ve seen since I saw rails way back early in 2006. I think Sproutcore is the future of complex web application because it is an excellent way to create complicated (and elegant) UI&amp;#8217;s using Javascript. It uses KVO (Key-Value-Observing) to keep the UI in sync with the model. Yehdua Katz put it this way: &amp;#8220;the view always represents truth.&amp;#8221; I will not write about Sproutcore (SC from now on) because there is plenty of information to read on what it is and how it works. They have a &lt;a href='http://guides.sproutcore.com'&gt;guides site&lt;/a&gt; to learn about it. However, there is still a lot of confusion on how to implement some simple stuff in SC! I&amp;#8217;ve been dabbling with SC for a few months now&amp;#8211;and now I&amp;#8217;m finally ready to pass on some knowledge. I write SaaS applications, so the first thing I ever consider is &amp;#8220;the user has to login.&amp;#8221; That was my first hurdle with SC. I had to solve this problem: &amp;#8220;How can I create a login form with sproutcore and authenticate against a database of users?&amp;#8221; Well in order to solve this problem we need to do a few things:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Create an SC application with a form for username/password&lt;/li&gt;

&lt;li&gt;Figure out how to submit that form&lt;/li&gt;

&lt;li&gt;Create an HTTP API to determine if the form is valid&lt;/li&gt;

&lt;li&gt;Return some information to SC&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We&amp;#8217;ll start out by creating a basic interface. We&amp;#8217;ll have two pages. When the user goes to our application they&amp;#8217;ll see the login form. If they login correcly, we&amp;#8217;ll show them a different view.&lt;/p&gt;

&lt;p&gt;We need some way to get the data from the form to pass it off for processing. SC.ObjectController will do this for us. SC.ObjectController is a proxy to some underling object. However, we never bind directly to the object, instead we bind to the controller. That way when some information changes in the controller (and thusly the underlying object) the various things bound to it will change. This is where KVO comes into play.&lt;/p&gt;

&lt;p&gt;We also need something to process the data in the form. The processing code works along these lines:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Send a HTTP request to the server&lt;/li&gt;

&lt;li&gt;Tell the UI to update according to the HTTP response&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We&amp;#8217;ll use a state chart framework to transition the application from a logged out state to the logged in state. State charts are good way to model applications. I suggest you google them to learn more about them. Our simple application will only have 2 states: logged in/out.&lt;/p&gt;

&lt;p&gt;Once we have the SC application working correclty with some mock login info, we&amp;#8217;ll hook up a simple web service written with Sinatra.&lt;/p&gt;

&lt;h2 id='creating_the_sproutcore_application'&gt;Creating the Sproutcore Application&lt;/h2&gt;

&lt;p&gt;Sproutcore comes with some generators (similar to Rails). It has a generator to create a basic application. &lt;strong&gt;I am using Sproutcore 1.5RC1 for this.&lt;/strong&gt; Ensure the proper version is installed. You can install the gem and generate a new application like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ # enter a fresh directory
$ rvm use 1.9.2@sproutcore-login-tutorial # if you want to use rvm
$ gem install sproutcore --pre
$ sc-init login_tutorial&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you can start the server and see a hello world page&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sc-server
# head over to localhost:4020 and choose &amp;#39;login_tutorial&amp;#39;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img alt='Welcome' src='/images/posts/sproutcore_login_tutorial/welcome.png' /&gt;&lt;/p&gt;

&lt;h2 id='creating_the_login_page'&gt;Creating the Login Page&lt;/h2&gt;

&lt;p&gt;Take a peek at &lt;code&gt;apps/login_tutorial/main_page.js&lt;/code&gt;. This file defines the intial view in our application. It creates a page with a label on it. Every &lt;code&gt;SC.Page&lt;/code&gt; must have a &lt;code&gt;SC.MainPane&lt;/code&gt; as the mainPane property. The mainPane contains the objects that are part of the view and displayed on the page. We&amp;#8217;ll use this code as an example to create a new page that shows our login form. We&amp;#8217;ll reserve the main page for the logged in state since it&amp;#8217;s feasible to say that 99% of time the user is logged in.&lt;/p&gt;

&lt;p&gt;Create a file named: &lt;code&gt;apps/login_tutorial/resource/login_page.js&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Here is the skeleton:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;LoginTutorial.loginPage = SC.Page.design({
    mainPane: SC.MainPane.design({
    })
}); &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Inside the mainPane there will be view with 2 text feilds and a button to submit the form. Here is the scaffold code you can use to create the view:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;LoginTutorial.loginPage = SC.Page.design({
  mainPane: SC.MainPane.design({
    childViews: &amp;#39;form&amp;#39;.w(),

    form: SC.View.design({
      layout: { width: 200, height: 160, centerX: 0, centerY: 0 },
      childViews: &amp;#39;header userName password loginButton&amp;#39;.w(),

      header: SC.LabelView.design({
        layout: { width: 200, height: 24, top: 0, centerX: 0 },
        controlSize: SC.LARGE_CONTROL_SIZE,
        value: &amp;#39;Login Required&amp;#39;,
        textAlign: SC.ALIGN_CENTER
      }),

      userName: SC.TextFieldView.design({
        layout: { width: 150, height: 30, top: 30, centerX: 0},
        hint: &amp;#39;Username&amp;#39;
      }),

      password: SC.TextFieldView.design({
        layout: {  width: 150, height: 30, top: 80, centerX: 0 },
        hint: &amp;#39;Password&amp;#39;,
        isPassword: YES
      }),

      loginButton: SC.ButtonView.design({
        layout: { width: 100, height: 30, top: 120, centerX: 0 },
        conrolSize: SC.HUGE_CONTROL_SIZE,
        title: &amp;#39;Login&amp;#39;
      })
    })
  })
});&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We still have to connect the controller to the data and setup the state chart. Let&amp;#8217;s do that next.&lt;/p&gt;

&lt;h2 id='configuring_the_state_chart'&gt;Configuring the State Chart&lt;/h2&gt;

&lt;p&gt;Firs, update the &lt;code&gt;Buildfile&lt;/code&gt; in the root directory to require the state chart framework. Change the only line in the file to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;config :all, :required =&amp;gt; [:sproutcore, &amp;#39;sproutcore/statechart&amp;#39;]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now create a file named: &lt;code&gt;apps/login_tutorial/core_states.js&lt;/code&gt;. This file defines the state chart. It will have 2 states: loggedIn and loggedOut. When we enter the logged out state, the login form will be displayed. The form will be removed when we leave the state. The main page will be displayed when we enter the logged in state. Here is the code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;LoginTutorial.statechart = SC.Statechart.create({
  rootState: SC.State.design({
    initialSubstate: &amp;#39;loggedOut&amp;#39;,

    loggedOut: SC.State.design({
      enterState: function() {
        LoginTutorial.getPath(&amp;#39;loginPage.mainPane&amp;#39;).append();
      },

      exitState: function() {
        LoginTutorial.getPath(&amp;#39;loginPage.mainPane&amp;#39;).remove();
      }
    }),

    loggedIn: SC.State.design({
      enterState: function() {
        LoginTutorial.getPath(&amp;#39;mainPage.mainPane&amp;#39;).append();
      }
    })
  })
});&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The state chart is in charge of handling the flow of the application. It needs to be started when the user goes to the page. Open up &lt;code&gt;apps/login_tutorial/main.js&lt;/code&gt; and replace the content of the &lt;code&gt;main&lt;/code&gt; function with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;LoginTutorial.main = function main() {

  LoginTutorial.statechart.initStatechart();

} ;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, reboot the server and head back to the application. You should see a shiny login form.&lt;/p&gt;

&lt;p&gt;&lt;img alt='Login Form' src='/images/posts/sproutcore_login_tutorial/login_form.png' /&gt;&lt;/p&gt;

&lt;h2 id='binding_with_a_controller'&gt;Binding with a Controller&lt;/h2&gt;

&lt;p&gt;Now we need to create a controller. A controller manages data for us. We&amp;#8217;ll create a controller with two properties and bind them to the values in the login form. First generate a controller:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sc-gen controller LoginTutorial.loginController&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now create two attributes for the controller like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;LoginTutorial.loginController = SC.ObjectController.create(
/** @scope LoginTutorial.loginController.prototype */ {

  userName: null,
  password: null

}) ;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we need to bind the controller to the inputs. We&amp;#8217;ll set the &lt;code&gt;valueBinding&lt;/code&gt; property on the text fields to the correct value on the controller. Then whenever the user types something in the form, the controller&amp;#8217;s attributes will update. We&amp;#8217;ll use the controller to get the data to actually login soon. Here is the code to bind the text fields to the controller:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;userName: SC.TextFieldView.design({
  layout: { width: 150, height: 30, top: 30, centerX: 0},
  hint: &amp;#39;Username&amp;#39;,
  valueBinding: &amp;#39;LoginTutorial.loginController.userName&amp;#39;
}),

password: SC.TextFieldView.design({
  layout: {  width: 150, height: 30, top: 80, centerX: 0 },
  hint: &amp;#39;Password&amp;#39;,
  isPassword: YES,
  valueBinding: &amp;#39;LoginTutorial.loginController.password&amp;#39;
}),&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Reload the page and now you can type stuff into the fields. Then you can check controller properties in the console. So for example, if you type &amp;#8216;Adman65&amp;#8217; into the user name field you could evaluate this in the console:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; LoginTutorial.loginController.userName
&amp;quot;Adman65&amp;quot;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Conversely, you could also set the value of userName in the controller and it would update the UI:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;LoginTutorial.loginController.set(&amp;#39;userName&amp;#39;, &amp;#39;rpm&amp;#39;)&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='making_the_form_do_something'&gt;Making the Form Do Something&lt;/h2&gt;

&lt;p&gt;The next step is to make the login button do something. Pressing the button fires an event. We can configure the button to call a method on a responder. A responder is an object that knows how to handle the action. We can set the responder property on a view so all actions are processed by the same object. Our statechart is the responder for this example. Here is the strategy:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Tell the view that state chart will handle events fired from it&lt;/li&gt;

&lt;li&gt;Tell the button to call a method on the responder&lt;/li&gt;

&lt;li&gt;Add a method to handle the action&lt;/li&gt;

&lt;li&gt;Use that action to authenticate using the credentials&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Set the responder like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;LoginTutorial.loginPage = SC.Page.design({
  mainPane: SC.MainPane.design({
    defaultResponder: &amp;#39;LoginTutorial.statechart&amp;#39;,

    //...
  })
})&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Update the button view like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;loginButton: SC.ButtonView.design({
    layout: { width: 100, height: 30, top: 120, centerX: 0 },
    conrolSize: SC.HUGE_CONTROL_SIZE,
    title: &amp;#39;Login&amp;#39;,
    action: &amp;#39;authenticate&amp;#39;
  })&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now add a method in the state chart to handle the action&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;LoginTutorial.statechart = SC.Statechart.create({
  rootState: SC.State.design({
    initialSubstate: &amp;#39;loggedOut&amp;#39;,

    loggedOut: SC.State.design({
      enterState: function() {
        LoginTutorial.getPath(&amp;#39;loginPage.mainPane&amp;#39;).append();
      },

      exitState: function() {
        LoginTutorial.getPath(&amp;#39;loginPage.mainPane&amp;#39;).remove();
      },

      authenticate: function() {
        // we&amp;#39;ll fill this in later
        // you can call alert(&amp;#39;weeeeee&amp;#39;) to test it&amp;#39;s working if you 
        // don&amp;#39;t trust me :D
      }
    }),

    loggedIn: SC.State.design({
      enterState: function() {
        LoginTutorial.getPath(&amp;#39;mainPage.mainPane&amp;#39;).append();
      }
    })
  })
});&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='mock_authentication'&gt;Mock Authentication&lt;/h2&gt;

&lt;p&gt;At this point we can check the credentials in the authenticate method we just added. For now we&amp;#8217;ll just check to see if the user has filled in both things, then move to logged in state. We&amp;#8217;ll show an error if either value is missing. Once the UI working, we&amp;#8217;ll use a simple web service to authenticate.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;authenticate: function() {
    var userName = LoginTutorial.getPath(&amp;#39;loginController.userName&amp;#39;);
    var password = LoginTutorial.getPath(&amp;#39;loginController.password&amp;#39;);

    if(!SC.empty(userName) &amp;amp;&amp;amp; !SC.empty(password)) {
      this.gotoState(&amp;#39;loggedIn&amp;#39;);
    } else {
      SC.AlertPane.error(&amp;quot;Login information incorrect!&amp;quot;);
    }
  }&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, when you fill in both fields and press login, then you should see the original welcome message. Otherwise, you get a popup error message.&lt;/p&gt;

&lt;p&gt;&lt;img alt='Error Message' src='/images/posts/sproutcore_login_tutorial/error.png' /&gt;&lt;/p&gt;

&lt;h2 id='connecting_to_the_web'&gt;Connecting to the Web&lt;/h2&gt;

&lt;p&gt;Now we&amp;#8217;ll create a simple sinatra site that accepts a post and does the same basic checking. Here is &lt;code&gt;webservice.rb&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;require &amp;#39;rubygems&amp;#39;
require &amp;#39;sinatra&amp;#39; # make sure you install this gem
require &amp;#39;json&amp;#39; # make sure you install this gem

post &amp;#39;/login&amp;#39; do
  data = JSON.parse request.body.read

  if data[&amp;#39;user_name&amp;#39;] &amp;amp;&amp;amp; data[&amp;#39;password&amp;#39;]
    200
  else
    412
  end
end&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sproutcore sends parameters as JSON encoded strings. We need to decode the JSON to get the parameters. Now you can run the file like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ruby webservice.rb&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have to update the authenticate method to post data to the server:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;loggedOut: SC.State.design({
  enterState: function() {
    LoginTutorial.getPath(&amp;#39;loginPage.mainPane&amp;#39;).append();
  },

  exitState: function() {
    LoginTutorial.getPath(&amp;#39;loginPage.mainPane&amp;#39;).remove();
  },

  authenticate: function() {
    var userName = LoginTutorial.getPath(&amp;#39;loginController.userName&amp;#39;);
    var password = LoginTutorial.getPath(&amp;#39;loginController.password&amp;#39;);

    SC.Request.postUrl(&amp;#39;/login&amp;#39;, {user_name: userName, password: password}).
      notify(this, &amp;#39;didCompleteAuthentication&amp;#39;).json().send();
  },

  didCompleteAuthentication: function(response){
    if(SC.ok(response)) {
       this.gotoState(&amp;#39;loggedIn&amp;#39;);
     } else {
       SC.AlertPane.error(&amp;quot;Login information incorrect!&amp;quot;);
     } 
  }
}),&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We use &lt;code&gt;SC.Request&lt;/code&gt; to create a HTTP POST ajax call. The second argument is the body. Calling .json() will encode the body argument when sending the request. notify() adds a callback to handle the response. Finally, send() actually sends the request. The first argument to the callback is always the response. We check to see if it&amp;#8217;s ok then go to logged in state, else show an error message.&lt;/p&gt;

&lt;p&gt;Finally, we have to update the build file to proxy &amp;#8216;/login&amp;#8217; to sinatra. Add this line to your &lt;code&gt;Buildfile&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;proxy &amp;#39;/login&amp;#39;, :to =&amp;gt; &amp;#39;localhost:4567&amp;#39;&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='wrapping_up'&gt;Wrapping Up&lt;/h2&gt;

&lt;p&gt;I moved through this example pretty fast since it&amp;#8217;s very basic. It is intended to give you a rough overview of how you can string together a controller, view, state chart, an web service to authenticate users and update the UI accordingly. Here is some further reading:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href='http://github.com/Adman65/sproutcore-login-tutorial'&gt;Source&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='http://blog.nextfinity.net/loginlogout-example-app-pt-1/'&gt;More detailed login tutorial&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='http://wiki.sproutcore.com/w/page/12412900/Foundation-Ajax%20Requests'&gt;SC.Request&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='http://frozencanuck.wordpress.com/2010/11/15/ki-now-the-official-statechart-framework-for-sproutcore/'&gt;More about statecharts in SC&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='http://guides.sproutcore.com'&gt;Sproutcore Guides&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='http://www.sinatrarb.com/intro.html'&gt;More about Sinatra&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>The Ruby Gem Challenge</title>
      <link>http://broadcastingadam.com/2011/02/the_ruby_gem_challenge</link>
      <pubDate>Sun, 20 Feb 2011 00:00:00 +0100</pubDate>
      <author>me@broadcastingadam.com (Adam Hawkins)</author>
      <guid>http://broadcasting.com/2011/02/the_ruby_gem_challenge</guid>
      <description>&lt;p&gt;I am working on a gem ranking website. One of the metrics is test results. Getting test result for a random project can be a very difficult task. I&amp;#8217;ve cloned 3,081 different gems onto my computer. I&amp;#8217;ve written a simple bash script to execute this loop:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for repo in ~/repos/* ; do
  cd ${repo}
  rvm use 1.8.7@${repo}
  bundle
  rake
done&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nothing fancy going on there. However, &lt;strong&gt;the results are appalling.&lt;/strong&gt; Very few gems work out of the box on a clean machine. I think this a huge failure for gem developers. If you don&amp;#8217;t have a rake task that can execute tests in a clean environment then you have a problem! I thought to myself, surely this cannot be the case. I tested well known gems like devise. No dice. I tested cancan. That didn&amp;#8217;t work as well. I tried to test some of gem&amp;#8217;s I&amp;#8217;ve used. Not much luck there. I have the script running in a console right now. AASM just worked with 100% passing. I&amp;#8217;ve tweeted some gems that work as well. Mail and HTTParty worked out of the box. HTTParty even had cucumber features passing! I think the gem authors (myself included) should rise to the occasion and make it easier for other people to test our gems! I think this would speak very highly of the ruby community. Everyone should try the Ruby Gem challenge out on their favorite gem:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Clone repo into fresh directory&lt;/li&gt;

&lt;li&gt;Create empty gemset and bundle&lt;/li&gt;

&lt;li&gt;Bundle (If the gem does not use bunder, fail right there)&lt;/li&gt;

&lt;li&gt;Execute &lt;code&gt;rake&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;Report results&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;After running this test through many many gems, I have a new found respect for the authors of the gems that passed my tests. Try it out and let me and the authors know your results! Tweet me at @Adman65 and tweet the authors know too! They should get on that :D&lt;/p&gt;

&lt;p&gt;PS. It will also be nearly impossible to get above an 80% ranking on whatgem when I implement this scheme. That will &lt;strong&gt;really&lt;/strong&gt; sort out the good from the bad.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Why I Love Volume 1: Sprockets</title>
      <link>http://broadcastingadam.com/2011/02/why_i_love_volume_1_sprockets</link>
      <pubDate>Fri, 11 Feb 2011 00:00:00 +0100</pubDate>
      <author>me@broadcastingadam.com (Adam Hawkins)</author>
      <guid>http://broadcasting.com/2011/02/why_i_love_volume_1_sprockets</guid>
      <description>&lt;p&gt;&lt;a href='http://getsprockets.org/'&gt;Sprockets&lt;/a&gt; is one of the most handy gems I&amp;#8217;ve ever used. It allows you separate javascript into multiple files and use &lt;code&gt;require&lt;/code&gt; keywords. This was a god send for me. The application I&amp;#8217;m working has a TON of js. I was able to tame it with sprockets. I also came up with a nice directory structure a long the way.&lt;/p&gt;

&lt;h2 id='the_problem'&gt;The Problem&lt;/h2&gt;

&lt;p&gt;It all starts with application.js. You have one file. The documentation says dump your javascript into this file&amp;#8211;hell, put &lt;strong&gt;all&lt;/strong&gt; your js into this file. So you start writing a few ajax calls and various trickery. 20 lines. Then 50 lines. Then 100 lines. Then 500 lines. Then maybe a couple thousand. Wait&amp;#8230;.a couple thousand? How did we get here? A couple thousand for what? What page is this JS for? How do i &lt;em&gt;find&lt;/em&gt; what javascript I&amp;#8217;m looking for? Hmmm. What about my jquery plugins? /public is starting to get pretty packed. Now lets say you&amp;#8217;ve got 25 different pages. Each page needs their own JS to accomplish certain tasks. At this point, is it smart to keep dumping things into the same file? I say no. It&amp;#8217;s time to get things whipped into shape. There&amp;#8217;s one thing I really like about Rails: &lt;strong&gt;convention over configuration.&lt;/strong&gt; The views folder is setup pretty nicely. There is a folder that corresponds to the controller that renders the view, and a file for the view name. It would be nice to have this same structure for our javascript. When your JS starts to become rather large, you&amp;#8217;ll have some common code that is shared. This stuff belongs in an application.js file. So how can we keep all this code organized? Sprockets.&lt;/p&gt;

&lt;h2 id='hail_the_conquering_hero'&gt;Hail the Conquering Hero&lt;/h2&gt;

&lt;p&gt;Sprockets is a Ruby library that preprocesses and concatenates JavaScript source files. It takes any number of source files and preprocesses them line-by-line in order to build a single concatenation. Specially formatted lines act as directives to the Sprockets preprocessor, telling it to require the contents of another file or library first or to provide a set of asset files (such as images or stylesheets) to the document root. Sprockets attempts to fulfill required dependencies by searching a set of directories called the load path.&lt;/p&gt;

&lt;p&gt;Perfect. It can even combine all our js into one single file. We can even minmize that later if we choose too. This means we can setup this type of directory structure:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/app
  /javascripts
    /pages
      dashboard.js
      settings.js
    /shared
      utility.js
    application.js&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;! That is pretty handy if you ask me. It becomes very odvious how the JS is organized. It also makes it very easy to add isolated bits of javascript for specific pages/widgets/etc. You can also add other directories to the load path. This means you can create a /vendor directory for your javascript. I love this because I can keep my downloaded jquery plugins in /vendor with git submodules for easy updating. So you could create this sort of structure for your application:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/app
  /javascripts
    /so_on_and_so_forth
/vendor
  /javascripts
    jquery.js
    jquery-ui.js
    jquery.plugin1.js
    jquery.plugin2.js&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nice. You can also require other files as you would in ruby. For example, say you&amp;#8217;re in application.js and you want to ensure that some other javascript (like jquery) is loaded before this code is ran.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//=require &amp;lt;jquery&amp;gt;

// jquery dependent stuff here&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Another example, say you&amp;#8217;re writing some JS for the dashboard and you need to the utilities methods.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//= require &amp;#39;../shared/utilities&amp;#39;

MyApp.utilities.flashNotice(&amp;#39;oh hai&amp;#39;);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A require statement tells Sprockets to insert the content of the required file before processing the rest of the document. I like this because it makes it very explicit what JS is needed. It also prevents those wonderful undefined method xxx for null errors. A require with &lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt; tells sprockets to search the load path. A require without means it is a relative path name.&lt;/p&gt;

&lt;h2 id='how_i_integrated_sprockets'&gt;How I Integrated Sprockets&lt;/h2&gt;

&lt;p&gt;I took a similar approach to what I outlined earlier. I wanted a javascript file for each separate page of the application and a some shared folder where shared code lived. Then I wanted a way to easily initialize the pages. Each page would live in it&amp;#8217;s own specific object, so there would be no collisions. Here is the directory structure I came up with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/app
  /javascripts
    /pages
      dashboard.js
      settings.js
    /components
      widget1.js
      widget2.js
    /shared
      utilities.js
    application.js
    jquery.js
/vendor
  /sprockets
    /jquery
      /src
        jquery-1.4.4.js
        jquery-ui.js
        jquery.plugin1.js
        jquery.plugin2.js&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;My application has many shared widgets. I called them components because they can be reused in any context in many different places. Sometimes the JS for these things can be quite long, so I wanted a specific file for each one so I knew where to look when something went wrong. The default configuration for sprocket-rails has &lt;code&gt;/vendor/sprockets/*src&lt;/code&gt; on the load path. I didn&amp;#8217;t feel like changing it, and this way it lets me group similar files. Sprockets will always process application.js first. I use this to set the stage by requiring all different JS my application needs.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// application.js

//=require &amp;#39;jquery&amp;#39;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;jquery.js is a file simple loads all the stuff in /vendor:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// jquery.js

//=require &amp;lt;jquery.1.4.4.&amp;gt;
//=require &amp;lt;jquery-ui&amp;gt;
//=require &amp;lt;jquery.plugin1&amp;gt;
//=require &amp;lt;jquery.plugin2&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;#8217;s what one of the page file looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//= require &amp;#39;../components/widget1.js&amp;#39;
//= require &amp;#39;../components/widget2.js&amp;#39;

var DashboardPage = {
  init: function() {
      // do stuff, this is called when the page is loaded
  },
  // protip, use an ajax callback for the page automagically
  ajaxComplete: function() { }
};&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I added a helper to initialize the page and attach the current page. It generates javascript like along these lines and embeds it into the page:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(function(){
  #{page_name.titleize}Page.init();
  $(&amp;#39;body&amp;#39;).ajaxComplete(#{page_name.titleize}Page.ajaxComplete);
});&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then in the view (/app/views/dashboards/show):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;% initialize_page &amp;#39;dashboard&amp;#39; %&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='how_it_worked_out'&gt;How it Worked Out&lt;/h2&gt;

&lt;p&gt;This was the best changed I&amp;#8217;ve ever made to this application. Before the JS was spread out into random files and it was a pain in the ass to track down &lt;em&gt;how&lt;/em&gt; it got included and &lt;em&gt;where&lt;/em&gt; it was. Now this way I know there is /app/javascripts/pages/page_name.js file and by the time that code is executed, all the required code is added. It&amp;#8217;s also been very easy to add new plugins. Drop the jquery plugin into /vendor and update the jquery.js in /app/javascripts. Boom. Available everywhere. It is also concatenated into one large file so instead of 20 or so (yes I know this is bad) requests we now only have &lt;strong&gt;1&lt;/strong&gt;. This made a big difference in the load time. If you haven&amp;#8217;t used sprockets, I highly suggest you check it out&amp;#8211;especially if you have a js centric application.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;tl;dr&lt;/strong&gt;: Sprockets is a cool gem to organize and manage js your own way. It also concatenates all js files into one single file. This makes your page load faster. Use sprockets for inceased sanity.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Ubuntu, Jetty, Solr &amp; MultiCore</title>
      <link>http://broadcastingadam.com/2011/02/ubuntu_jetty_solr_and_multicore</link>
      <pubDate>Wed, 02 Feb 2011 00:00:00 +0100</pubDate>
      <author>me@broadcastingadam.com (Adam Hawkins)</author>
      <guid>http://broadcasting.com/2011/02/ubuntu_jetty_solr_and_multicore</guid>
      <description>&lt;p&gt;&lt;a href='http://lucene.apache.org/solr/'&gt;Solr&lt;/a&gt; is a wonderful fulltext search program. It can be configured to do a great many things. It can also be a royal pain to setup. Solr is written in Java. In order to use solr in your application you must configure a java application somewhere to serve up Solr. Solr runs as an web service. You index docouments by posting XML to the server for indexing. You can install a java application server like Tomcat or Jetty to host Solr. By default, Solr can only index one set of data. This means, if you need to host multiple applications on the same solr server, then you have a few options. You can create new Solr instances for each application, or you can use Solr&amp;#8217;s MultiCore functionality to index different datasets. MultiCore is like creating another database for Postgres. I&amp;#8217;ll show you how to get this up and running under Ubuntu.&lt;/p&gt;

&lt;h2 id='installing_jetty_java_and_solr'&gt;Installing Jetty, Java and Solr.&lt;/h2&gt;

&lt;p&gt;This is one of the reasons I love ubuntu server. It just has packages. I don&amp;#8217;t have to worry about downloading code from random place, it just has everything a boy could need in a server. Install these packages using apt:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install solr-jetty openjdk-6-jdk&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This pulls in ~60MB and a ton of packages so watch out for that :D&lt;/p&gt;

&lt;p&gt;The next thing we want to do is setup Jetty to listen on all connections. By default the installation is only available on htt://localhost:8080. That&amp;#8217;s great if you&amp;#8217;re making a local server, but we need to open our box up to the world. Ubuntu uses a file &lt;code&gt;/etc/defaults/jetty&lt;/code&gt; to manage daemon settings. Open this file in vim and replace this line:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#JETTY_HOST=$(uname -n)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;JETTY_HOST=&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will tell jetty to listen on all connections. You can also put in your own ip or domain name if you please. Feel free to change the port as well at this point.&lt;/p&gt;

&lt;p&gt;Now navigate to the top of the file and &lt;code&gt;/NO_START&lt;/code&gt; to go to the next setting we need to change. Replace the 1 with a 0 and wer&amp;#8217;re in business. This will tell jetty to start when the server is loaded.&lt;/p&gt;

&lt;p&gt;Now fire the server up with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/etc/init.d/jetty start&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once all is good you should be able to navigate to &lt;a href='http://yourhost.com:8080'&gt;http://yourhost.com:8080&lt;/a&gt; and get welcome page. This is basically a &amp;#8220;it works page&amp;#8221;. Now you can move on to solr. Ubuntu already did a lot of extra work for you by installing a runnable version of solr into Jetty. You can access that at &lt;a href='http://yourhost.com:8080/solr'&gt;http://yourhost.com:8080&lt;/a&gt;. It is a very basic admin&amp;#8211;but it&amp;#8217;s something. Now we&amp;#8217;re ready for MulitCore.&lt;/p&gt;

&lt;h2 id='multi_core'&gt;Multi Core&lt;/h2&gt;

&lt;p&gt;MultiCore is was the most complicated part for me to get setup, partially because everything I read conflicted with something&amp;#8211;but don&amp;#8217;t worry. It should be easy for you if you follow along. You can read the offical wiki page &lt;a href='here'&gt;http://wiki.apache.org/solr/CoreAdmin&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Here&amp;#8217;s what they don&amp;#8217;t tell you, or assume you should know:&lt;/strong&gt; In order for MultiCore to work, each core must have it&amp;#8217;s own solrconfig.xml and schema.xml. That&amp;#8217;s fantastic, but excuse me, where the hell do I put these files? That was my life for 3 hours. Mucking around with random configurations until POOF. \o/ It all worked.&lt;/p&gt;

&lt;p&gt;You also have to create a &lt;code&gt;solr.xml&lt;/code&gt; file separate from all the other config files that tells Solr to load multicore. This was outlined reasonably well in the documentation, but it still gave me headaches.&lt;/p&gt;

&lt;h3 id='step_1_solrxml'&gt;Step 1. Solr.xml&lt;/h3&gt;

&lt;p&gt;We need to create a file that tells Solr to load our cores. You can decided ahead of time what they are, or just use this as a template for now. Below is a template you can follow. You can create as many cores as you want. When Editing the file, be sure to replace all copies of &amp;#8220;production&amp;#8221; with whatever the name of your core is. In my setup, I needed 3 different cores. One for production code, one for staging code, and one for a beta code. Once you&amp;#8217;ve created this file, save it as: &lt;strong&gt;/usr/share/solr/solr.xml&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;solr persistent=&amp;quot;true&amp;quot;&amp;gt;
 &amp;lt;cores adminPath=&amp;quot;/admin/cores&amp;quot;&amp;gt;
   &amp;lt;core name=&amp;quot;production&amp;quot; instanceDir=&amp;quot;production&amp;quot; dataDir=&amp;quot;/var/lib/solr/production/data&amp;quot; /&amp;gt;
   &amp;lt;core name=&amp;quot;staging&amp;quot; instanceDir=&amp;quot;staging&amp;quot; dataDir=&amp;quot;/var/lib/solr/staging/data&amp;quot; /&amp;gt;
   &amp;lt;core name=&amp;quot;beta&amp;quot; instanceDir=&amp;quot;beta&amp;quot; dataDir=&amp;quot;/var/lib/solr/beta/data&amp;quot; /&amp;gt;
 &amp;lt;/cores&amp;gt;
&amp;lt;/solr&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Don&amp;#8217;t forget to set the dataDirectory attribute as well!&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id='step_2_making_data_directories'&gt;Step 2. Making Data Directories&lt;/h3&gt;

&lt;p&gt;Now we must create directories for our index data to live. They were specified earlier in the step 1. These directories must be writable by the jetty user. Apt automatically added this user for you when you installed jetty-solr. You can create them with this command.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo mkdir -p /var/lib/solr/production/data&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Repeat this command for however many cores you need. Next make jetty the owner.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo chown -R jetty /var/lib/solr/&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='step_3_copying_the_config_files'&gt;Step 3. Copying the Config Files&lt;/h3&gt;

&lt;p&gt;This was the hidden step. First thing we need to do is create directories for our cores to live. Each core has it&amp;#8217;s own schema and config files. These need to be created. It&amp;#8217;s just like we did in step 2, but with a different directory.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo mkdir /usr/share/solr/production&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we need to create the configuration files. I&amp;#8217;ve posted them in gists. These files are templates and just enough to get the server started. It is up to you to do the customization!&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href='https://gist.github.com/816101'&gt;solrconfig.xml&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='https://gist.github.com/816103'&gt;schema.xml&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Download those files or keep them open. Now create a conf directory inside the directory you&amp;#8217;ve already created&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo mkdir /usr/share/solr/production/conf&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now enter the directory and paste those files.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd /usr/share/solr/production/conf
# paste solrconfig.xml into your editor and save it
# paste schema.xml into your editor and save it&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now at this point, you can simply copy this directory for the other stages. This is especially helpful if you have 5 stages. You can duplicate the config like so&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo cp -R /usr/share/solr/production /usr/share/solr/new_name1
sudo cp -R /usr/share/solr/production /usr/share/solr/new_name2
# and so on&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you are ready to restart the server&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo /etc/init.d/jetty stop
sudo /etc/init.d/jetty start&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now head back over to &lt;a href='http://yourhost.com:8080/solr/admin'&gt;http://yourhost.com:8080/solr/admin&lt;/a&gt; And you should see links to all your cores!&lt;/p&gt;

&lt;h3 id='step_4_customization'&gt;Step 4. Customization&lt;/h3&gt;

&lt;p&gt;Depending your needs you may have different schemas and configurations for each core. You should configure them now. If you need to use the same configuration to each core, you should symlink the main solrconfig.xml to the various stages. For example, you should have the production and staging cores running the same config.&lt;/p&gt;

&lt;p&gt;Feel free to hit me up on twitter at @Adman65 with questions or problems! Hope this helped.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Cucumber's env.rb &amp; Dry Run Problems</title>
      <link>http://broadcastingadam.com/2010/12/cucumbers_dry_run_problems</link>
      <pubDate>Thu, 02 Dec 2010 00:00:00 +0100</pubDate>
      <author>me@broadcastingadam.com (Adam Hawkins)</author>
      <guid>http://broadcasting.com/2010/12/cucumbers_dry_run_problems</guid>
      <description>&lt;p&gt;Env.rb setsup Cucumber&amp;#8217;s execution environment. The generated file from cucumber-rails essentially loads your rails env and setups up Capybara etc. That&amp;#8217;s all well and good but what do you do if you need to add your own stuff. Once you&amp;#8217;ve built up a sizeable cucumber test suite, it&amp;#8217;s probable that you&amp;#8217;ve got some modifications to env.rb. However, they &lt;strong&gt;should not&lt;/strong&gt; be there since when you upgrade to a new version of cucumber (mainly cucumber-rails) it wants to regenerate that file. So what you need to do is split up your modifications into sepearate files. Here are some modifications you may have:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Modifying your Capybara driver (yay chrome)&lt;/li&gt;

&lt;li&gt;Loading blueprints&lt;/li&gt;

&lt;li&gt;Customizing specjour&lt;/li&gt;

&lt;li&gt;Settings other constants&lt;/li&gt;

&lt;li&gt;Insert random code&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;That&amp;#8217;s all well and good but it&amp;#8217;s not the correct way to do it. There are few options. You can split each modification into its own file and drop it in /features/support. Cucumber will autoload &lt;strong&gt;all&lt;/strong&gt; files in side this directory. Technically it matches all files using this glob pattern: &lt;code&gt;features/**/*.rb&lt;/code&gt;. However env.rb is loaded &lt;strong&gt;before&lt;/strong&gt; all other files in features/support. This means you can drop create a file like this for specjour into &lt;code&gt;features/support/specjour.rb&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# tell Capybara to start a server on any open port
# since specjour will start multiple workers on the same computer
# and hence Capybara will try to connect to the same port 
# locking up the test suite
if ENV[&amp;#39;TEST_ENV_NUMBER&amp;#39;]
  Capybara::Server.class_eval do
    def find_available_port
      server = TCPServer.new(&amp;#39;127.0.0.1&amp;#39;, 0)
      @port = server.addr[1]
    ensure
      server.close if server
    end
  end
end&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That fill will be loaded &lt;strong&gt;after&lt;/strong&gt; env.rb when you &lt;strong&gt;execute&lt;/strong&gt; your tests. This does create an interesting wrinkle. I use dry run mode a lot in my suite. I refactor my features and steps quite often as I get a better understanding of the domain. I use dry run mode to check to see if all the steps are defined before executing the test suite. The test suite can take over an hour. :( Cucumber does not load env.rb in dry run mode, it &lt;strong&gt;does&lt;/strong&gt; load all other files in /features/support. This creates a problem if you have files in features/support that require env.rb to be loaded. For instance the specjour example I posted requires the capybara gem to be loaded. You could add:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;require &amp;#39;capybara&amp;#39;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But it won&amp;#8217;t be able to find the gem since the gem environment is not loaded when the file is required. In dry run mode cucumber does not load files that match this regular expression: &lt;code&gt;support\/env\..*&lt;/code&gt;. Interestingly Cucumber does not simply select features/support/env.rb since that is the standard file. That means you can name files &amp;#8220;env.specjour.rb&amp;#8221; or &amp;#8220;env.capybara.rb&amp;#8221; to have them execluded in dry run mode. Although, this issue is only present when you run features using the cucumber binary. If you run features through rake then you will not have problems since the complete rails environment is loaded before cucumber is loaded.&lt;/p&gt;

&lt;p&gt;tl;dr PROTIP: put things you would&amp;#8217;ve added to env.rb in a file in /features/support/customer_modification_.rb. If you run those features with rake you&amp;#8217;ll be ok. If you run those features with the cucumber command you&amp;#8217;ll be ok. If those modifications required env.rb to be loaded and you run features with cucumber in dry run mode name them: features/support/env.modification.rb.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Lessons From a Startup</title>
      <link>http://broadcastingadam.com/2010/10/lessons_from_a_startup</link>
      <pubDate>Sun, 31 Oct 2010 00:00:00 +0200</pubDate>
      <author>me@broadcastingadam.com (Adam Hawkins)</author>
      <guid>http://broadcasting.com/2010/10/lessons_from_a_startup</guid>
      <description>&lt;p&gt;Ive been working as the lead developer at Finnish start up for about 9 months now. Were making a cool product that weve got high hopes for. Were getting our first customers now, so Im taking some time to reflect on our progress and what Ive learned.&lt;/p&gt;

&lt;h2 id='1_dont_release_unfinished_code'&gt;1. Don&amp;#8217;t Release Unfinished Code&lt;/h2&gt;

&lt;p&gt;This seems like a no brainer, but sometimes the excitement about a new feature gets the best of you and you push it out before youve had adequate time to to test it. Im not talking about just integration testing, but letting some test users play with and make sure its working to their requirements and not yours. Last month we had a major feature released, it had already been delayed due to bug fixes. We held off and kept working on it. When we did release the feature it turned out that it still wasnt done and we had to go shock and awe on the bug list. Its better to be late and correct, then early and look like a noob. We learned that lesson.&lt;/p&gt;

&lt;h2 id='2_dont_trust_third_parties'&gt;2. Don&amp;#8217;t Trust Third Parties&lt;/h2&gt;

&lt;p&gt;Our product integrates pretty heavily with various third party products. At one point we were working with four third parties to provide crucial parts of our product. Their services seemed useful, but we ran into problems when it came into crunch time. Our problem was that our release dates where not inline with their time. For example, we were waiting a month for one company to provide some information/API stuff for us. We wanted to roll out the feature in two weeks, but as time went on, we had to cut the feature because the third party couldnt deliver. We are starting another third party integration. In the planning phase, we just assumed it would take twice or even three times as long as they saythis is simply because theyve got their own business too.&lt;/p&gt;

&lt;h2 id='3_have_small_goals'&gt;3. Have (small) Goals&lt;/h2&gt;

&lt;p&gt;We are big dreamers. We want our product to be the shit. We want it to be awesome. We want to be a swiss army knife made out of unicorns tears flying around with a gold cape. We also need to sell this thing and develop real features. Its been easy for us to get distracted and not focus on getting useful things done. What we need to do is focus on small features and deliverables. There are quick wins and small steps. Remember to set goals you can makeand be realistic about them! You only hurt yourself by setting unrealastic goals for yourself. Know your limits and work within in them. We learned this lesson as well.&lt;/p&gt;

&lt;h2 id='4_have_a_vision'&gt;4. Have a Vision&lt;/h2&gt;

&lt;p&gt;The vision is the over arching goal and purpose of what youre doing. Someone needs to have this, or youre just a leaf in the wind. However, dont get your vision confused with your goals! You set goals in order to meet the vision. Your goals build up to a product that fulfills the vision. Also, be realistic about your vision. If youre not making any cash, then your vision must be to make some money and set goals to make that happen.&lt;/p&gt;

&lt;h2 id='5_have_a_standard'&gt;5. Have a Standard&lt;/h2&gt;

&lt;p&gt;Weve had a few developers come and go through the course of the project. Ive been the only constant. In the beginning, it was wild west. Anyone could commit and features were happening all over the place. We recently had someone new coming a few months ago to do front end work. The front end work is slowly transitioning into backend-ish work. Thats all good if you have people that can wear multiple hats, except there has to be rules. After a while I got fed up and wrote up a standards document. It laid out what would have to be in place for ommits/features to be accepted and what kind of workflow to use. Its published in the repos readme. All current and future developers will be held to the standards laid out. Having standards should increase code quality over the projects lifetime.&lt;/p&gt;

&lt;h2 id='6_invest_in_testing'&gt;6. Invest in Testing&lt;/h2&gt;

&lt;p&gt;Test. Test. Test. Test. I love testing and you should to. Testing can save your life. Include time for testing in the release schedule. Include time for testing before production deploys. Invest developer time in creating a good test suite. Use tools like specjour to distribute your test suite. Our cucumber test suite took ~1hr. Spent some time setting up specjour, got that sucker down to ~10min. Youre integration suite should run quickly and you should run it often. If the suite takes too long to run, it will not run that often and you lose the benefits of automated testing. Invest time and keeping this process lean. It will pay you back.&lt;/p&gt;

&lt;h2 id='7_make_software_that_customers_want_and_will_pay_for'&gt;7. Make Software that Customers Want (and will pay for)&lt;/h2&gt;

&lt;p&gt;Duh. But, sometimes its easy to get distracted with stuff you think is cool. Example: you think feature A is off-chain and it should totally be in the project. Customers are lined up waiting for feature B. Feature B isnt as cool but is going to bring in some cash. Work on feature B. Make a product that will sell and bring in money. Our product is a game changer (I know you hear this every time you read about start ups). When customers see what weve got cooking they are completely befuddled, next awe struck, then really interested. The project leader and myself are way past that phase. We are no longer awe struck by what our product can dobut the customers still are! You should focus on developing features that customers want and not (all the time) developing feature for yourself.&lt;/p&gt;

&lt;h2 id='8_know_youre_gonna_make_mistakes'&gt;8. Know You&amp;#8217;re Gonna Make Mistakes&lt;/h2&gt;

&lt;p&gt;It goes without saying, but understand that youre gonna mess up. When youre working in a startup, the business plan and overall product is not set in stone. Remember to keep this mind and adapt to change.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>app/observers -- Where They Should Be</title>
      <link>http://broadcastingadam.com/2010/10/app_observers</link>
      <pubDate>Sat, 09 Oct 2010 00:00:00 +0200</pubDate>
      <author>me@broadcastingadam.com (Adam Hawkins)</author>
      <guid>http://broadcasting.com/2010/10/app_observers</guid>
      <description>&lt;p&gt;Afer you&amp;#8217;ve been doing Rails for a while you become old and cranky about how you want things. I &lt;em&gt;love&lt;/em&gt; my observers in /app/obsevers. I do not understand why they are not their by default. Models, mailers, and controllers all have their own folders, why can&amp;#8217;t observers by default. They don&amp;#8217;t even make any sense in /app/models. #1 They don&amp;#8217;t model anything and #2 They aren&amp;#8217;t subclasses of ActiveRecord (or some other ORM). If all the classes in /app/models are subclasses of AR, then what is an observer breaks the pattern. In Rails 2 if you want to specify another directory to load code from you have to specify add it to the &lt;code&gt;config.load_path&lt;/code&gt; variable. This is not the case in Rails 3. If you simply want to shove your observers into /app/observers, jsut make the directory and move the files in there. You will have to move them if you don&amp;#8217;t patch the &lt;code&gt;rails g observer&lt;/code&gt; command to generate them in a new directory. That takes care of Rails, but now that we have our observers separated, it&amp;#8217;s safe to assume we want to be able to run &lt;code&gt;rake spec:obsevers&lt;/code&gt;. This is not a problem either. All you have to do is create a rake spec task to only run files in spec/observers. So drop this bad boy in /lib/tasks&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;require &amp;#39;rspec/core&amp;#39;
require &amp;#39;rspec/core/rake_task&amp;#39;
Rake.application.instance_variable_get(&amp;#39;@tasks&amp;#39;)[&amp;#39;default&amp;#39;].prerequisites.delete(&amp;#39;test&amp;#39;)

spec_prereq = Rails.configuration.generators.options[:rails][:orm] == :active_record ?  &amp;quot;db:test:prepare&amp;quot; : :noop

namespace :spec do
  [:observers].each do |sub|
    desc &amp;quot;Run the code examples in spec/#{sub}&amp;quot;
    RSpec::Core::RakeTask.new(sub =&amp;gt; spec_prereq) do |t|
      t.pattern = &amp;quot;./spec/#{sub}/**/*_spec.rb&amp;quot;
    end
  end
end&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have our own rake task for testing our observers. But let&amp;#8217;s take it one step further and make our observer specs a first class citizen in Rspec2. You know that when you write controller specs you can call the &lt;code&gt;controller&lt;/code&gt; method or in helper specs there is a &lt;code&gt;helper&lt;/code&gt; object that represents the object under test. This magic happens because rspec contains special code that runs when initial describe block matches something like xxxController or xxxHelper. If it matches, it loads some special code to make writing specs for these classes much easier. All you have to do is take a peek into the rspec-rails &lt;a href='http://github.com/rspec/rspec-rails/tree/master/lib/rspec/rails/example/'&gt;source&lt;/a&gt; to see where the magic happens. I advice you to look at those files and figure out what&amp;#8217;s up. Creating a new observer example group is easy. Drop this bad boy in side /spec/support/observer_example_group.rb&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module RSpec::Rails
  module ObserverExampleGroup    
    extend ActiveSupport::Concern
    extend RSpec::Rails::ModuleInclusion

    include RSpec::Rails::RailsExampleGroup

    def observer
      example.example_group.describes.instance
    end

    included do
      metadata[:type] = :observer
    end

    RSpec.configure &amp;amp;include_self_when_dir_matches(&amp;#39;spec&amp;#39;,&amp;#39;observers&amp;#39;)
  end
end&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This module adds some sugar to all specs in an observer example group. If your spec is in spec/observers you can now do something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;describe AccountObserver do
  it &amp;quot;should send a welcome email&amp;quot; do
     AccountMailer.should_receive(:welcome_email).and_return(mock_mail)
     mock_mail.should_receive(:deliver)
     observer.after_create(mock_account) # notice observer is defined in the observer example group
  end
end&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nice! We no longer have to call AccountObserver.instance in all our tests or set an @observer in a before filter. This also allows us to do some more cool stuff for our observer examples. You can include support modules for certian example by doing something like this in your spec_helper.rb file&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;config.include ControllerHelpers, :type =&amp;gt; :controller&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can do that for observers as well! You may by thinking where the hell did those mock_account and mock_email methods come from? You define then in an obesrver helper module inside the support directory then tell rspec to include them for all observers like so. First create this file: spec/support/observer_helpers.rb&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module ObserverHelpers
  def mock_account(stubs = {}) 
    @mock_account ||= mock_model(Account, stubs)
  end

  def mock_mail(stubs = {}) 
    @mock_mail ||= mock(Mail, stubs)
  end
end&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now in your spec helper:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;config.include ObserverHelpers, :type =&amp;gt; :observer&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Poof! All done. Now you can go on your way running rake spec:observers and treating your observer specs as first class citizens w/Rspec2. Happy testing.&lt;/p&gt;</description>
    </item>
    

  </channel> 
</rss>

