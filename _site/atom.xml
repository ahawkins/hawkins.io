<?xml version="1.0" encoding="UTF8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
<title>BroadcastingAdam</title>
 <link href="http://broadcasting.com/atom.xml" rel="self"/>
 <link href="http://broadcasting.com"/>
 <updated>2011-10-30T15:35:19+02:00</updated>
 <id>http://broadcastingadam.com/</id>
 <author>
   <name>Adam Hawkins</name>
   <email>adman1965@gmail.com</email>
 </author>

 
 <entry>
   <title>Dear God?! What is this Bug?</title>
   <link href="http://broadcastingadam.com/2011/10/dear_god_what_is_this_bug"/>
   <updated>2011-10-28T00:00:00+03:00</updated>
   <content type="html"><![CDATA[<p>A few days ago I had to do a very trivial task. One of my coworkers has translated our Rails app into finnish. He sent me the <code>fi.yml</code> file for me to add the application. I thought this process would take maybe ~30 mins. Turns out it took me <strong>5 hours</strong>. I&#8217;ll tell you why.</p>

<h2 id='it_all_started_on_windows'>It All Started on Windows</h2>

<p>I sent my coworker the existing yml file. I told him to replace the text with the finnish version. He had a hard time just working with the yml file so he made an excel spreadsheet so he could see the existing english text in context. Then he put the finnish version next to it. When he was done he wrote a script to take the finnish columns and create the yml file. Sounds reasonable. I knew there would be formatting mistakes related to tabs, spaces, :&#8217;s etc. So I figured I&#8217;d just have to clean up the file before adding it to the locales. After a few days he sent me the file. Then after a few weeks I had time to put it in&#8211;so I downloaded <code>fi.yml</code> from gmail and off I went.</p>

<p>Drop the file in <code>config/locales</code> and start the server. BOOM. Syntax error. Line #4. Ok, np, open up the file, figure there would be a missing : or something. Nothing jumps out. Stare at it for about 30 minutes. Hmmm&#8230;there&#8217;s <em>got</em> to be something going on here. Open the file up in textmate so I can see &#8220;invisibles.&#8221; Nothing seems out of place. I convert all tabs to spaces (I know YML parsers are bitchy when it comes to this). Run the server again. Syntax error line #4. Le fu. At this point I have no clue what it could be. I save the file in UTF8 (just to be sure) and convert all line breaks to unix format. Sill no luck. At this point I&#8217;m out of ideas. So I just deleted the first block of text and retyped it. Syntax error line 79! <strong>HUZZAH!</strong> Progress. Head over to line 79. There are odvious issues which I take care off. All in all it took little over an hour to clean up the 1,000+ line yml file.</p>

<h2 id='the_server_starts_finally'>The Server Starts Finally</h2>

<p>Now I&#8217;m ready to see the wondeful finnish version of the application. I open up the settings page and switch the locale to Suomen. Refresh the page and voilla! It&#8217;s in English. Hmmm, this is prolly just a dumb thing I did like forgetting the <code>before_filter</code> to set the locale or forgetting to save the form. Ya know, something <strong>simple</strong>. Do the quick status check. Everything is in proper order. My locale is set to <code>fi</code> in the DB. The <code>before_filter :set_locale</code> is being hit. Everything on my end seems to be as it should be. Now I have to do the fun stuff which happens way to often on this project: debug framework code. It&#8217;s time to take a dive into <code>I18n.translate</code> which of <em>course</em> is modified by Rails for trickery.</p>

<h2 id='into_the_rabbit_hole'>Into the Rabbit Hole</h2>

<p>At this point, I just want to find out if the right locale and key is being passed into I18n. After another bit of reading code (and learning about I18n fallbacks) and I see that <code>:fi</code> is being passed into the various translate functions. So at this point, I know these things.</p>

<ol>
<li>My code to manage the locale is correct</li>

<li>My locale is set to :fi</li>

<li>The :fi locale is correctly being passed into I18n.</li>
</ol>

<p>Now that I know this, I&#8217;m able to try to figure out why <strong>every single key</strong> is falling back to english. After some more code reading I look squarely at this method: (source taken from I18n code)</p>

<pre><code>def lookup(locale, key, scope = [], options = {})
  init_translations unless initialized?
  keys = I18n.normalize_keys(locale, key, scope, options[:separator])

  keys.inject(translations) do |result, _key|
    _key = _key.to_sym
    return nil unless result.is_a?(Hash) &amp;&amp; result.has_key?(_key)
    result = result[_key]
    result = resolve(locale, _key, result, options.merge(:scope =&gt; nil)) if result.is_a?(Symbol)
    result
  end
end</code></pre>

<p>The underlying code is pretty simple. It loops over the translation keys like: <code>[en, dashboard, subkey, key, key]</code> to find the actual value in the translations hash. Ok, seems easy enough (recurring theme over the course of this task), throw a debugger in and see what&#8217;s happening.</p>

<p>So I put a debugger here:</p>

<pre><code>def lookup(locale, key, scope = [], options = {})
  init_translations unless initialized?
  keys = I18n.normalize_keys(locale, key, scope, options[:separator])

  keys.inject(translations) do |result, _key|
    _key = _key.to_sym
    debugger # &lt;---------- Debugger added
    return nil unless result.is_a?(Hash) &amp;&amp; result.has_key?(_key)
    result = result[_key]
    result = resolve(locale, _key, result, options.merge(:scope =&gt; nil)) if result.is_a?(Symbol)
    result
  end
end</code></pre>

<p>So I restart the server and go to page. My perfectly placed debugger hits and I get the nice rdb prompt. This is where my brain <strong>starts to question everything it knows about Ruby</strong>.</p>

<h2 id='1__1__1'>1 + 1 = 1</h2>

<p>Now that I&#8217;m in my debugger I can see that <code>locale == :fi =&gt; true</code>. I want to know why the key <code>fi.navigation.dashboard</code> is returning english. So I <strong>step.</strong> and the method exists. Hmm. Apparently the translations hash does not have the <code>:fi</code> key. What follows is something straight out of the X-Files.</p>

<p>I quit the process and start over again. This time I don&#8217;t step but inspect what&#8217;s going on in memory. Here&#8217;s me in the debugger</p>

<pre><code>(rdb:2) translations.keys
[:&quot;en-us&quot;, :&quot;de-ch&quot;, :en, :fi :&quot;en-gb&quot;]
(rdb:2) translations[:fi]
nil
(rdb:2) translations[:en]
{:invitation_mailer=&gt;{:rejection_notification=&gt;{:description=&gt;&quot;%{name} has rejected your invitation! You can reply to this email if\nyou&#39;d like to contact them. They can still confirm later if they want.\nThey will still rece ... you the the point }
(rdb:2)</code></pre>

<p>Well this is looking <strong>very</strong> suspect. I&#8217;m thinking symbols are globally unique! A <code>:fi</code> anywhere in any ruby source file in the same process is equal to any other <code>:fi</code> in the same process. How can this possibly be! Well, perhaps <code>translations</code> isn&#8217;t a simple <code>Hash</code> but something like <code>HashWithIndifferentAccess</code> or other trickery. A check to <code>translations.class</code> returns <code>Hash</code>. At this point I&#8217;m absolutely fucking confused because <code>translations[:fi]</code> is <code>nil</code> but <code>translations[:en]</code> is correct. <strong>AND</strong> <code>translations.keys</code> has <code>:fi</code> in the damn thing. So I start running around the room bouncing off walls and other thing that don&#8217;t make any sense because for some reason all I know about Ruby symbols is wrong and that&#8217;s causing my brain to meltdown.</p>

<p>I start playing in the debugger more.</p>

<pre><code>(rdb:2) translations[translations.keys.first]
# a ton of finnish
(rdb:2) translations.keys[:fi]
nil # wait wut.</code></pre>

<p>Does. Not. Compute. Brain shutting down. More debugging:</p>

<pre><code>(rdb:2) translations.keys
[:fi, :&quot;en-gb&quot;, :en, :&quot;en-us&quot;, :&quot;de-ch&quot;]
(rdb:2) translations.keys.first == :fi # HMMMM. Highly suspect &lt;------------ WTF!
false
(rdb:2) translations.keys.first
:fi
(rdb:2) translations.keys[2] == :en
true
(rdb:2) translations[:en]
# a ton of english
(rdb:2) translations[:fi]
# nil
(rdb:2) translations[translations.keys.first]</code></pre>

<p>GAH. I cannot handle this. There has got to be some completly sinister going on here. Something I&#8217;ve never heard about. Something that only exists in comp.lang.c. Something that is out side of releam. Something going in the C implementation. Just something fucking crazy.</p>

<p>This sort of bug induced comma has been going on for a few hours now. Nearing the end of my rope I try some more things in the debugger:</p>

<pre><code>/Users/adam/.rvm/gems/ree-1.8.7-2011.03/gems/i18n-0.6.0/lib/i18n/backend/simple.rb:33
locale = locale.to_sym
(rdb:1) locale
&quot;fi&quot;
(rdb:1) locale == &quot;fi&quot;
false
(rdb:1) locale &lt;=&gt; &quot;fi&quot;
1
(rdb:1) locale.length
5
(rdb:1) &quot;fi&quot;.length
2</code></pre>

<p><strong>HOLY CHRISTMAS</strong>. There is the sinister bit! The keys are actually different! This is completely masked by any call to <code>puts</code> or <code>to_sym</code>. Now I have to figure out why in god&#8217;s name is the key for finnish in the <code>translations</code> 5 characters. There is only one other place that can cause this problem: Where the YML files are parsed and put into the translations file. I track that down and enter the debugger:</p>

<pre><code>(rdb:1) locale.bytes
#&lt;Enumerable::Enumerator:0x10ba360b8&gt;
(rdb:1) locale.bytes.map(&amp;:to_s)
[&quot;239&quot;, &quot;187&quot;, &quot;191&quot;, &quot;102&quot;, &quot;105&quot;]
(rdb:1) &quot;fi&quot;.bytes.map(&amp;:to_s)
[&quot;102&quot;, &quot;105&quot;]</code></pre>

<h2 id='encodings_youve_done_it_to_me_again'>Encodings, You&#8217;ve Done it to me Again!</h2>

<p>Astute readers will notice that is there is a BOM in the key that&#8217;s used in the <code>translations</code> hash! So when I pass the string &#8220;fi&#8221; into <code>I18n.translate</code> of course it doesn&#8217;t have the BOM in it which essentially equates to I18n thining that there is no such thing as that locale. There are more sinister things at play here. I18n will call <code>to_sym</code> for all keys that are entered into the translations hash. <em>However</em>, ruby will not remove the BOM from the string when <code>to_sym</code> is called. When you inspect that symbol in the debugger it will show as <code>:fi</code>. When you call <code>locale.to_s</code> it will show <code>&quot;fi&quot;</code> so everything <em>seems</em> right on the surface. Underneath the covers it is horribly wrong. Now I have to figure out if the problem is with my files or somee other piece of code. Let&#8217;s get a hex dump and figure out for sure.</p>

<p>Here is the hex dump of the <code>en.yml</code> file.</p>

<pre><code>cs181226081:crm adam$ od config/locales/en.yml 
0000000    067145  005072  020040  067554  060543  062554  035163  020012</code></pre>

<p>Now we have the eternally lovely <code>fi.yml</code></p>

<pre><code>cs181226081:crm adam$ od -ax config/locales/fi.yml 
0000000    ?   ?   ?   f   i   :  nl  sp  sp   l   o   c   a   l   e   s
         bbef    66bf    3a69    200a    6c20    636f    6c61    7365</code></pre>

<p><strong>Dear god</strong>. There is a BOM at the start of the file. That was it?! Yes folks, that was the problem. There was a BOM at the start of my locale file. YAML (however it&#8217;s coded) consumes the bytes and turns them to a key for hash. Question: how come BOM are used to create keys to this hash? Answer: Because I&#8217;m using Ruby 1.8.7 and everything&#8217;s wrong!</p>

<p>People bitch about the YML parser on 1.9. I welcome it&#8217;s strictness. I don&#8217;t think this would&#8217;ve happend on 1.9. There was some interesting twist of fate in how Ruby 1.8.7 handles BOM&#8217;s, encodings, and YAML. I don&#8217;t remember exactly what it was but I know this: It was the perfect storm of everything going the exactly wrong direction to create the most annoying bug I&#8217;ve ever seen. I like to describe these sitations with this phrase: &#8220;a long and constant stream of unfortunate mistakes.&#8221;</p>

<h2 id='squashing_the_bug'>Squashing the Bug</h2>

<p>I don&#8217;t hold anything aganist anyone. This is most likely some odd edge case. I attribute this to the file coming from Windows, generated then edited in god knows what way. I attribute it to encoding conversions. There are a lot of possible ways this situation could happen. One thing is for sure: any YML library on any version of Ruby should <strong>not</strong> allow BOM markers in keys! This is crazy! I cannot think of any use case for this behavior.</p>

<p>After I finally got my head around what exactly what had happened I could move forward. I copied the text to the clipboard and deleted the existing file. I made a new file in the ever trustworthy VIM and pasted it in. <code>:w</code>, then <code>./script/server</code>, and a refresh later: I see my application in Finnish. Jesus christ. That took my a little over 5 hours. By this time I was completely mentally spent. A few fixes and commits later I deployed a finnish version of the application&#8211;then I didn&#8217;t work on Rails for the rest of the day.</p>

<h2 id='moral_of_the_story'>Moral of the story</h2>

<ol>
<li>Use Ruby 1.9</li>

<li>Don&#8217;t trust files from Windows</li>

<li>Turn invisibles on in your editor when editing YML files</li>

<li>Be sure to remove the BOM</li>

<li>Upgrade from Ruby 1.8.7</li>
</ol>

<p>P.S. Here are the gists if you want to relive the horror.</p>

<p><a href='https://gist.github.com/1319411'>Debugging Session</a> <a href='https://gist.github.com/1319579'>Hex Dumps</a></p>]]></content>
 </entry>
 
 <entry>
   <title>Handling Legacy APIs</title>
   <link href="http://broadcastingadam.com/2011/10/handling_legacy_apis"/>
   <updated>2011-10-19T00:00:00+03:00</updated>
   <content type="html"><![CDATA[<p>Well, it&#8217;s been a while since I&#8217;ve written a post to my blog. I&#8217;m on a plane back to Helsinki for some intense work. I&#8217;ve got some trance on so I figure I&#8217;ll scratch and itch and try to get something written.</p>

<p>There are few things poeple never mention when they are teaching rails to rookies, or hell, really even talk about in general. Rails gets a lot of play for how easy it is to write RESTful APIs. It deserves it. However, no one ever mentions what it <em>actually means</em> to write a web API. I haven&#8217;t see anyone talk about freezing input formats or output formats. The common approach is to just throw in <code>respond_to :json</code> then go on your merry way. It works, but it&#8217;s got some problems.</p>

<h2 id='dealing_with_changes'>Dealing with Changes</h2>

<p>Let&#8217;s first examine the most basic and widely adverised Rails RESTful API controlller.</p>

<pre><code>class FoosController &lt; ApplicationController
  respond_to :json

  def new
    respond_with Foo.create(params[:foo])
  end

  def show
    respond_with Foo.find params[:id]
  end

  def index
    respond_with Foo.all
  end

  def update
    foo = Foo.find params[:id]

    respond_with foo.update_attributes(params[:foo])
  end

  def destroy
    foo = Foo.find params[:id]

    respond_with foo.destroy
  end
end</code></pre>

<p><strong>Zomg!</strong> You have an API! Well, no. You&#8217;ve just defined a simple webservice that communicates with JSON. You have not met the two fundamental requirements for writing an API:</p>

<ol>
<li>Input parameters stay the same forever for a given API version</li>

<li>Output formats stay the same forever for a given API version.</li>
</ol>

<p>Let&#8217;s say you change an attribute on the <code>Foo</code> class. You&#8217;ll likely be smacked with a lof of <code>UnknownAttribute</code> errors. Then on the other end, there previous parameter will be renamed in the outputted JSON. Congratulations, you&#8217;ve just made an API that has Facebook consistency. As the developer, you need to take steps to ensure that you&#8217;re API stays to the standards you&#8217;ve written.</p>

<p>You have two ways to handle this problem. You can build logic into the underlying model to handle deprecated methods. You could code some logic into the controller to convert legacy input parameters. You could write a middleware that will handle some changes. There are a few ways to tackel this problem. I&#8217;ll share how I did it for Radium.</p>

<h2 id='handling_legacy_api_input_parameters'>Handling Legacy API Input Parameters</h2>

<p>A long time ago. I wrote a webservice for a Symbian (kill it with fire) application. The API was supposed to exist for maybe a few months for prototyping. Turns out it&#8217;s taken over 1.5 years to develop (and it&#8217;s not done yet) the application. In that time, my simple API interface to some common models has had to stay the same. You can imagine over the course of 1.5 years the underyling schema and model layer will undergo changes. For examples, one record use to a series to timestamps and a state machine to track it&#8217;s progress. Now there is a simple boolean flag. Attributes have been renamed. Classes have changed. The underlying data model has matured but the API hadn&#8217;t. Now I&#8217;m facing a problem with supporting legacy input parameters and legacy output formats. I was using the wonderful <code>to_json</code> method.</p>

<p>I needed to take different param hashes, change values, rename keys, and some various other massaging to fit current model. So I decided to write a class for each different type of API call. There are todos, contacts, and meetings. Here is a snippet of one of the classes:</p>

<pre><code>module SymbianAPI
  class LegacyTodoConverter
    def self.convert(params)
      params[:finished] = true if params.delete(:finished_at)
      params[:description] = params.delete :task
      params[:finish_by] = params.delete :due_at

      # more stuff

      params
    end
  end
end</code></pre>

<p>I ended up writing 3 of these type&#8217;s of classes. They massage the legacy params for the API request and update them to fit the current model.</p>

<p>I took a more complicated route implementing them. I wanted my controllers to look as vanilla as possible. I didn&#8217;t want to have to reference these classes in every request or write a <code>before_filter</code>. I just wanted the controller to know that <code>params[:foo]</code> is good to go. I dedecied to write a middleware that would automatically convert the legacy parameters based on the route. So if the route mataches <code>/api/customers</code>, then I would use my LegacyCustomerConvertor to merge in the new params. There is some other trickery going on here, but I figure I&#8217;d share the code for anyone who is interested.</p>

<pre><code>class SymbianApiAdapter
  def initialize(app)
    @app = app
  end

  def call(env)
    if request_for_symbian_api?(env)
      @app.call convert_legacy_input(env)
    else
      @app.call env
    end
  end

  private 
  def request_for_symbian_api?(env)
    parts = env[&#39;PATH_INFO&#39;].split(&#39;/&#39;)
    parts[1] == &#39;api&#39; &amp;&amp; parts[2] != &#39;v2&#39;
  end

  def convert_legacy_input(env)
    # No fucking clue why we have to do this trickery for PUTS
    if env[&#39;REQUEST_METHOD&#39;] == &#39;PUT&#39;
      params = Rack::Request.new(env).POST
    else
      params = env[&#39;rack.request.form_hash&#39;]
    end

    if params.present? &amp;&amp; params[&#39;xml&#39;].present?
      adapter = case env[&#39;PATH_INFO&#39;]
                when &#39;/api/todos/sync&#39;
                  Api::Adapters::TodosAdapter
                when /todo/
                  Api::Adapters::TodoAdapter
                when &#39;/api/meetings/sync&#39;
                  Api::Adapters::MeetingsAdapter
                when /meeting/
                  Api::Adapters::MeetingAdapter
                when &#39;/api/customers/sync&#39;
                  Api::Adapters::CustomersAdapter
                when /customer/
                  Api::Adapters::CustomerAdapter
                end

      env[&#39;rack.request.form_hash&#39;] || {}

      if adapter
        xml = params.delete &#39;xml&#39;
        hash = Hash.from_xml(xml)

        if hash.values.first.is_a?(Hash)
          converted_params = {}
          converted_params[hash.keys.first] = adapter.convert(hash.values.first.with_indifferent_access)
          env[&#39;rack.request.form_hash&#39;].merge! converted_params
        elsif hash.values.first.is_a?(Array)
          env[&#39;rack.request.form_hash&#39;].merge! adapter.convert(hash)
        end
      end
    end

    env
  end
end</code></pre>

<p>This keeps my controllers small since they don&#8217;t have to worry about handling the paramters. They are just correct when the request finally hits the controller. Now there is also a wall between what comes in from the request and what actually hits the models. This makes it much easier to <strong>ensure future support</strong>. All I need to do is update those convertor classes and things will continue. Now at this point I can write this controller action and never worry about the params.</p>

<pre><code>class FoosController &lt; ApplicationController
  respond_to :json

  def create
    reapond_with Foo.create(params[:foo])
  end
end</code></pre>

<h2 id='handling_legacy_api_output_formats'>Handling Legacy API Output Formats</h2>

<p>There has finally been some talk about this sort of thing. There needs to be a way to easily generate different blocks of JSON depending on what API version is in use&#8211;essentially different <strong>views</strong>. There are a few ways to do this. You could use a fancy new JSON builder like Rabl. I have not used Rabl. I investigated it, but I find that using builders in views is cumbersom when you need to write some code. (And code doesn&#8217;t belong the view anyway). I opted for an easier approach. (And given that this is currently a Rails 2 app, there are no other options). I wrote another three classes that take the record to be returned and generate an output hash. That hash can then be used for <code>to_json</code> or <code>to_xml</code>. Here&#8217;s how they work.</p>

<pre><code>module Api
  class LegacyContactAdapter
    def self.convert(contact)
     {
      :town =&gt; contact.city, # API was specified to return a &#39;town&#39; attribute
      :postcode =&gt; contact.zip_code # API specificed a &#39;postcode&#39; attribute

      # so on and so forth. Build up the hash with the specified
      # attributes
    }
  end
end</code></pre>

<p>Now, the controller can use that class to return the required JSON.</p>

<pre><code>def create
  foo = Foo.create params[:foo]

  if foo.save
    respond_to do |wants|
      wants.json { render :json =&gt; Api::LegacyContactAdapter.convert(contact), :status =&gt; :created }
    end
  else
    respond_to do |wants|
      wants.json { render :json =&gt; contact.errors, :status =&gt; :unprocessable_entity }
    end
  end</code></pre>

<p>Using that classes ensure that it&#8217;s easy(ier) to support the legacy API into the future because there is a wall in the code. Also, if the contact model ever changes, or the api needs a new output paramter, you can just throw it into the various <code>Adapter</code> classes.</p>

<h2 id='wrapping_it_up'>Wrapping it Up</h2>

<p>Writing API&#8217;s is serious business. They represent a contact between your system and external developers. You need to do everything in your power to ensure that you hold up your end of the baragin. You need to ensure that the input parameters are always accepted and that you stick to the given output format no matter what changes. I&#8217;ve showed you some different ways you can hold up your end of the contract. A middleware based solution may not work in every situation. I could&#8217;ve easily used a <code>before_filter</code> but I didn&#8217;t like that. The important thing is to build walls between the API and the other parts of your code that way it&#8217;s easier to ensure support in the future.</p>]]></content>
 </entry>
 
 <entry>
   <title>Present Yourself - Presenters in Rails</title>
   <link href="http://broadcastingadam.com/2011/06/present_yourself"/>
   <updated>2011-06-10T00:00:00+03:00</updated>
   <content type="html"><![CDATA[<p>Presenters are one of those interesting things that you don&#8217;t hear about very much. They are mentioned, and then flutter in the wind. If you google &#8220;presenters rails&#8221; you&#8217;ll get some links from a few years ago and that&#8217;s about it. There is perhaps some useful information there. Maybe you find something on cells. That&#8217;s most likely not what you want. I&#8217;m taking about presenters (insert Alan Iverson practice voice). Presenters are object designed to encapsulate information required to create a view. They slim down controllers and encourage view reusability. This post describes how I started using presenters and why it worked.</p>

<h2 id='the_backstory__thats_a_god_damn_ton_of_instance_variables'>The Backstory - That&#8217;s a God Damn Ton of Instance Variables</h2>

<p>I work on a complex project. It&#8217;s not one of those cookie-cutter Rails apps that deals with practically generated code. There is some real business going on here. Views are complicated things and it takes a fair amount of information to render views for certain objects. Here is an example of what I&#8217;m talking about for one page.</p>

<ol>
<li>The record itself.</li>

<li>All the associated notes</li>

<li>All the associated todos</li>

<li>All the associated extra fields (think EAV)</li>

<li>All the associated deals</li>

<li>All the associate activities (with fancy filtering. This alone is massive where each activity as it&#8217;s own forms and required stuff)</li>

<li>Statistics (3 different tables, 30 different statistics, custom ranges)</li>

<li>A new email</li>

<li>A new sms</li>

<li>A new meeting</li>

<li>A new deal</li>

<li>The list goes on</li>
</ol>

<p>Everyone is used to seeing this:</p>

<pre><code>def show
  @customer = Customer.find params[:id]
end</code></pre>

<p>That&#8217;s all well in good for simple applications. What if you have this?</p>

<pre><code>def show
  @customer = Customer.find params[:id]

  # insert 30 more lines of instantiation
  # and other trickery to get the view to render
end</code></pre>

<p>That&#8217;s gonna get old real quick&#8211;especially if you have to do that for many different pages. The controller is becoming ove run run with logic <strong>only</strong> required for the view. All of that extra cruft is not related to the actual controller action of taking params and finding and object. <strong>It&#8217;s just noise.</strong> The solution is to move all that stuff into an object that knows how to <em>present</em> that specific view. Why do you want to to this? I think there are a few reasons.</p>

<ol>
<li>Keep controllers small and stupid. They should be kept small.</li>

<li>Extract logic into a class where it&#8217;s easily testable</li>

<li>Encourage view/template reusability since a view requires an object not a random assortment of instance variables.</li>

<li>Keep views stupid since they depend on one object for everything.</li>
</ol>

<p>Now many of my previous complex controller actions look like this:</p>

<pre><code>def show
  customer = Customer.find params[:id]
  @presenter = CustomerPresenter.new customer, current_user
end</code></pre>

<p>At this point, the presenter does all the required instantiation and other trickery that the view needs.</p>

<h2 id='looking_at_a_presenter'>Looking at a Presenter</h2>

<p>I created a common base class for all the presenters in my application. I call it ApplicationPresenter. Here&#8217;s the code: (Rails 2.3)</p>

<pre><code>class ApplicationPresenter
  extend ActiveSupport::Memoizable
  include ActionController::UrlWriter
  include ActionController::RecordIdentifier

  def self.default_url_options
    ActionMailer::Base.default_url_options
  end

  private
  def t(*args)
    I18n.translate(*args)
  end
end</code></pre>

<p>This code enables me to do a few things:</p>

<ol>
<li>Memoize all methods so instantiation/querying only happens once</li>

<li>Use named route helpers &amp; url_for/polymorphic_url etc in the presenter</li>

<li>User <code>dom_id</code> and things like that. I use <code>dom_id</code> a ton in this project.</li>

<li>Provide <code>t</code> in the presenters. This is mostly to prevent the views from figuring out how to find text themselves.</li>
</ol>

<p>The application is very compontentized. Pages are composed of different components. Each component has their own presenter. A page presenter will provide an interface for getting a presenter for each component. That presenter is passed into the partial as a local variable. It works out pretty well. Here is an example view. Most of the views look like this:</p>

<pre><code>-# This is the dashboard type view

- title @presenter.title

= render :partial =&gt; &#39;announcements/announcement&#39;, :locals =&gt; {:presenter =&gt; @presenter.announcement_presenter}

= render :partial =&gt; &quot;activities/activities&quot; , :locals =&gt; {:presenter =&gt; @presenter.activities_presenter}

= render_statistics @presenter.statistics_presenter

- content_for :sidebar do

  = render :partial =&gt; &quot;todos/widget&quot;, :locals =&gt; { :presenter =&gt; @presenter.todo_widget_presenter }

  = render :partial =&gt; &#39;users/widget&#39;, :locals =&gt; { :presenter =&gt; @presenter.user_widget_presenter }

  = render :partial =&gt; &#39;customers/search_widget&#39;

  = render :partial =&gt; &#39;companies/widget&#39;, :locals =&gt; {:presenter =&gt; @presenter.company_widget_presenter}</code></pre>

<p>Now you know what a basic view looks like, here&#8217;s the code for that page&#8217;s presenter.</p>

<pre><code>class DashboardPresenter &lt; ApplicationPresenter
  def initialize(user)
    @user = user
  end

  def user_widget_presenter
    UserWidgetPresenter.new @user 
  end
  memoize :user_widget_presenter

  def company_widget_presenter
    CompanyWidgetPresenter.new @user
  end
  memoize :company_widget_presenter

  def todo_widget_presenter
    TodoWidgetPresenter.new @user, @user
  end
  memoize :todo_widget_presenter

  def announcement_presenter
    AnnouncementPresenter.new @user
  end
  memoize :announcement_presenter

  def activities_presenter
    DashboardActivitiesPresenter.new @user, @user
  end
  memoize :activities_presenter

  def statistics_presenter
    DashboardStatisticsPresenter.new @user
  end
  memoize :statistics_presenter

  def title
    t &#39;dashboard.page_title&#39;
  end
  memoize :title
end</code></pre>

<p>The main page presenters really don&#8217;t have much to them. The just create presenters for all the different components I want on that page. However, some of the individual presenters can get pretty hairy. I&#8217;ll share a simple one first:</p>

<pre><code>class NotesPresenter &lt; ApplicationPresenter
  def initialize(record)
    @record = record
  end

  def notes
    @record.notes.all(:include =&gt; :user)
  end
  memoize :notes

  def show_explanation?
    @record.notes.count == 0
  end
  memoize :show_explanation?

  def explanation
    t(&#39;explanations.notes&#39;)
  end
  memoize :explanation
end</code></pre>

<p>Now for the hairy one:</p>

<pre><code>class DealsPresenter &lt; ApplicationPresenter

  PER_PAGE = 35

  def initialize(user, params)
    @user = user
    @params = params
  end

  def deals
    if @user.is_a?(Manager)
      bucket = account.deals
    else
      bucket = @user.deals
    end

    case filter
    when &#39;user&#39;
      bucket = bucket.with_user(account.users.find(@params[:user_id]))
    when &#39;status_pending&#39;
      bucket = bucket.pending
    when &#39;status_closed&#39;
      bucket = bucket.closed
    when &#39;status_rejected&#39;
      bucket = bucket.rejected
    when &#39;status_paid&#39;
      bucket = bucket.paid
    when &#39;due_this_week&#39;
      bucket = bucket.due_between(Time.zone.now.beginning_of_week..Time.zone.now.end_of_week)
    when &#39;due_this_month&#39;
      bucket = bucket.due_between(Time.zone.now.beginning_of_month..Time.zone.now.end_of_month)
    when &#39;due_overdue&#39;
      bucket = bucket.overdue
    else
      bucket
    end

    bucket.paginate :order =&gt; &quot;#{ordered_column} #{sort_direction}&quot;,
                    :include =&gt; [{:customer =&gt; :company}, :user],
                    :page =&gt; @params[:page],
                    :per_page =&gt; PER_PAGE
  end
  memoize :deals

  def filters_presenter
    presenter = FiltersPresenter.new

    presenter.filter I18n.translate(&#39;deals.filters.all_deals&#39;), deals_path, :class =&gt; (filter == &#39;all&#39; ? &#39;selected&#39; : &#39;unselected&#39;)

    text = case filter
           when &#39;user&#39;
             I18n.translate(&#39;deals.filters.filtered_by_user&#39;, :user =&gt; account.users.find(@params[:user_id]))
           else
             I18n.translate(&#39;deals.filters.by_user&#39;)
           end

    if @user.is_a?(Manager)
      presenter.dropdown text, :class =&gt; (filter == &#39;user&#39; ? &#39;selected&#39; : &#39;unselected&#39;) do |drop_down|
        account.users.alphabetical.except(@user).each do |user|
          drop_down.filter user, deals_path(:filter =&gt; :user, :user_id =&gt; user.id)
        end
      end
    end

    text = case filter
           when &#39;status_pending&#39;
             I18n.translate(&#39;deals.filters.status_pending&#39;)
           when &#39;status_closed&#39;
             I18n.translate(&#39;deals.filters.status_closed&#39;)
           when &#39;status_paid&#39;
             I18n.translate(&#39;deals.filters.status_paid&#39;)
           when &#39;status_rejected&#39;
             I18n.translate(&#39;deals.filters.status_rejected&#39;)
           else
             I18n.translate(&#39;deals.filters.status&#39;)
           end

    presenter.dropdown text, :class =&gt; (filter =~ /status/ ? &#39;selected&#39; : &#39;unselected&#39;) do |drop_down|
      %w(pending closed paid rejected).each do |status|
        drop_down.filter I18n.translate(&quot;deals.states.#{status}&quot;), deals_path(:filter =&gt; &quot;status_#{status}&quot;) if filter != status
      end
    end

    presenter
  end
  memoize :filters_presenter

  def deal
    Deal.new
  end
  memoize :deal

  def sortable_options
    @params.slice(:filter, :user_id)
  end
  memoize :sortable_options

  def sort_column
    %w(user customer company amount due_on status).include?(@params[:sort]) ? @params[:sort] : &#39;user&#39;
  end
  memoize :sort_column

  def sort_direction
    @params[:direction] == &#39;desc&#39; ? &#39;desc&#39; : &#39;asc&#39;
  end
  memoize :sort_direction

  def ordered_column
    case sort_column
    when &#39;user&#39;
      &#39;users.name&#39;
    when &#39;customer&#39;
      &#39;customers.name&#39;
    when &#39;company&#39;
      &#39;companies.name&#39;
    when &#39;amount&#39;
      &#39;deals.value&#39;
    when &#39;status&#39;
      &#39;deals.state&#39;
    when &#39;due_on&#39;
      &#39;deals.due_by&#39;
    end
  end
  memoize :ordered_column

  def title
    I18n.translate &#39;plurals.deals&#39;
  end
  memoize :title

  def statistics_presenter

  end
  memoize :statistics_presenter

  private
  def filter
    %w(user status_pending status_closed status_rejected status_paid
      due_this_week due_this_month due_overdue all).include?(@params[:filter]) ? @params[:filter] : &#39;all&#39;
  end
  memoize :filter

  def account
    @user.account
  end
  memoize :account
end</code></pre>

<p><strong>Note:</strong> this particular presenter is waiting to be refactored. But it does give you an idea of some of the logic that I removed from the controlller. It also testifies to the logic required to construct a view and why it&#8217;s nice to remove it from the controller.</p>

<h2 id='testing_presenters'>Testing Presenters</h2>

<p>I like moving logic out of the controllers because testing controllers is such a pain in the ass. (I stopped doing it completely actually). Once your controller starts to do some real work, whatever mocks/stubs you had in place become too cumbersome to maintain. Sometimes I simply want to test that a new instance variable is created. Using my presenter, I could write a test like this:</p>

<pre><code>class NotesPresenter &lt; ApplicationPresenter
  def note
    Note.new
  end
  memoize :note
end

describe NotesPresenter do
  it &quot;should provide a new note for a form&quot; do
    subject.note.should be_new_record
    subject.note.should be_a(Note)
  end
end</code></pre>

<p>Good luck doing that in a controller action with more complex logic. It&#8217;s very easy to test in an isolate class.</p>

<p>Most of my test cases don&#8217;t do heavy assertions, but verify that a specific interface is implemented. Most of the logic inside the method is trivial enough to ignore writing a test case. Instead, I use rspec&#8217;s <code>it_should_behave_like</code> to specify the presenter provides a certain interface. Here is the test for the previously mentioned <code>DashboardPresenter</code>:</p>

<pre><code>require &#39;spec_helper&#39;

describe DashboardPresenter do
  def mock_user(stubs = {})
    @mock_user ||= mock_model(User, stubs)
  end

  subject { DashboardPresenter.new(mock_user) }

  it_should_behave_like &quot;a presenter with activities&quot;

  it_should_behave_like &quot;a presenter with todos&quot;

  it_should_behave_like &quot;a presenter with stats&quot;

  it_should_behave_like &quot;a presenter with companies&quot;

  it_should_behave_like &quot;a presenter with a page title&quot;

  it { should respond_to(:user_widget_presenter) }

  it { should respond_to(:announcement_presenter) }
end</code></pre>

<p>Now for a component presenter:</p>

<pre><code>require &#39;spec_helper&#39;

describe NotesPresenter do
  fixtures :customers

  subject { NotesPresenter.new customers(:teemu) }

  it_should_behave_like &quot;a presenter with an explanation&quot;

  it { should respond_to(:notes) }
end</code></pre>

<h2 id='closing_thoughts'>Closing Thoughts</h2>

<p>I&#8217;m very happy I did this. It makes my view layer much easier to maintain. It also makes my controllers easy to maintain because of how simple they are. It also gives me a common object I can pass off to a view if I need to render it. This happens to me a lot actually. There are ajax forms that hit different controllers on one page. For example, if you are on &#8216;companies/1&#8217; there is a form to add a todo. Naturally this goes to <code>TodosController</code>. Now the UI for the company page has to be updated from the <code>TodosController</code> in a <code>js.erb</code> template. I can simply instantiate the todos component presenter has use that to rerender the partial. I don&#8217;t have to know anything else&#8211;the presenter does all the work for me.</p>

<p>You can learn more about presenters in this <a href='http://www.codeschool.com/courses/rails-best-practices'>course</a>. You can also learn more about presenters by reading Martin Flower&#8217;s <a href='http://www.google.com/search?sourceid=chrome&amp;ie=UTF-8&amp;q=martin+fowler+presenter'>papers</a>.</p>]]></content>
 </entry>
 
 <entry>
   <title>Advanced Caching in Rails</title>
   <link href="http://broadcastingadam.com/2011/05/advanced_caching_in_rails"/>
   <updated>2011-05-06T00:00:00+03:00</updated>
   <content type="html"><![CDATA[<p>Caching in Rails is covered occasionally. It is covered in very basic detail in the caching <a href='http://guides.rubyonrails.org/caching_with_rails.html'>guide</a>. Advanced caching is left to reader. Here&#8217;s where I come in. I recently read part of Ryan Bigg&#8217;s <a href='http://www.manning.com/katz/'>Rails 3 in Action</a> upcoming Rails book (review in the works) where he covers caching. He does a wonderful job of giving the reader the basic sense of how you can use page, action, and fragment caching. The examples only work well in a simple application like he&#8217;s developing in the book. I&#8217;m going to show you how you can level up your caching with some new approaches.</p>

<h2 id='different_caching_layers'>Different Caching Layers</h2>

<p>First, let&#8217;s start with a brief overview of the different types of caching:</p>

<p>1. Page Caching: <strong>PRAISE THE GODS</strong> if you actually can use page caching in your application. Page caching is the holy grail. Save the entire thing. Don&#8217;t hit the stack &amp; give some prerendered stuff back. Great for worthless applications without authentication and other highly dynamic aspects.</p>

<p>2. Action Caching: Essentially the same as page caching, except all the before filters are run allowing you to check authentication and other stuff that may have prevented the request for rendering.</p>

<p>3. Fragment Caching: Store parts of views in the cache. Usually for caching partials or large bits of HTML that are independent from other parts. IE, a list of top stories or something like that.</p>

<p>4. Rails.cache: All cached content <strong>except cached pages</strong> are stored in the Rails.cache. Cached pages are stored as HTML on disk. We&#8217;ll use the fact that all the cached action and fragment content are simply stored in Rails.cache. You can cache arbitrary content in the Rails cache. You may cache a large complicated query that you don&#8217;t want to wait to reinstantiate a ton of AR::Base objects.</p>

<h2 id='under_the_hood'>Under the Hood</h2>

<p>All the caching layers are built on top of the next one. Page caching is the only exception because it does not use <code>Rails.cache</code> it writes content to disk. The cache is essentially a key-value store. Different things can be persisted. Strings are most common (for HTML fragments). More complicated objects can be persisted as well. Let&#8217;s go through some examples of manually using the cache to store things. I am using memcached with dalli for all these examples. Any driver that implements the cache store pattern should work.</p>

<pre><code># Rails.cache.write takes two value: key and a value
&gt; Rails.cache.write &#39;foo&#39;, &#39;bar&#39;
=&gt; true

# We can read an object back with read
&gt; Rails.cache.read &#39;foo&#39;
=&gt; &quot;bar&quot;

# We can store a complicated object as well
&gt; hash = {:this =&gt; {:is =&gt; &#39;a hash&#39;}}
&gt; Rails.cache.write &#39;complicated-object&#39;, object
&gt; Rails.cache.read &#39;complicated-object&#39;
=&gt; {:this=&gt;{:is=&gt;&quot;a hash&quot;}}

# If we want something that doesn&#39;t exist, we get nil
&gt; Rails.cache.read &#39;we-havent-cached-this-yet&#39;
=&gt; nil

# &quot;Fetch&quot; is the most common pattern. You give it a key and a block
# to execute to store if the cache misses. The block is not executed
# if there is a cache hit.
&gt; Rails.cache.fetch &#39;huge-array&#39; do
    huge_array = Array.new
    1000000.times { |i| huge_array &lt;&lt; i }
    huge_array # retrun value is stored in cache
  end
=&gt; [huge array] # took some time to generate
&gt; Rails.cache.read &#39;huge-array&#39;
=&gt; [huge array] # but returned instantly

# You can also delete everything from the cache
&gt; Rails.cache.clear 
=&gt; [true]</code></pre>

<p>Those are the basics of interacting withe the Rails cache. The rails cache is a wrapper around whatever functionality is provided by the underlying storage system. Now we are ready to move up a layer.</p>

<h2 id='understanding_fragment_caching'>Understanding Fragment Caching</h2>

<p>Fragment caching is taking rendered HTML fragments and storing them in the cache. Rails provides a <code>cache</code> view helper for this. It&#8217;s most basic form takes no arguments besides a block. Whatever is rendered during the block will be written back to the cache. The basic principle behind fragment caching is that it takes much less time fetch pre-rendered HTML from the cache, then it takes to generate a fresh copy. This is very true. If you haven&#8217;t noticed, view generation can be very costly. Let&#8217;s say you have generated a basic scaffold for a post:</p>

<pre><code>$ rails g scaffold post title:string content:text author:string
# that will generate some views to play with</code></pre>

<p>Let&#8217;s start with the most common use case: caching information specific to one thing. IE: One post. Here is a show view:</p>

<pre><code>&lt;!-- nothing fancy going on here --&gt;
&lt;p&gt;
  &lt;b&gt;Title:&lt;/b&gt;
  &lt;%= @post.title %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;b&gt;Content:&lt;/b&gt;
  &lt;%= @post.content %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;b&gt;Author:&lt;/b&gt;
  &lt;%= @post.author %&gt;
&lt;/p&gt;</code></pre>

<p>Let&#8217;s say we wanted to cache fragment. Simple wrap it in <code>cache</code> and Rails will do it.</p>

<pre><code>&lt;%= cache &quot;post-#{@post.id}&quot; do %&gt;
  &lt;p&gt;
    &lt;b&gt;Title:&lt;/b&gt;
    &lt;%= @post.title %&gt;
  &lt;/p&gt;

  &lt;p&gt;
    &lt;b&gt;Content:&lt;/b&gt;
    &lt;%= @post.content %&gt;
  &lt;/p&gt;

  &lt;p&gt;
    &lt;b&gt;Author:&lt;/b&gt;
    &lt;%= @post.author %&gt;
  &lt;/p&gt;
&lt;% end %&gt;</code></pre>

<p>The first argument is the key for this fragment. The rendered HTML is stored with this key: <code>views/posts-1</code>. Wait what? Where did that &#8216;views&#8217; come from? The <code>cache</code> view helper automatically prepends &#8216;view&#8217; to all keys. This is important later. When you first load the page you&#8217;ll see this in the log:</p>

<pre><code>Exist fragment? views/post-2 (1.6ms)
Write fragment views/post-2 (0.9ms)</code></pre>

<p>You can see the key and the operations. Rails is checking to see if the specific key exists. It will fetch it or write it. In this case, it has not been stored so it is written. When you reload the page, you&#8217;ll see a cache hit:</p>

<pre><code>Exist fragment? views/post-2 (0.6ms)
Read fragment views/post-2 (0.0ms)</code></pre>

<p>There we go. We got HTML from the cache instead of rendering it. Look at the response times for the two requests:</p>

<pre><code>Completed 200 OK in 17ms (Views: 11.6ms | ActiveRecord: 0.1ms)
Completed 200 OK in 16ms (Views: 9.7ms | ActiveRecord: 0.1ms)</code></pre>

<p>Very small differences in this case. 2ms different in view generation. This is a very simple example, but it can make a world of difference in more complicated situations.</p>

<p>You are probably asking the question: &#8220;What happens when the post changes?&#8221; This is an excellent question! What well if the post changes, the cached content will <strong>not</strong> be correct. It is up to <strong>us</strong> to remove stuff from the cache <strong>or</strong> figure out a way to get new content from the cache. Let&#8217;s assume that our blog posts now have comments. What happens when a comment is created? How can handle this?</p>

<p>This is a very simple problem. What if we could figured out a solution to this problem: How can we create a cache miss when the associated object changes? We&#8217;ve already demonstrated how we can explicitly set a cache key. What if we made a key that&#8217;s dependent on the time the object was last updated? We can create a key composed of the record&#8217;s ID and it&#8217;s updated_at timestamp! This way the cache key will change as the content changes <strong>and we will not have to expire things manually.</strong> (We&#8217;ll come back to sweepers later). Let&#8217;s change our cache key to this:</p>

<pre><code>&lt;% cache &quot;post-#{@post.id}&quot;, @post.updated_at.to_i do %&gt;</code></pre>

<p>Now we can see we have a new cache key that&#8217;s dependent on the objects timestamps. Check out the rails log:</p>

<pre><code>Exist fragment? views/post-2/1304291241 (0.5ms)
Write fragment views/post-2/1304291241 (0.4ms)</code></pre>

<p>Cool! Now let&#8217;s make it so creating a comment updates the post&#8217;s timestamp:</p>

<pre><code>class Comment &lt; ActiveRecord::Base
  belongs_to :post, :touch =&gt; true
end</code></pre>

<p>Now all comments will touch the post and change the <code>updated_at</code> time stamp. You can see this in action by <code>touch</code>&#8216;ing a post.</p>

<pre><code>Post.find(1).touch

Exist fragment? views/post-2/1304292445 (0.4ms)
Write fragment views/post-2/1304292445 (0.4ms)</code></pre>

<p>This concept is known as: <strong>auto expiring cache keys.</strong> You create a composite key with the normal key and a time stamp. This will create some memory build up as objects are updated and no longer create cache hits. For example. You have that fragment. It is cached. Then someone updates the post. You now have two versions of the fragment cached. If there are 10 updates, then there are 10 different versions. Luckily for you, this is not a problem for memcached! Memcached uses a LRU replacement policy. LRU stands for Least Recently Used. That means the key that hasn&#8217;t been request in the longest time will be replaced with new content needs to be stored. For example, assume your cache can only hold 10 posts. The next update will create a new key and hence new content. Version 0 will be deleted and version 11 will be stored in the cache. The total amount of memory is cycled between things that are requested. There are two things to consider in this approach. 1: You will not be able to ensure that content is kept in the cache as long as possible. 2. You will never have to worry about expiring things manually as long as timestamps are updated in the model layer. I&#8217;ve found it is orders of magnitude easier to add a few <code>:touch =&gt; true</code>&#8217;s to my relationships than it is to maintain sweepers. More on sweepers later. We must continue exploring cache keys.</p>

<p>Rails uses auto-expiring cache keys by <strong>default.</strong> The problem is they are not mentioned at all the documentation or in the guides. There is one very handy method: <code>ActiveRecord::Base.cache_key</code>. This will generate a key like this: <code>posts/2-20110501232725</code>. <strong>This is the exact same thing we did ourselves.</strong> This method is very important because depending on what type of arguments you pass into the <code>cache</code> method it will be called on them. For the time being, this code is functionally equal to our previous examples.</p>

<pre><code>&lt;%= cache @post do %&gt;</code></pre>

<p>The <code>cache</code> helper takes different forms for arguments. Here are some examples:</p>

<pre><code>cache &#39;explicit-key&#39;      # views/explicit-key
cache @post               # views/posts/2-1283479827349
cache [@post, &#39;sidebar&#39;]  # views/posts/2-2348719328478/sidebar
cache [@post, @comment]   # views/posts/2-2384193284878/comments/1-2384971487
cache :hash =&gt; :of_things # views/localhost:3000/posts/2?hash_of_things</code></pre>

<p>If an <code>Array</code> is the first arguments, Rails will use cache key expansion to generate a string key. This means calling doing logic on each object then joining each result together with a &#8217;/&#8217;. Essentially, if the object responds to <code>cache_key</code>, it will use that. Else it will do various things. Here&#8217;s the source for <code>expand_cache_key</code>:</p>

<pre><code>def self.expand_cache_key(key, namespace = nil)
  expanded_cache_key = namespace ? &quot;#{namespace}/&quot; : &quot;&quot;

  prefix = ENV[&quot;RAILS_CACHE_ID&quot;] || ENV[&quot;RAILS_APP_VERSION&quot;]
  if prefix
    expanded_cache_key &lt;&lt; &quot;#{prefix}/&quot;
  end

  expanded_cache_key &lt;&lt;
    if key.respond_to?(:cache_key)
      key.cache_key
    elsif key.is_a?(Array)
      if key.size &gt; 1
        key.collect { |element| expand_cache_key(element) }.to_param
      else
        key.first.to_param
      end
    elsif key
      key.to_param
    end.to_s

  expanded_cache_key
end</code></pre>

<p>This is where all the magic happens. Our simple fragment caching example could easily be converted into an idea like this: The post hasn&#8217;t changed, so cache the entire result of /posts/1. You can do with this action caching or page caching.</p>

<h2 id='moving_on_to_action_caching'>Moving on to Action Caching</h2>

<p>Action caching is an around filter for specific controller actions. It is different from page caching since before filters are run and may prevent access to certain pages. For example, you only want to cache if the user is logged in. If the user is not logged in they should be redirect to the log in page. This is different than page caching. Page caching bypasses the rails stack completely. Most web applications for legitimate complexity cannot use page caching. Action caching is the next logical step for most web applications. Let&#8217;s break the idea down: If the post hasn&#8217;t changed, return the entire cached page as the HTTP response, else render the show view, cache it, and return that as the HTTP response. Or in code:</p>

<pre><code>Rails.cache.fetch &#39;views/localhost:3000/posts/1&#39; do
  @post = Post.find params[:id]
  render :show
end</code></pre>

<p>Declaring action caching is easy. Here&#8217;s how you can cache the show action:</p>

<pre><code>class PostsController &lt; ApplicationController

  caches_action :show

  def show
    # do stuff
  end
end</code></pre>

<p>Now refresh the page and look at what&#8217;s been cached.</p>

<pre><code>Started GET &quot;/posts/2&quot; for 127.0.0.1 at 2011-05-01 16:54:43 -0700
  Processing by PostsController#show as HTML
  Parameters: {&quot;id&quot;=&gt;&quot;2&quot;}
Read fragment views/localhost:3000/posts/2 (0.5ms)
Rendered posts/show.html.erb within layouts/application (6.1ms)
Write fragment views/localhost:3000/posts/2 (0.5ms)
Completed 200 OK in 16ms (Views: 8.6ms | ActiveRecord: 0.1ms)</code></pre>

<p>Now that the show action for post #2 is cached, refresh the page and see what happens.</p>

<pre><code>Started GET &quot;/posts/2&quot; for 127.0.0.1 at 2011-05-01 16:55:27 -0700
  Processing by PostsController#show as HTML
  Parameters: {&quot;id&quot;=&gt;&quot;2&quot;}
Read fragment views/localhost:3000/posts/2 (0.6ms)
Completed 200 OK in 1ms</code></pre>

<p>Damn. 16ms vs 1ms. You can see the difference! You can also see Rails reading that cache key. <strong>The cache key is generated off the url with action caching.</strong> Action caching is a combination of a before and around filter. The around filter is used to capture the output and the before filter is used to check to see if it&#8217;s been cached. It works like this:</p>

<ol>
<li>Execute before filter to check to see if cache key exists?</li>

<li>Key exists? - Read from cache and return HTTP Response. This triggers a <code>render</code> and <strong>prevents any further code from being executed.</strong></li>

<li>No key? - Call all controller and view code. Cache output using Rails.cache and return HTTP response.</li>
</ol>

<p>Now you are probably asking the same question as before: &#8220;What do we do when the post changes?&#8221; We do the same thing as before: we create a composite key with a string and a time stamp. The question now is, how do we generate a special key using action caching?</p>

<p>Action caching generates a key from the current url. You can pass extra options using the <code>:cache_path</code> option. Whatever is in this value is passed into <code>url_for</code> using the current parameters. Remember in the view cache key examples what happened when we passed in a hash? We got a much different key than before:</p>

<pre><code>views/localhost:3000/posts/2?hash_of_things</code></pre>

<p>Rails generated a URL based key instead of the standard views key. This is because you may different servers and things like that. This ensures that each server has it&#8217;s own cache key. IE, server one does not collide with server 2. We could generate our own url for this resource by doing something like this:</p>

<pre><code>url_for(@post, :tag =&gt; @post.updated_at.to_i)</code></pre>

<p>This will generate this url:</p>

<pre><code>http://localhost:3000/posts/1?tag=234897123978</code></pre>

<p>Notice the &#8216;?tag=23481329847&#8217;. Look familiar from anywhere? Rails uses this method to tag GET urls for static assets. That way the browser does not send a new HTTP request when it sees &#8216;application.css?1234&#8217; since it is caching it. We can use this strategy to with action caching as well.</p>

<pre><code>caches_action :show, :cache_path =&gt; proc { |c|
  # c is the instance of the controller. Since action caching
  # is declared at the class level, we don&#39;t have access to instance
  # variables. If cache_path is a proc, it will be evaluated in the
  # the context of the current controller. This is the same idea
  # as validations with the :if and :unless options
  #
  # Remember, what is returned from this block will be passed in as
  # extra parameters to the url_for method.
  post = Post.find c.params[:id]
  {:tag =&gt; post.updated_at.to_i}
end</code></pre>

<p>This calls <code>url_for</code> with the parameters already assigned by it through the router and whatever is returned by the block. Now if you refresh the page, you&#8217;ll have this:</p>

<pre><code>Started GET &quot;/posts/2&quot; for 127.0.0.1 at 2011-05-01 17:11:22 -0700
  Processing by PostsController#show as HTML
  Parameters: {&quot;id&quot;=&gt;&quot;2&quot;}
Read fragment views/localhost:3000/posts/2?tag=1304292445 (0.5ms)
Rendered posts/show.html.erb within layouts/application (1.7ms)
Write fragment views/localhost:3000/posts/2?tag=1304292445 (0.5ms)
Completed 200 OK in 16ms (Views: 4.4ms | ActiveRecord: 0.1ms)</code></pre>

<p>And volia! Now we have an expiring cache key for our post! Let&#8217;s dig a little deeper. We know the key. Let&#8217;s look into the cache and see what it actually is! You can see the key from the log. Look it up in the cache.</p>

<pre><code>&gt; Rails.cache.read &#39;views/localhost:3000/posts/2?tag=1304292445&#39;
=&gt; &quot;&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;.....&quot;</code></pre>

<p>It&#8217;s just a straight HTML string. Easy to use and return as the body. This method works well for singular resources. How can we handle the index action? I&#8217;ve created 10,000 posts. It takes a good amount of time to render that page on my computer. It takes over 10 seconds. The question is, how can we cache this? We could use the most recently updated post for the time stamp. That way, when one post is updated, it will move to the top and create a new cache key. Here is the code without any action caching:</p>

<pre><code>Started GET &quot;/posts&quot; for 127.0.0.1 at 2011-05-01 17:18:11 -0700
  Processing by PostsController#index as HTML
  Post Load (54.1ms)  SELECT &quot;posts&quot;.* FROM &quot;posts&quot; ORDER BY updated_at DESC LIMIT 1
Dalli::Server#connect localhost:11212
Read fragment views/localhost:3000/posts?tag=1304292445 (1.5ms)
Rendered posts/index.html.erb within layouts/application (9532.3ms)
Write fragment views/localhost:3000/posts?tag=1304292445 (36.7ms)
Completed 200 OK in 10088ms (Views: 9535.6ms | ActiveRecord: 276.2ms)</code></pre>

<p>Now with action caching:</p>

<pre><code>Started GET &quot;/posts&quot; for 127.0.0.1 at 2011-05-01 17:20:47 -0700
  Processing by PostsController#index as HTML
Read fragment views/localhost:3000/posts?tag=1304295632 (1.0ms)
Completed 200 OK in 11ms</code></pre>

<p>Here&#8217;s the code for action caching:</p>

<pre><code>caches_action :index, :cache_path =&gt; proc {|c|
  post = Post.order(&#39;updated_at DESC&#39;).limit(1).first
  {:tag =&gt; post.updated_at.to_i}
}</code></pre>

<p>These are simple examples designed to show you who can create auto expiring keys for different situations. At this point we have not add to expire any thing ourselves! The keys have done it all for us. However, there are some times when you want more precise control over how things exist in the cache. Enter Sweepers.</p>

<h2 id='sweepers'>Sweepers</h2>

<p>Sweepers are HTTP request dependent observers. They are loaded into controllers and observer models the same way standard observers do. However there is one very important different. <strong>They are only used through HTTP requests.</strong> This means if you have things being created outside the context of HTTP requests sweepers will do you know good. For example, say you have a background process running that syncs with an external system. Creating a new model will not make it to any sweeper. So, if you have anything cached. It is up to you to expire it. Everything I&#8217;ve demonstrated so far can be done with sweepers.</p>

<p>Each <code>cache_*</code> method has an opposite <code>expire_*</code> method. Here&#8217;s the mapping:</p>

<ol>
<li>caches_page , expire_page</li>

<li>caches_action , expire_action</li>

<li>cache , expire_fragment</li>
</ol>

<p>Their arguments work the same with using cache_key_expansion to find a key to read or delete. Depending on the complexity of your application, it may be very to use sweepers or it may be impossible. Our simple examples can use sweepers easily. We only need to tie into the save event. For example, when a update or delete happens we need to expire the cache for that specific post. When a create, update, or delete happens we need to expire the index action. Here&#8217;s what a the sweeper would look like:</p>

<pre><code>class PostSweeper &lt; ActionController::Caching::Sweeper
  observe Post

  def after_create(post)
    expire_action :index
    expire_action :show, :id =&gt; post
    # this is the same as the previous line
    expire_action :controller =&gt; :posts, :action =&gt; :show, :id =&gt; @post.id
  end
end

# then in the controller, load the sweeper
class PostsController &lt; ApplicationController
  cache_sweeper :post_sweeper
end</code></pre>

<p>I will not go into much depth on sweepers because they are the only thing covered in the rails caching guide. The work, but I feel they are clumsy for complex applications. Let&#8217;s say you have comments for posts. What do you do when a comment is created for a post? Well, you have to either create a comment sweeper or load the post sweeper into the comments controller. You can do either. However, depending on the complexity of your model layer, it may quickly infeasible to do cache expiration with sweepers. For example, let say you have a Customer. A customer has 15 different types of associated things. Do you want to put the sweeper into 15 different controllers? You can, but you may forget to at some point.</p>

<p>The real problem with sweepers is that they cannot be used once your application works outside of HTTP requests. They can also be clumsy. I personally feel it&#8217;s much easier to create auto expiring cache keys and only uses sweepers when I want to tie into very specific events.</p>

<p>Now you should have a good grasp on how the Rails caching methods work. We&#8217;ve covered how fragment caching uses the current view to generate a cache key. We introduced the concept of auto expiring cache keys using <code>ActiveRecord#cache_key</code> to automatically expire cached content. We introduced action caching and how it uses <code>url_for</code> to generate a cache key. Then we covered how you can pass things into <code>url_for</code> to generate a time stamped key to expire actions automatically. We&#8217;ve skipped page caching because it&#8217;s not applicable to many Rails applications. Now that we understand how caching works we can address shortcomings in the system.</p>

<h2 id='moving_away_from_the_http_request'>Moving Away from the HTTP Request</h2>

<p>Now we&#8217;re going to write some code to address problems in the Rails caching system. We know that action caching is dependent on URLS. Fragment caching is dependent on the view being rendered. However, we know that both of these methods use <code>Rails.cache</code> under the covers to store content. We can use <code>Rails.cache</code> any where in our code. Unlike <code>caches_path</code>, <code>caches_action</code> and <code>cache</code> that will no hit the cache if <code>perform_caching</code> is set to false, the <code>Rails.cache</code> methods will <strong>always</strong> execute against the cache. Ideally, it would be nice to create a simple observer for our models. What it would be cool if we had a class like this:</p>

<pre><code>class Cache 
  def self.expire_page(*args)
    # do stuff
  end

  def self.expire_action(*args)
    # do stuff
  end

  def self.expire_fragment(*args)
    # do stuff
  end
end</code></pre>

<p>Then we can use that utility class anywhere in our code to expire different things we have cached. First, we need to be able to generate URL&#8217;s from something other than a controller. You may be familiar with this problem. Mailers are not controllers, but you can still generate URL&#8217;s. You need a host name to generate paths. The controller have this information because they accept HTTP requests which have that information. Mailer do not. That&#8217;s why the host name must be configured in the different environments. We can create a frankenstein class that takes parts of ActionMailer to generate URLS. Once we can generate URL&#8217;s we can expire pages and actions. URL generation is included this module <code>Rails.application.routes.url_helpers</code>. That&#8217;s a shortcut method for the generated module which contains <code>url_for</code>, <code>path_for</code> and all the named route helpers. We also need a class level variable for the host name. Here&#8217;s what we can do so far:</p>

<pre><code>class Cache
  include Rails.application.routes.url_helpers # for url generation

  def self.default_url_options
    ActionMailer::Base.default_url_options
  end

  def expire_action(*args)
    # do stuff
  end

  def expire_fragment(*args)
    # do stuff
  end
end</code></pre>

<p>Now we can pull in some knowledge on how the cache system works to fill in the gaps. Some of this comes from reading the various source files and observation in generating the cache keys. Here is the complete class:</p>

<pre><code># will not work in Rails 2 -- Rails 3 only!
class Cache
  include Rails.application.routes.url_helpers # for url generation

  def self.default_url_options
    ActionMailer::Base.default_url_options
  end

  def expire_action(key, options = {})
    expire(key, options)
  end

  def expire_fragment(key, options={})
    expire(key, options)
  end

  private
  def caching_enabled?
    return ActionController::Base.perform_caching
  end

  def expire(key, options = {})
    return unless caching_enabled?
    Rails.cache.delete expand_cache_key(key), options
  end

  def expand_cache_key(key)
    # if the key is a hash, then use url for
    # else use expand_cache_key like fragment caching
    to_expand = key.is_a?(Hash) ? url_for(key).split(&#39;://&#39;).last : key
    ActiveSupport::Cache.expand_cache_key to_expand, :views
  end
end</code></pre>

<p>Since action and fragment caching all use Rails.cache under the hood, we can simply generate the keys ourselves and remove them manually&#8211;all without the fuss of HTTP Requests. Now you can create an initializer to define a method on your application namespace so it&#8217;s globally accessible. I like this way because it&#8217;s easy to reference in any piece of code.</p>

<pre><code># config/initializers/cache.rb
require &#39;cache&#39;

module App # whatever you application module is
  class &lt;&lt; self
    def cache
      @cache ||= Cache.new
    end

    def expire_fragment(*args)
      cache.expire_fragment(*args)
    end

    def expire_action(*args)
      cache.expire_fragment(*args)
    end
  end
end</code></pre>

<p>Now we can merrily go about our business expiring cached content from <strong>anywhere.</strong> Here are some examples:</p>

<pre><code>App.cache # reference to a Cache instance

App.expire_fragment @post
App.expire_fragment [@post, &#39;sidebar&#39;]
App.expire_fragment &#39;explicit-key&#39;

# in a controller
App.expire_fragment post_url(@post)
# Have to pass in the hash since it&#39;s most likely
# that you won&#39;t have access to the url helpers
# in whatever scope your&#39;re in.
App.expire_action :action =&gt; :show, :controller =&gt; :posts, :id =&gt; @post, :tag =&gt; @post.updated_at.to_i</code></pre>

<p>The <code>expire_fragment</code> and <code>expire_action</code> methods work just like the ones described in the Rails guides. Only difference is, you can use them anywhere. Now we can easily call this code in an observer. The observer events will fire every time they happen <strong>anywhere in the codebase.</strong> Here&#8217;s an example. I am assuming a todo is created outside an HTTP request through a background process. The observer will capture the event.</p>

<pre><code>class TodoObserver &lt; ActivRecord::Observer
  def after_create
    App.expire_fragment :controller =&gt; :todos, :action =&gt; :index
  end
end</code></pre>

<p>The beauty here is that we can use this code anywhere. If you have more complicated cache expirations you may have to use a background job. This may not be acceptable because of processing time, but in some situations you can afford a sweeping delay if the sweeping process takes a long time. You could easily use this code with DelayedJob or Resque if needed. After all, the generated rails code does reference a cache observer&#8211;now you know how to write one.</p>

<h2 id='tagged_based_caching'>Tagged Based Caching</h2>

<p>This is an approach I came up with to work in this situation:</p>

<ol>
<li>Maintain control over how long things are cached</li>

<li>Large number of different associations. Actions or fragments no longer related to a specific resource.</li>

<li>Content could be invalidated through HTTP requests or any number of background process.</li>

<li>Hard to maintain specific keys. I thought of it as &#8220;resources&#8221;.</li>
</ol>

<p>There is a ton of cached content in the system. Many different actions and fragments. There was also a cache hierarchy. Expiring a specific fragment would have to expire an action (so a cache miss would occur when a page was requested thus, causing the new fragment to be displayed) while other things on pages are still cached. One question to ask, is how can I expire groups of things based on certain events? Well, first you need a way to associate different keys. Once you can associate different keys, then you can expire them together. Since you&#8217;re tracking the keys being sent to <code>Rails.cache</code>, you can simply use <code>Rails.cache</code> to delete them. All of this is possible through one itty-bitty detail of the Rails caching system.</p>

<p>You may have noticed something in the <code>Cache</code> class in the previous section. There is a second argument for <code>options</code>. Anything in the <code>option</code> argument is passed to the cache store. This is where can tie in the grouping logic. Also, since action and fragment caching use the same mechanism to write to the cache, we simply have to override the <code>write_fragment</code> method to add our tagging logic.</p>

<p>Through all of this trickery, you&#8217;ll be able to express this type of statement:</p>

<pre><code>App.cache.expire_tag &#39;stats&#39; 
App.cache.expire_tag @account</code></pre>

<p>The content could from anywhere, but all you know is that&#8217;s stale.</p>

<p>This is exactly where <a href='http://rubygems.org/gems/cashier'>Cashier</a> comes in. It is (my gem) that allows you associate actions and fragments with one or more tags, then expire based of tags. Of course you can expire the cache from anywhere in your code. Here are some examples:</p>

<pre><code>caches_action :stats, :tag =&gt; proc {|c|
  &quot;account-#{Account.find(c.params[:id]).id}&quot;
}

caches_action :show, :tag =&gt; &#39;account&#39;
caches_cation :show, :tag =&gt; %w(account customer)

&lt;%= cache @post, :tag =&gt; &#39;customer&#39; do %&gt;</code></pre>

<p>Then you can expire like this:</p>

<pre><code>Cashier.expire &#39;account&#39; # wipe all keys tagged &#39;account&#39;</code></pre>

<p>All this is possible through this module:</p>

<pre><code>module Cashier
  module ControllerHelper
    def self.included(klass)
      klass.class_eval do
        def write_fragment_with_tagged_key(key, content, options = nil)
          if options &amp;&amp; options[:tag] &amp;&amp; Cashier.perform_caching? 
            tags = case options[:tag].class.to_s
                   when &#39;Proc&#39;, &#39;Lambda&#39;
                     options[:tag].call(self)
                   else 
                     options[:tag]
                   end
            Cashier.store_fragment fragment_cache_key(key), *tags
          end
          write_fragment_without_tagged_key(key, content, options)
        end
        alias_method_chain :write_fragment, :tagged_key
      end
    end
  end
end</code></pre>

<p>I higly recommend you checkout <a href='http://rubygems.org/gems/cashier'>Cashier</a>. It may be useful in your application especially if you have complicated relationships with high performance requirements.</p>

<h2 id='caching_complicated_actions_or_methods'>Caching Complicated Actions (or Methods)</h2>

<p>Let&#8217;s say you have an index action. However, it&#8217;s more complicated than a normal scaffold index. The user can search, filer, sort and apply different query options. Think for example a form build with MetaWhere or Sunspot. There are infinite number of combinations, but the data is always the same. That is, a search for &#8220;EC2&#8221; will always have the same results as another search for &#8220;EC2&#8221; as long as the underlying data hasn&#8217;t changed. We could easily cache the index action if we could figured how to represent each unique combination of input parameters as a key value. Memcached also has a key length limit. I don&#8217;t know what it is off the top of my head, but you should try to keep the key short. How can we do this? We use a <strong>cryptographic hash.</strong> A cryptographic hash is guaranteed to be unique given a unique set of input parameters. This means there no collisions.</p>

<pre><code>hash(key1) != hash(key2) # will always be true</code></pre>

<p>The Ruby Standard Library comes with SHA1. SHA1 is good hashing function so we&#8217;ll have no problems using it for these examples. It takes a string input and generates a hash. We&#8217;ll create a composite key with a timestamp and string representation of the input parameters.</p>

<p>require &#8216;digest/sha1&#8217;</p>

<p>class ComplicatedSearchController &lt; ApplicationController</p>

<pre><code>caches_action :search, :cache_path =&gt; proc {|c|
  timestamp = Model.most_recently_updated.updated_at
  string = timestamp + c.params.inspect
  {:tag =&gt; Digest::SHA.hexdigest(string)}
}</code></pre>

<p>end</p>

<p>That will cache every combination of input parameters you can throw at it. This is perfect for actions with pagination as well. It&#8217;s perfect for anything that uses the same underlying data based on input parameters. This can save your bacon if a search takes a few seconds. If one user just did the same search, the second user won&#8217;t have to wait at all. Hell, they might even be impressed.</p>

<h2 id='bringing_caching_into_the_model_layer'>Bringing Caching into the Model Layer</h2>

<p>Caching isn&#8217;t just for views. Some DB operations or methods make be computationally intensive. We can use <code>Rails.cache</code> inside the models to make them more efficient. Let&#8217;s say you wanted to cached the listing of all the top 100 posts on reddit.</p>

<pre><code>class Post
  def self.top_100
    timestamp = Post.most_recently_updated.updated_at
    Rails.cache.fetch [&#39;top-100&#39;, timestamp.to_i&#39;].join(&#39;/&#39;) do
      order(&#39;vote_count DESC&#39;).limit(100).all
    end
  end
end</code></pre>

<p>I&#8217;ve used the <code>most_recently_updated</code> method a few times. It is not a defined method, but a method named so that you understand what it is doing. We can use these concepts to do more fun stuff. My main project has companies and customers. An account has many customers and companies. It&#8217;s typical that I need to retrieve all the customers per an account. This can be 10000 records. That takes time. ActiveRecord instantiation on that order is not free. However, I only care about customers or companies in the scope of a specific account. That means, I only use the account and customers/companies association. Rails gives you the ability to specific a different attribute for <code>:touch</code> on <code>belongs_to</code>. I use this to my advantage to create an &#8216;association_name_updated_at&#8217; column. Then specify :touch =&gt; &#8216;association_name_updated_at&#8217;. Here&#8217;s how it looks in code:</p>

<pre><code>class Account &lt; ActiveRecord::Base
  has_many :customers
end

class Customers &lt; ActiveRecord::Base
  belongs_to :account, :touch =&gt; :customers_updated_at
end</code></pre>

<p>That gives me a timestamp I can use to generate all keys. Now I can use Rails.cache to fetch different queries and keep them all cached. You can wrap this functionality in a module and include in other associations.</p>

<pre><code>require &#39;digest/sha1&#39;

module CachedFinderExtension
  def cached(options = {})
    key = Digest::SHA1.hexdigest(options.to_s)
    association_name = proxy_reflection.name
    owner_key = [proxy_owner.class.to_s.underscore, proxy_owner.id].join(&#39;/&#39;)
    tag = proxy_owner.send(&quot;#{association_name}_updated_at&quot;).to_i

    Rails.cache.fetch [owner_key, association_name, tag, key].join(&#39;/&#39;) do
      all options
    end
  end
end</code></pre>

<p><code>all</code> is a method that takes many options. We don&#8217;t really care what&#8217;s passed in, we just need to be able to generate a cache key based on the input parameters. Since we know when the association was last updated, the method will return fresh content depending if records have been modified. Include the extension in your association and you&#8217;re on your way!</p>

<pre><code>class Account &lt; ActiveRecord::Base
  has_many :customers, :extend =&gt; CachedFinderExentsion
end

# all find&#39;s now automatically cached and expired
@account.customers.cached(:conditions =&gt; {:name =&gt; &#39;Adam&#39;})
@account.customers.cache(:order =&gt; &#39;name ASC&#39;, :limit =&gt; 10})</code></pre>

<p>These are just examples of what you can do with caching in the model layer. You could even write the type of cached finder extension for ActiveRecord::Base. This is different from SQL caching since it only persists through request&#8211;this is cached throughout the entire application.</p>

<h2 id='csrf_and_form_authenticty_token'>CSRF and form_authenticty_token</h2>

<p>Rails uses a CSRF (Cross Site Request Forgery) token and a form authentic token to protect your application against attacks. These are generated per request and each pages get unique values each time. <code>protect_from_forgery</code> is added by default to <code>ApplicationController</code>. You may have run into the problem before. You may have tried to submit a POST and received an Unauthorized response. This is the <code>form_authenticity_token</code> in action. You can fiddle with it and see what happens to your application.</p>

<p>These tokens cause problems (depending on what Rails version) you&#8217;re using with cached HTML. Caching a page or an action with a form may generate unauthorized errors because the tokens were for a different session or request. There are parts of the cached pages that need to be <em>replaced</em> with new values before the application can be used. This is a simple process, but it will take another HTTP request.</p>

<p>You&#8217;ll need to create a controller to server up some configuration related information that&#8217;s never cached. That way, a cached action will load, then a separate request will be made for correct tokens.</p>

<p>NOTE: You may run into more problems with on Rails 2. This is because Rails 3 uses a form authenticity token and CSRF in a meta tag in the HEAD of the document. This is for AJAX requests. You may notice the rails.js file appends them to all AJAX requests. Forms submitted with AJAX with something like <code>$(form).serialize()</code> will send the <code>form_authenticty_token</code> since it&#8217;s automatically included in all forms generated with <code>form_for</code> or <code>form_tag</code>.</p>

<p>You need to create a new controller that responds_to JavaScript and return some JS for the browser to evaluate. Here&#8217;s how you can replace the information in the meta tag for Rails 3. You can also use this logic to update all <code>form_authenticty_token</code> inputs on the page.</p>

<pre><code>$(&quot;meta[name=&#39;csrf-token&#39;]&quot;).attr(&#39;content&#39;, &#39;&lt;% Rack::Utils.escape_html(request_forgery_protection_token) %&gt;&#39;);
$(&quot;meta[name=&#39;csrf-param&#39;]&quot;).attr(&#39;content&#39;, &#39;&lt;% Rack::Utils.escape_html(form_authenticity_token) %&gt;&#39;);

// you may also want to supply current application status as well.
// for example, you may want to know the current users&#39;s ID
// for use in your application JS
MyApp.userId = &#39;&lt;%= current_user.id %&gt;&#39;;</code></pre>

<h2 id='dealing_with_relative_dates_or_other_content'>Dealing with Relative Dates (or other content)</h2>

<p>Many Rails applications use <code>distance_of_times_in_words</code> throughout their application. This can cause major problems for any cached content with a data. For example, you have a fragment cached. That fragment was cached 1 month ago. 2 months ago, it&#8217;s still in the cache. Since you stored a relative date in the cache, the fragment contains &#8216;1 month ago&#8217;. This is no good. You can solve this problem easily with JavaScript.</p>

<p>JavaScript is better for handling dates/times than Rails is. This is because Rails needs to know what the user&#8217;s time zone is, then marshal all times into that time zone. JavaScript is better because it use the local time zone by default. How often do you want to display a time in a different zone than user&#8217;s current locale? You can dump the UTC representation of the date into the DOM, then use JS to parse them into relative or something like <code>strftime</code>. I&#8217;ve encapsulated this process in a helper in my Rails applications. Once all the data is in the DOM, you can do all the parsing in JavaScript.</p>

<pre><code>def timestamp(time, options = {})
  classes = %w(timestamp)
  classes &lt;&lt; &#39;past&#39; if time.past?
  classes &lt;&lt; &#39;future&#39; if time.future?

  options[:class] ||= &quot;&quot;
  options[:class] += classes.join(&#39; &#39;)

  content_tag(:span, time.utc.iso8601, options)
end</code></pre>

<p>Then, when the page loads you can use a library like date.js to create more user friendly dates.</p>

<h2 id='time_to_cash_out'>Time to Cash Out</h2>

<p>I&#8217;ve covered a ton of material in this article. I&#8217;ve given a through explanation of how all the Rails cache layers fit together and how to use the lowest level to it&#8217;s full potential. I&#8217;ve provided a solution for managin the cache outside the HTTP request cycle as well as shown you how to bring caching into the model layer. This is not the be-all-and-all of caching in Rails. It is a indepth look at caching in a Rails application. I&#8217;ll leave you with a quick summary of everything covered and some few goodies.</p>

<h3 id='page_caching'>Page Caching</h3>

<ol>
<li>The honest to goodness best caching ever. Bypass Rails completely.</li>

<li>Usually not applicable to any web application. Have a form? No good, the <code>form_authenticity_token</code> will be no good and Rails will reject it.</li>
</ol>

<h3 id='action_caching'>Action Caching</h3>

<ol>
<li>Most bang for the buck. Can usually be applied in many different circumstances.</li>

<li>Uses fragment caching under the covers.</li>

<li>Generates a cache key based off the current url and whatever other options are passed in</li>

<li>Get more mileage by caching actions with an composite timestamped key.</li>
</ol>

<h3 id='fragment_caching'>Fragment Caching</h3>

<ol>
<li>Good for caching reusable bits of HTML. Think shared partials or forms.</li>

<li>Use a good cache key for each cache block.</li>

<li>Don&#8217;t go overboard. Requests to memcached are not free. Maximize benefits by caching a small number of large fragments instead of a large number of small fragments.</li>

<li>Use auto expiring cache keys to invalidate the cache automatically.</li>
</ol>

<h3 id='general_points'>General Points</h3>

<ol>
<li>Don&#8217;t worry about sweepers unless you have too.</li>

<li>Understand the limitations of Rail&#8217;s HTTP request cycle</li>

<li>Use cryptographic hashes to generate cache keys when permutations of input parameters are invloved.</li>

<li>Don&#8217;t be afraid to use Rails.cache in your models.</li>

<li>Only use sweepers when you have to.</li>

<li>Tagged based caching is useful in certain situations.</li>

<li>Conslidate your cache expritation logic in one place so it&#8217;s easily testable.</li>

<li>Test with caching turned on in complex applications.</li>

<li>Look into <a href='http://www.varnish-cache.org/'>Varnish</a> for more epic wins.</li>

<li>belongs to with <code>:touch =&gt; true</code> is your friend.</li>

<li>Use association timestamps</li>

<li>Spend time upfront considering your cache strategy.</li>

<li>Be weary of examples with expire by regex. This only works on cache stores that have the ability to iterate over all keys. <strong>Memcached</strong> is not one of those.</li>
</ol>]]></content>
 </entry>
 
 <entry>
   <title>Learning Rails: A Glossary</title>
   <link href="http://broadcastingadam.com/2011/04/rails_glossary"/>
   <updated>2011-04-24T00:00:00+03:00</updated>
   <content type="html"><![CDATA[<p>I&#8217;ve been teaching Rails to some people. One thing that&#8217;s hard for them to get straight is the large number of tools involved in Rails development. This post is glossary of terms you may come across. Hopefully it will clarify things for you.</p>

<h2 id='acceptance_testing'>Acceptance Testing</h2>

<p>Acceptancing testing is the act of testing use cases. Test cases are written in a way that describes a use case. Then a test case is passing it can be accepted. Cucumber is a good tool for acceptance testings. Work with your stake holder to develop tests that represent use cases. When the test is complete the feature should be accepted. Acceptance testing is focused around people outside the code development accepting features.</p>

<h2 id='application_servers__thin_mongrel_passenger_unicorn'>Application Servers - Thin, Mongrel, Passenger, Unicorn</h2>

<p>These are all application servers. They interact with your Ruby code and respond to requests. They are integrated with web servers like Nginx or Apache to server you application on the internet.</p>

<h2 id='authentication'>Authentication</h2>

<p>Authentication is the process of matching credentials to a person and verifying them. Authentication is purely about identifiying who the user is&#8211;and not what they can do. Devise is an example of an authentication library.</p>

<h2 id='authorization'>Authorization</h2>

<p>Authorization is the process for determine what a specific user can do. Authorization usually involves permission or role based systems. CanCan is an example of an authorization library.</p>

<h2 id='behavior_driven_development_bdd'>Behavior Driven Development (BDD)</h2>

<p>Is essentially the same as TDD except using a different set of tools to express code in terms of user facing behavior. Rspec and Cucumber are part of the BDD toolbox.</p>

<h2 id='bundler'>Bundler</h2>

<p>Bundler reads a Gemfile and calculates a set of version requirements to make all the specified gems live happily together. It will prevent version conflicts and infamous &#8216;gem already activated error&#8217;. It allows you to install git gems or standard gems from rubygems.org. It does not require libraries, it simply makes them available. It is up to you require them in your programs. Bundler can be used outside of rails. You should use bundler when you do any ruby work.</p>

<h2 id='capistrano'>Capistrano</h2>

<p>Capistrano is a tool for executing command one groups of remote (or local) serves over SSH. It is primary used to deploy Ruby (on Rails) application. It has support for multistage environments. Example, staging and production. You can easily write your own tasks similar to writing rake task. It is the preferred way deploy Rails applications.</p>

<h2 id='capybara'>Capybara</h2>

<p>Capybara is a gem designed to provide an abstraction layer between different browser drivers. It is primarily used in integration testing to interact with the web server. It provides an API to navigate between pages, click buttons, fill in forms, and other user interactions. It has adapters for many different browser drivers. Notable drivers include Selenium, rack-test and webrat.</p>

<h2 id='compass'>Compass</h2>

<p>Compass is a library built around SASS abstractions. It provides mixins for many common things like styling buttons and forms. It is also easy to extend and comes with many built in functions. The blueprint CSS framework is bundled by default.</p>

<h2 id='cucumber'>Cucumber</h2>

<p>Cucumber is a test framework for creating plain english acceptance tests. The tests can be executed automatically. Cucumber is used for integration testing web applications. The test suite is often used in CI (Continuous Integration). Cucumber uses a language called Gherkin to parse files into lines and match them against regular expressions. Regular expressions are matched with code blocks. Your test code lives in these blocks.</p>

<p>Cucumber tests are divided up into &#8220;Feature&#8221; files. Each feature has many &#8220;scenarios.&#8221; Features are like use cases. Scenarios are different permutations of that use case. Here is an example Feature file:</p>

<pre><code>Feature: Make Widthdrawls from Accounts
  As an account holder
  I want to use my money
  In order to use it buy thing

  Background:
    Given I have account under &quot;RubyX&quot;
    And my account is activated

  Scenario: There is enough money in my account
    Given my account has &quot;$1,000&quot;
    And I&#39;m at the bank
    When I widthdraw &quot;$500&quot;
    Then my account should have &quot;$500&quot;

  Scenario: There is not enough money in my account
    Given my account has &quot;$1,000&quot;
    And I&#39;m at the bank
    When I widthdraw &quot;$500&quot;
    Then the teller should reject my transaction</code></pre>

<p>Here is an example step definition:</p>

<pre><code>Given /I&#39;m at the bank/ do
  # set up pre conditions
end

Then /the teller should reject my transaction/ do
  # assert on things
end</code></pre>

<h2 id='dsl'>DSL</h2>

<p>DSL stands for Domain Specific Language. They are crafted to solve one or more problems very eloquently and nothing more. For example, a DSL created to declare work order would be horrible suited for writing Photoshop. DSLs are usually wrappers around more complicated methods that make it easier to express the intent of the underlying code from a programmer&#8217;s perspective. You may have used a DSL before and not realized it. Here is an example from Sunspot&#8217;s search functionality. It&#8217;s designed for describing a search and nothing more:</p>

<pre><code>Post.search do
  fulltext &#39;best pizza&#39;
  with :blog_id, 1
  with(:published_at).less_than Time.now
  order_by :published_at, :desc
  paginate :page =&gt; 2, :per_page =&gt; 15
  facet :category_ids, :author_id
end</code></pre>

<h2 id='erb'>ERB</h2>

<p>ERB is Embedded Ruby. ERB is built into the Ruby core. It allows to to place Ruby inside other files. For example, placing Ruby inside HTML. Here is an example:</p>

<pre><code>&lt;div class=&quot;&lt;%= @ticket.state %&gt;&quot;
  &lt;p&gt;&lt;%= @ticket.message %&gt;&lt;/p&gt;
&lt;/div&gt;</code></pre>

<h2 id='factories__factorygirl__machinist'>Factories - FactoryGirl &amp; Machinist</h2>

<p>These are two popular libraries for creating object factories. They are usually used in test suites and population scripts. They provide a default set of attributes and allow programmers to specify the attributes they care about at creation time.</p>

<h2 id='git'>Git</h2>

<p>Git is a distributed version control system. Each user has a complete copy of the repository. Changes can be pushed back to the remote repositories for others to pull or push from. Linus Torvalds created Git because he was unsatisfied with other version control systems like CVS or SVN. Do not get GitHub confused with Git. GitHub is simply a service for hosting the main Git repository. You can use git independent of github, however most Ruby developers use github exclusively.</p>

<h2 id='haml'>HAML</h2>

<p>HAML is an HTML abstraction language. It&#8217;s great for structuring documents and horrible to content. It will autoclose tags and lets you specify attributes as a hash. You can also include ruby code inside the templates. Here is an example:</p>

<pre><code>.post#post_5 
  .content= simple_format(@post.content)</code></pre>

<h2 id='heroku'>Heroku</h2>

<p>Ruby PaaS (Platform as a Service). They provide free cloud hosting for Rack applications with paid plans for increased resources. It is a very easy way to deploy your first application. Beware, they are easily owned by Amazon&#8217;s AWS failure.</p>

<h2 id='metaprogramming'>Metaprogramming</h2>

<p>Metaprogramming is a term for dynamically generating code at runtime. Metaprogramming is why Rails feel the way it does. ActiveRecord associations to dynamically add methods to your classed based on how to declare them. Metaprogramming is possible in Ruby because it&#8217;s a dynamic language interpreted at run time.</p>

<h2 id='open_classes__monkey_patching'>Open Classes &amp; Monkey Patching</h2>

<p>Ruby has open classes. This means you can simply declare methods insides a class that&#8217;s already been defined. ActiveSupport uses open classes to add all those nice methods to core Ruby objects. This is how you can add a method to the <code>String</code> class:</p>

<pre><code>class String
  def wtf?
    puts &quot;wtf? &quot; * self.length
  end
end</code></pre>

<h2 id='rake'>Rake</h2>

<p>Rake is like the Ruby version of make. You can create custom tasks that can be executed from the command line. <code>rake db:migrate</code> is a classic example. You can create as many tasks as you want. They can have prerequisites. They can also be in namespaces. A &#8217;:&#8217; designates tasks in different namespace. <code>db:migrate</code> means &#8216;db&#8217; namespace, &#8216;migrate&#8217; task. Multiple tasks can be executed in one go like so: <code>rake db:create
schema:load</code>. They will be executed in the order they are listed. Rake was originally designed to be like make, but is often used to execute arbitrary code outside an application context. A cron job is a perfect example.</p>

<h2 id='rjs_ruby_javascript'>RJS (Ruby JavaScript)</h2>

<p>RJS is an abomination. Don&#8217;t use it. RJS uses ruby helpers to generate JavaScript to dump into HTML attributes violating UJS.</p>

<h2 id='rspec'>RSpec</h2>

<p>Rspec is a unit testing framework. It is based around the idea that test should describe behavior of classes in an english like way. Test files are called &#8220;specs&#8221;. Spec files are divided into &#8220;examples.&#8221; Examples contain matchers. Spec files can share examples. Here is an example spec_file:</p>

<pre><code>require &#39;spec_helper&#39;

describe Post do
  it { should have_many(:comments) }

  describe &quot;Post#out_dated?&quot; do
    subject { Post.new :created_at =&gt; 2.months.ago }

    it { should be_outdated }
  end
end</code></pre>

<h2 id='rvm'>RVM</h2>

<p>Rvm stands for Ruby Version Manager. It is a set of bash script designed to allow you switch out Ruby interpreters on the fly. It manages installed ruby interpreters and makes is very easy to install different implementations. It also manages Gemsets. Gemsets are groups of gemsets that are distinct from other groups (except the global gemset which shares gems between different ruby interpreters).</p>

<h2 id='sass__scss'>SASS &amp; SCSS</h2>

<p>SASS and SCSS are CSS abstraction languages. They are compiled down to CSS. They allow you use variables, modules and include other files. In short, they make it much easier to write and main large amounts of CSS.</p>

<h2 id='selenium'>Selenium</h2>

<p>Selenium is a library that simulates user interaction with a browser. It runs the full browser. Selenium works best in FireFox, but can work in Chrome and other browsers. Commands are sent across as JavaScript which the browser evaluates to complete each action. Selenium is the most complete solution for simulating a user for your web application.</p>

<h2 id='test_driven_development_tdd'>Test Driven Development (TDD)</h2>

<p>The practice of writing a failing test first then completing the implementation. This makes the developer spend more time thinking about the code upfront while providing a solid test suite for the entire application. You can use Test::Unit for TDD in Ruby.</p>

<h2 id='testunit'>Test::Unit</h2>

<p>Test::Unit is a unit test framework built into Ruby 1.8. It is known as MiniTest in 1.9. It provides functionality for writing test cases with standard setup and tear down. Rails generates test files built in Test::Unit by default. It provides basic assertions. It&#8217;s similar to jUnit or any member of the xUnit family. Here is an example:</p>

<pre><code>require &#39;test_helper&#39;

class PostTest &lt; Test::Unit::TestCase 

  def test_out_dated? do
    post = Post.new :created_at =&gt; 2.months.ago
    assertTrue(post.out_dated?)
  end
end</code></pre>

<h2 id='ujs_unobstrusive_javascript'>UJS (Unobstrusive JavaScript)</h2>

<p>Unobtrusive JavaScript means separating JavaScript from the HTML. Specifying an <code>onClick</code> attribute in HTML is consider obtrusive because it obfuscates the markup. It is also hard to maintain because your javascript is harder to maintain. You can do the same thing unobtrusively by using jQuery to find the element by a class name and applying a click handler. Essentially UJS means keep JavaScript in .js files and HTML in .html files. Separation of church and state if you will.</p>

<h2 id='webrat'>Webrat</h2>

<p>Webrat is the original headless browser. It&#8217;s similar to selenium, but much more implemented. It does not execute JavaScript and does not execute in a GUI. It is the most basic driver and is perfect for interacting with simple websites.</p>]]></content>
 </entry>
 
 <entry>
   <title>Sproutcore Login Tutorial</title>
   <link href="http://broadcastingadam.com/2011/04/sproutcore_login_tutorial"/>
   <updated>2011-04-04T00:00:00+03:00</updated>
   <content type="html"><![CDATA[<p>Sproutcore is probably the coolest thing I&#8217;ve seen since I saw rails way back early in 2006. I think Sproutcore is the future of complex web application because it is an excellent way to create complicated (and elegant) UI&#8217;s using Javascript. It uses KVO (Key-Value-Observing) to keep the UI in sync with the model. Yehdua Katz put it this way: &#8220;the view always represents truth.&#8221; I will not write about Sproutcore (SC from now on) because there is plenty of information to read on what it is and how it works. They have a <a href='http://guides.sproutcore.com'>guides site</a> to learn about it. However, there is still a lot of confusion on how to implement some simple stuff in SC! I&#8217;ve been dabbling with SC for a few months now&#8211;and now I&#8217;m finally ready to pass on some knowledge. I write SaaS applications, so the first thing I ever consider is &#8220;the user has to login.&#8221; That was my first hurdle with SC. I had to solve this problem: &#8220;How can I create a login form with sproutcore and authenticate against a database of users?&#8221; Well in order to solve this problem we need to do a few things:</p>

<ol>
<li>Create an SC application with a form for username/password</li>

<li>Figure out how to submit that form</li>

<li>Create an HTTP API to determine if the form is valid</li>

<li>Return some information to SC</li>
</ol>

<p>We&#8217;ll start out by creating a basic interface. We&#8217;ll have two pages. When the user goes to our application they&#8217;ll see the login form. If they login correcly, we&#8217;ll show them a different view.</p>

<p>We need some way to get the data from the form to pass it off for processing. SC.ObjectController will do this for us. SC.ObjectController is a proxy to some underling object. However, we never bind directly to the object, instead we bind to the controller. That way when some information changes in the controller (and thusly the underlying object) the various things bound to it will change. This is where KVO comes into play.</p>

<p>We also need something to process the data in the form. The processing code works along these lines:</p>

<ol>
<li>Send a HTTP request to the server</li>

<li>Tell the UI to update according to the HTTP response</li>
</ol>

<p>We&#8217;ll use a state chart framework to transition the application from a logged out state to the logged in state. State charts are good way to model applications. I suggest you google them to learn more about them. Our simple application will only have 2 states: logged in/out.</p>

<p>Once we have the SC application working correclty with some mock login info, we&#8217;ll hook up a simple web service written with Sinatra.</p>

<h2 id='creating_the_sproutcore_application'>Creating the Sproutcore Application</h2>

<p>Sproutcore comes with some generators (similar to Rails). It has a generator to create a basic application. <strong>I am using Sproutcore 1.5RC1 for this.</strong> Ensure the proper version is installed. You can install the gem and generate a new application like this:</p>

<pre><code>$ # enter a fresh directory
$ rvm use 1.9.2@sproutcore-login-tutorial # if you want to use rvm
$ gem install sproutcore --pre
$ sc-init login_tutorial</code></pre>

<p>Now you can start the server and see a hello world page</p>

<pre><code>$ sc-server
# head over to localhost:4020 and choose &#39;login_tutorial&#39;</code></pre>

<p><img alt='Welcome' src='/images/posts/sproutcore_login_tutorial/welcome.png' /></p>

<h2 id='creating_the_login_page'>Creating the Login Page</h2>

<p>Take a peek at <code>apps/login_tutorial/main_page.js</code>. This file defines the intial view in our application. It creates a page with a label on it. Every <code>SC.Page</code> must have a <code>SC.MainPane</code> as the mainPane property. The mainPane contains the objects that are part of the view and displayed on the page. We&#8217;ll use this code as an example to create a new page that shows our login form. We&#8217;ll reserve the main page for the logged in state since it&#8217;s feasible to say that 99% of time the user is logged in.</p>

<p>Create a file named: <code>apps/login_tutorial/resource/login_page.js</code>.</p>

<p>Here is the skeleton:</p>

<pre><code>LoginTutorial.loginPage = SC.Page.design({
    mainPane: SC.MainPane.design({
    })
}); </code></pre>

<p>Inside the mainPane there will be view with 2 text feilds and a button to submit the form. Here is the scaffold code you can use to create the view:</p>

<pre><code>LoginTutorial.loginPage = SC.Page.design({
  mainPane: SC.MainPane.design({
    childViews: &#39;form&#39;.w(),

    form: SC.View.design({
      layout: { width: 200, height: 160, centerX: 0, centerY: 0 },
      childViews: &#39;header userName password loginButton&#39;.w(),

      header: SC.LabelView.design({
        layout: { width: 200, height: 24, top: 0, centerX: 0 },
        controlSize: SC.LARGE_CONTROL_SIZE,
        value: &#39;Login Required&#39;,
        textAlign: SC.ALIGN_CENTER
      }),

      userName: SC.TextFieldView.design({
        layout: { width: 150, height: 30, top: 30, centerX: 0},
        hint: &#39;Username&#39;
      }),

      password: SC.TextFieldView.design({
        layout: {  width: 150, height: 30, top: 80, centerX: 0 },
        hint: &#39;Password&#39;,
        isPassword: YES
      }),

      loginButton: SC.ButtonView.design({
        layout: { width: 100, height: 30, top: 120, centerX: 0 },
        conrolSize: SC.HUGE_CONTROL_SIZE,
        title: &#39;Login&#39;
      })
    })
  })
});</code></pre>

<p>We still have to connect the controller to the data and setup the state chart. Let&#8217;s do that next.</p>

<h2 id='configuring_the_state_chart'>Configuring the State Chart</h2>

<p>Firs, update the <code>Buildfile</code> in the root directory to require the state chart framework. Change the only line in the file to:</p>

<pre><code>config :all, :required =&gt; [:sproutcore, &#39;sproutcore/statechart&#39;]</code></pre>

<p>Now create a file named: <code>apps/login_tutorial/core_states.js</code>. This file defines the state chart. It will have 2 states: loggedIn and loggedOut. When we enter the logged out state, the login form will be displayed. The form will be removed when we leave the state. The main page will be displayed when we enter the logged in state. Here is the code:</p>

<pre><code>LoginTutorial.statechart = SC.Statechart.create({
  rootState: SC.State.design({
    initialSubstate: &#39;loggedOut&#39;,

    loggedOut: SC.State.design({
      enterState: function() {
        LoginTutorial.getPath(&#39;loginPage.mainPane&#39;).append();
      },

      exitState: function() {
        LoginTutorial.getPath(&#39;loginPage.mainPane&#39;).remove();
      }
    }),

    loggedIn: SC.State.design({
      enterState: function() {
        LoginTutorial.getPath(&#39;mainPage.mainPane&#39;).append();
      }
    })
  })
});</code></pre>

<p>The state chart is in charge of handling the flow of the application. It needs to be started when the user goes to the page. Open up <code>apps/login_tutorial/main.js</code> and replace the content of the <code>main</code> function with:</p>

<pre><code>LoginTutorial.main = function main() {

  LoginTutorial.statechart.initStatechart();

} ;</code></pre>

<p>Now, reboot the server and head back to the application. You should see a shiny login form.</p>

<p><img alt='Login Form' src='/images/posts/sproutcore_login_tutorial/login_form.png' /></p>

<h2 id='binding_with_a_controller'>Binding with a Controller</h2>

<p>Now we need to create a controller. A controller manages data for us. We&#8217;ll create a controller with two properties and bind them to the values in the login form. First generate a controller:</p>

<pre><code>$ sc-gen controller LoginTutorial.loginController</code></pre>

<p>Now create two attributes for the controller like so:</p>

<pre><code>LoginTutorial.loginController = SC.ObjectController.create(
/** @scope LoginTutorial.loginController.prototype */ {

  userName: null,
  password: null

}) ;</code></pre>

<p>Now we need to bind the controller to the inputs. We&#8217;ll set the <code>valueBinding</code> property on the text fields to the correct value on the controller. Then whenever the user types something in the form, the controller&#8217;s attributes will update. We&#8217;ll use the controller to get the data to actually login soon. Here is the code to bind the text fields to the controller:</p>

<pre><code>userName: SC.TextFieldView.design({
  layout: { width: 150, height: 30, top: 30, centerX: 0},
  hint: &#39;Username&#39;,
  valueBinding: &#39;LoginTutorial.loginController.userName&#39;
}),

password: SC.TextFieldView.design({
  layout: {  width: 150, height: 30, top: 80, centerX: 0 },
  hint: &#39;Password&#39;,
  isPassword: YES,
  valueBinding: &#39;LoginTutorial.loginController.password&#39;
}),</code></pre>

<p>Reload the page and now you can type stuff into the fields. Then you can check controller properties in the console. So for example, if you type &#8216;Adman65&#8217; into the user name field you could evaluate this in the console:</p>

<pre><code>&gt; LoginTutorial.loginController.userName
&quot;Adman65&quot;</code></pre>

<p>Conversely, you could also set the value of userName in the controller and it would update the UI:</p>

<pre><code>LoginTutorial.loginController.set(&#39;userName&#39;, &#39;rpm&#39;)</code></pre>

<h2 id='making_the_form_do_something'>Making the Form Do Something</h2>

<p>The next step is to make the login button do something. Pressing the button fires an event. We can configure the button to call a method on a responder. A responder is an object that knows how to handle the action. We can set the responder property on a view so all actions are processed by the same object. Our statechart is the responder for this example. Here is the strategy:</p>

<ol>
<li>Tell the view that state chart will handle events fired from it</li>

<li>Tell the button to call a method on the responder</li>

<li>Add a method to handle the action</li>

<li>Use that action to authenticate using the credentials</li>
</ol>

<p>Set the responder like this:</p>

<pre><code>LoginTutorial.loginPage = SC.Page.design({
  mainPane: SC.MainPane.design({
    defaultResponder: &#39;LoginTutorial.statechart&#39;,

    //...
  })
})</code></pre>

<p>Update the button view like this:</p>

<pre><code>loginButton: SC.ButtonView.design({
    layout: { width: 100, height: 30, top: 120, centerX: 0 },
    conrolSize: SC.HUGE_CONTROL_SIZE,
    title: &#39;Login&#39;,
    action: &#39;authenticate&#39;
  })</code></pre>

<p>Now add a method in the state chart to handle the action</p>

<pre><code>LoginTutorial.statechart = SC.Statechart.create({
  rootState: SC.State.design({
    initialSubstate: &#39;loggedOut&#39;,

    loggedOut: SC.State.design({
      enterState: function() {
        LoginTutorial.getPath(&#39;loginPage.mainPane&#39;).append();
      },

      exitState: function() {
        LoginTutorial.getPath(&#39;loginPage.mainPane&#39;).remove();
      },

      authenticate: function() {
        // we&#39;ll fill this in later
        // you can call alert(&#39;weeeeee&#39;) to test it&#39;s working if you 
        // don&#39;t trust me :D
      }
    }),

    loggedIn: SC.State.design({
      enterState: function() {
        LoginTutorial.getPath(&#39;mainPage.mainPane&#39;).append();
      }
    })
  })
});</code></pre>

<h2 id='mock_authentication'>Mock Authentication</h2>

<p>At this point we can check the credentials in the authenticate method we just added. For now we&#8217;ll just check to see if the user has filled in both things, then move to logged in state. We&#8217;ll show an error if either value is missing. Once the UI working, we&#8217;ll use a simple web service to authenticate.</p>

<pre><code>authenticate: function() {
    var userName = LoginTutorial.getPath(&#39;loginController.userName&#39;);
    var password = LoginTutorial.getPath(&#39;loginController.password&#39;);

    if(!SC.empty(userName) &amp;&amp; !SC.empty(password)) {
      this.gotoState(&#39;loggedIn&#39;);
    } else {
      SC.AlertPane.error(&quot;Login information incorrect!&quot;);
    }
  }</code></pre>

<p>Now, when you fill in both fields and press login, then you should see the original welcome message. Otherwise, you get a popup error message.</p>

<p><img alt='Error Message' src='/images/posts/sproutcore_login_tutorial/error.png' /></p>

<h2 id='connecting_to_the_web'>Connecting to the Web</h2>

<p>Now we&#8217;ll create a simple sinatra site that accepts a post and does the same basic checking. Here is <code>webservice.rb</code>:</p>

<pre><code>require &#39;rubygems&#39;
require &#39;sinatra&#39; # make sure you install this gem
require &#39;json&#39; # make sure you install this gem

post &#39;/login&#39; do
  data = JSON.parse request.body.read

  if data[&#39;user_name&#39;] &amp;&amp; data[&#39;password&#39;]
    200
  else
    412
  end
end</code></pre>

<p>Sproutcore sends parameters as JSON encoded strings. We need to decode the JSON to get the parameters. Now you can run the file like this:</p>

<pre><code>$ ruby webservice.rb</code></pre>

<p>Now we have to update the authenticate method to post data to the server:</p>

<pre><code>loggedOut: SC.State.design({
  enterState: function() {
    LoginTutorial.getPath(&#39;loginPage.mainPane&#39;).append();
  },

  exitState: function() {
    LoginTutorial.getPath(&#39;loginPage.mainPane&#39;).remove();
  },

  authenticate: function() {
    var userName = LoginTutorial.getPath(&#39;loginController.userName&#39;);
    var password = LoginTutorial.getPath(&#39;loginController.password&#39;);

    SC.Request.postUrl(&#39;/login&#39;, {user_name: userName, password: password}).
      notify(this, &#39;didCompleteAuthentication&#39;).json().send();
  },

  didCompleteAuthentication: function(response){
    if(SC.ok(response)) {
       this.gotoState(&#39;loggedIn&#39;);
     } else {
       SC.AlertPane.error(&quot;Login information incorrect!&quot;);
     } 
  }
}),</code></pre>

<p>We use <code>SC.Request</code> to create a HTTP POST ajax call. The second argument is the body. Calling .json() will encode the body argument when sending the request. notify() adds a callback to handle the response. Finally, send() actually sends the request. The first argument to the callback is always the response. We check to see if it&#8217;s ok then go to logged in state, else show an error message.</p>

<p>Finally, we have to update the build file to proxy &#8216;/login&#8217; to sinatra. Add this line to your <code>Buildfile</code>:</p>

<pre><code>proxy &#39;/login&#39;, :to =&gt; &#39;localhost:4567&#39;</code></pre>

<h2 id='wrapping_up'>Wrapping Up</h2>

<p>I moved through this example pretty fast since it&#8217;s very basic. It is intended to give you a rough overview of how you can string together a controller, view, state chart, an web service to authenticate users and update the UI accordingly. Here is some further reading:</p>

<ul>
<li><a href='http://github.com/Adman65/sproutcore-login-tutorial'>Source</a></li>

<li><a href='http://blog.nextfinity.net/loginlogout-example-app-pt-1/'>More detailed login tutorial</a></li>

<li><a href='http://wiki.sproutcore.com/w/page/12412900/Foundation-Ajax%20Requests'>SC.Request</a></li>

<li><a href='http://frozencanuck.wordpress.com/2010/11/15/ki-now-the-official-statechart-framework-for-sproutcore/'>More about statecharts in SC</a></li>

<li><a href='http://guides.sproutcore.com'>Sproutcore Guides</a></li>

<li><a href='http://www.sinatrarb.com/intro.html'>More about Sinatra</a></li>
</ul>]]></content>
 </entry>
 
 <entry>
   <title>The Ruby Gem Challenge</title>
   <link href="http://broadcastingadam.com/2011/02/the_ruby_gem_challenge"/>
   <updated>2011-02-20T00:00:00+02:00</updated>
   <content type="html"><![CDATA[<p>I am working on a gem ranking website. One of the metrics is test results. Getting test result for a random project can be a very difficult task. I&#8217;ve cloned 3,081 different gems onto my computer. I&#8217;ve written a simple bash script to execute this loop:</p>

<pre><code>for repo in ~/repos/* ; do
  cd ${repo}
  rvm use 1.8.7@${repo}
  bundle
  rake
done</code></pre>

<p>Nothing fancy going on there. However, <strong>the results are appalling.</strong> Very few gems work out of the box on a clean machine. I think this a huge failure for gem developers. If you don&#8217;t have a rake task that can execute tests in a clean environment then you have a problem! I thought to myself, surely this cannot be the case. I tested well known gems like devise. No dice. I tested cancan. That didn&#8217;t work as well. I tried to test some of gem&#8217;s I&#8217;ve used. Not much luck there. I have the script running in a console right now. AASM just worked with 100% passing. I&#8217;ve tweeted some gems that work as well. Mail and HTTParty worked out of the box. HTTParty even had cucumber features passing! I think the gem authors (myself included) should rise to the occasion and make it easier for other people to test our gems! I think this would speak very highly of the ruby community. Everyone should try the Ruby Gem challenge out on their favorite gem:</p>

<ol>
<li>Clone repo into fresh directory</li>

<li>Create empty gemset and bundle</li>

<li>Bundle (If the gem does not use bunder, fail right there)</li>

<li>Execute <code>rake</code></li>

<li>Report results</li>
</ol>

<p>After running this test through many many gems, I have a new found respect for the authors of the gems that passed my tests. Try it out and let me and the authors know your results! Tweet me at @Adman65 and tweet the authors know too! They should get on that :D</p>

<p>PS. It will also be nearly impossible to get above an 80% ranking on whatgem when I implement this scheme. That will <strong>really</strong> sort out the good from the bad.</p>]]></content>
 </entry>
 
 <entry>
   <title>Why I Love Volume 1: Sprockets</title>
   <link href="http://broadcastingadam.com/2011/02/why_i_love_volume_1_sprockets"/>
   <updated>2011-02-11T00:00:00+02:00</updated>
   <content type="html"><![CDATA[<p><a href='http://getsprockets.org/'>Sprockets</a> is one of the most handy gems I&#8217;ve ever used. It allows you separate javascript into multiple files and use <code>require</code> keywords. This was a god send for me. The application I&#8217;m working has a TON of js. I was able to tame it with sprockets. I also came up with a nice directory structure a long the way.</p>

<h2 id='the_problem'>The Problem</h2>

<p>It all starts with application.js. You have one file. The documentation says dump your javascript into this file&#8211;hell, put <strong>all</strong> your js into this file. So you start writing a few ajax calls and various trickery. 20 lines. Then 50 lines. Then 100 lines. Then 500 lines. Then maybe a couple thousand. Wait&#8230;.a couple thousand? How did we get here? A couple thousand for what? What page is this JS for? How do i <em>find</em> what javascript I&#8217;m looking for? Hmmm. What about my jquery plugins? /public is starting to get pretty packed. Now lets say you&#8217;ve got 25 different pages. Each page needs their own JS to accomplish certain tasks. At this point, is it smart to keep dumping things into the same file? I say no. It&#8217;s time to get things whipped into shape. There&#8217;s one thing I really like about Rails: <strong>convention over configuration.</strong> The views folder is setup pretty nicely. There is a folder that corresponds to the controller that renders the view, and a file for the view name. It would be nice to have this same structure for our javascript. When your JS starts to become rather large, you&#8217;ll have some common code that is shared. This stuff belongs in an application.js file. So how can we keep all this code organized? Sprockets.</p>

<h2 id='hail_the_conquering_hero'>Hail the Conquering Hero</h2>

<p>Sprockets is a Ruby library that preprocesses and concatenates JavaScript source files. It takes any number of source files and preprocesses them line-by-line in order to build a single concatenation. Specially formatted lines act as directives to the Sprockets preprocessor, telling it to require the contents of another file or library first or to provide a set of asset files (such as images or stylesheets) to the document root. Sprockets attempts to fulfill required dependencies by searching a set of directories called the load path.</p>

<p>Perfect. It can even combine all our js into one single file. We can even minmize that later if we choose too. This means we can setup this type of directory structure:</p>

<pre><code>/app
  /javascripts
    /pages
      dashboard.js
      settings.js
    /shared
      utility.js
    application.js</code></pre>

<p>! That is pretty handy if you ask me. It becomes very odvious how the JS is organized. It also makes it very easy to add isolated bits of javascript for specific pages/widgets/etc. You can also add other directories to the load path. This means you can create a /vendor directory for your javascript. I love this because I can keep my downloaded jquery plugins in /vendor with git submodules for easy updating. So you could create this sort of structure for your application:</p>

<pre><code>/app
  /javascripts
    /so_on_and_so_forth
/vendor
  /javascripts
    jquery.js
    jquery-ui.js
    jquery.plugin1.js
    jquery.plugin2.js</code></pre>

<p>Nice. You can also require other files as you would in ruby. For example, say you&#8217;re in application.js and you want to ensure that some other javascript (like jquery) is loaded before this code is ran.</p>

<pre><code>//=require &lt;jquery&gt;

// jquery dependent stuff here</code></pre>

<p>Another example, say you&#8217;re writing some JS for the dashboard and you need to the utilities methods.</p>

<pre><code>//= require &#39;../shared/utilities&#39;

MyApp.utilities.flashNotice(&#39;oh hai&#39;);</code></pre>

<p>A require statement tells Sprockets to insert the content of the required file before processing the rest of the document. I like this because it makes it very explicit what JS is needed. It also prevents those wonderful undefined method xxx for null errors. A require with <code>&lt;file&gt;</code> tells sprockets to search the load path. A require without means it is a relative path name.</p>

<h2 id='how_i_integrated_sprockets'>How I Integrated Sprockets</h2>

<p>I took a similar approach to what I outlined earlier. I wanted a javascript file for each separate page of the application and a some shared folder where shared code lived. Then I wanted a way to easily initialize the pages. Each page would live in it&#8217;s own specific object, so there would be no collisions. Here is the directory structure I came up with:</p>

<pre><code>/app
  /javascripts
    /pages
      dashboard.js
      settings.js
    /components
      widget1.js
      widget2.js
    /shared
      utilities.js
    application.js
    jquery.js
/vendor
  /sprockets
    /jquery
      /src
        jquery-1.4.4.js
        jquery-ui.js
        jquery.plugin1.js
        jquery.plugin2.js</code></pre>

<p>My application has many shared widgets. I called them components because they can be reused in any context in many different places. Sometimes the JS for these things can be quite long, so I wanted a specific file for each one so I knew where to look when something went wrong. The default configuration for sprocket-rails has <code>/vendor/sprockets/*src</code> on the load path. I didn&#8217;t feel like changing it, and this way it lets me group similar files. Sprockets will always process application.js first. I use this to set the stage by requiring all different JS my application needs.</p>

<pre><code>// application.js

//=require &#39;jquery&#39;</code></pre>

<p>jquery.js is a file simple loads all the stuff in /vendor:</p>

<pre><code>// jquery.js

//=require &lt;jquery.1.4.4.&gt;
//=require &lt;jquery-ui&gt;
//=require &lt;jquery.plugin1&gt;
//=require &lt;jquery.plugin2&gt;</code></pre>

<p>Here&#8217;s what one of the page file looks like:</p>

<pre><code>//= require &#39;../components/widget1.js&#39;
//= require &#39;../components/widget2.js&#39;

var DashboardPage = {
  init: function() {
      // do stuff, this is called when the page is loaded
  },
  // protip, use an ajax callback for the page automagically
  ajaxComplete: function() { }
};</code></pre>

<p>I added a helper to initialize the page and attach the current page. It generates javascript like along these lines and embeds it into the page:</p>

<pre><code>$(function(){
  #{page_name.titleize}Page.init();
  $(&#39;body&#39;).ajaxComplete(#{page_name.titleize}Page.ajaxComplete);
});</code></pre>

<p>Then in the view (/app/views/dashboards/show):</p>

<pre><code>&lt;% initialize_page &#39;dashboard&#39; %&gt;</code></pre>

<h2 id='how_it_worked_out'>How it Worked Out</h2>

<p>This was the best changed I&#8217;ve ever made to this application. Before the JS was spread out into random files and it was a pain in the ass to track down <em>how</em> it got included and <em>where</em> it was. Now this way I know there is /app/javascripts/pages/page_name.js file and by the time that code is executed, all the required code is added. It&#8217;s also been very easy to add new plugins. Drop the jquery plugin into /vendor and update the jquery.js in /app/javascripts. Boom. Available everywhere. It is also concatenated into one large file so instead of 20 or so (yes I know this is bad) requests we now only have <strong>1</strong>. This made a big difference in the load time. If you haven&#8217;t used sprockets, I highly suggest you check it out&#8211;especially if you have a js centric application.</p>

<p><strong>tl;dr</strong>: Sprockets is a cool gem to organize and manage js your own way. It also concatenates all js files into one single file. This makes your page load faster. Use sprockets for inceased sanity.</p>]]></content>
 </entry>
 
 <entry>
   <title>Ubuntu, Jetty, Solr &amp; MultiCore</title>
   <link href="http://broadcastingadam.com/2011/02/ubuntu_jetty_solr_and_multicore"/>
   <updated>2011-02-02T00:00:00+02:00</updated>
   <content type="html"><![CDATA[<p><a href='http://lucene.apache.org/solr/'>Solr</a> is a wonderful fulltext search program. It can be configured to do a great many things. It can also be a royal pain to setup. Solr is written in Java. In order to use solr in your application you must configure a java application somewhere to serve up Solr. Solr runs as an web service. You index docouments by posting XML to the server for indexing. You can install a java application server like Tomcat or Jetty to host Solr. By default, Solr can only index one set of data. This means, if you need to host multiple applications on the same solr server, then you have a few options. You can create new Solr instances for each application, or you can use Solr&#8217;s MultiCore functionality to index different datasets. MultiCore is like creating another database for Postgres. I&#8217;ll show you how to get this up and running under Ubuntu.</p>

<h2 id='installing_jetty_java_and_solr'>Installing Jetty, Java and Solr.</h2>

<p>This is one of the reasons I love ubuntu server. It just has packages. I don&#8217;t have to worry about downloading code from random place, it just has everything a boy could need in a server. Install these packages using apt:</p>

<pre><code>sudo apt-get install solr-jetty openjdk-6-jdk</code></pre>

<p>This pulls in ~60MB and a ton of packages so watch out for that :D</p>

<p>The next thing we want to do is setup Jetty to listen on all connections. By default the installation is only available on htt://localhost:8080. That&#8217;s great if you&#8217;re making a local server, but we need to open our box up to the world. Ubuntu uses a file <code>/etc/defaults/jetty</code> to manage daemon settings. Open this file in vim and replace this line:</p>

<pre><code>#JETTY_HOST=$(uname -n)</code></pre>

<p>With:</p>

<pre><code>JETTY_HOST=</code></pre>

<p>This will tell jetty to listen on all connections. You can also put in your own ip or domain name if you please. Feel free to change the port as well at this point.</p>

<p>Now navigate to the top of the file and <code>/NO_START</code> to go to the next setting we need to change. Replace the 1 with a 0 and wer&#8217;re in business. This will tell jetty to start when the server is loaded.</p>

<p>Now fire the server up with:</p>

<pre><code>/etc/init.d/jetty start</code></pre>

<p>Once all is good you should be able to navigate to <a href='http://yourhost.com:8080'>http://yourhost.com:8080</a> and get welcome page. This is basically a &#8220;it works page&#8221;. Now you can move on to solr. Ubuntu already did a lot of extra work for you by installing a runnable version of solr into Jetty. You can access that at <a href='http://yourhost.com:8080/solr'>http://yourhost.com:8080</a>. It is a very basic admin&#8211;but it&#8217;s something. Now we&#8217;re ready for MulitCore.</p>

<h2 id='multi_core'>Multi Core</h2>

<p>MultiCore is was the most complicated part for me to get setup, partially because everything I read conflicted with something&#8211;but don&#8217;t worry. It should be easy for you if you follow along. You can read the offical wiki page <a href='here'>http://wiki.apache.org/solr/CoreAdmin</a>.</p>

<p><strong>Here&#8217;s what they don&#8217;t tell you, or assume you should know:</strong> In order for MultiCore to work, each core must have it&#8217;s own solrconfig.xml and schema.xml. That&#8217;s fantastic, but excuse me, where the hell do I put these files? That was my life for 3 hours. Mucking around with random configurations until POOF. \o/ It all worked.</p>

<p>You also have to create a <code>solr.xml</code> file separate from all the other config files that tells Solr to load multicore. This was outlined reasonably well in the documentation, but it still gave me headaches.</p>

<h3 id='step_1_solrxml'>Step 1. Solr.xml</h3>

<p>We need to create a file that tells Solr to load our cores. You can decided ahead of time what they are, or just use this as a template for now. Below is a template you can follow. You can create as many cores as you want. When Editing the file, be sure to replace all copies of &#8220;production&#8221; with whatever the name of your core is. In my setup, I needed 3 different cores. One for production code, one for staging code, and one for a beta code. Once you&#8217;ve created this file, save it as: <strong>/usr/share/solr/solr.xml</strong>.</p>

<pre><code>&lt;solr persistent=&quot;true&quot;&gt;
 &lt;cores adminPath=&quot;/admin/cores&quot;&gt;
   &lt;core name=&quot;production&quot; instanceDir=&quot;production&quot; dataDir=&quot;/var/lib/solr/production/data&quot; /&gt;
   &lt;core name=&quot;staging&quot; instanceDir=&quot;staging&quot; dataDir=&quot;/var/lib/solr/staging/data&quot; /&gt;
   &lt;core name=&quot;beta&quot; instanceDir=&quot;beta&quot; dataDir=&quot;/var/lib/solr/beta/data&quot; /&gt;
 &lt;/cores&gt;
&lt;/solr&gt;</code></pre>

<p><strong>Don&#8217;t forget to set the dataDirectory attribute as well!</strong></p>

<h3 id='step_2_making_data_directories'>Step 2. Making Data Directories</h3>

<p>Now we must create directories for our index data to live. They were specified earlier in the step 1. These directories must be writable by the jetty user. Apt automatically added this user for you when you installed jetty-solr. You can create them with this command.</p>

<pre><code>sudo mkdir -p /var/lib/solr/production/data</code></pre>

<p>Repeat this command for however many cores you need. Next make jetty the owner.</p>

<pre><code>sudo chown -R jetty /var/lib/solr/</code></pre>

<h3 id='step_3_copying_the_config_files'>Step 3. Copying the Config Files</h3>

<p>This was the hidden step. First thing we need to do is create directories for our cores to live. Each core has it&#8217;s own schema and config files. These need to be created. It&#8217;s just like we did in step 2, but with a different directory.</p>

<pre><code>sudo mkdir /usr/share/solr/production</code></pre>

<p>Now we need to create the configuration files. I&#8217;ve posted them in gists. These files are templates and just enough to get the server started. It is up to you to do the customization!</p>

<ul>
<li><a href='https://gist.github.com/816101'>solrconfig.xml</a></li>

<li><a href='https://gist.github.com/816103'>schema.xml</a></li>
</ul>

<p>Download those files or keep them open. Now create a conf directory inside the directory you&#8217;ve already created</p>

<pre><code>sudo mkdir /usr/share/solr/production/conf</code></pre>

<p>Now enter the directory and paste those files.</p>

<pre><code>cd /usr/share/solr/production/conf
# paste solrconfig.xml into your editor and save it
# paste schema.xml into your editor and save it</code></pre>

<p>Now at this point, you can simply copy this directory for the other stages. This is especially helpful if you have 5 stages. You can duplicate the config like so</p>

<pre><code>sudo cp -R /usr/share/solr/production /usr/share/solr/new_name1
sudo cp -R /usr/share/solr/production /usr/share/solr/new_name2
# and so on</code></pre>

<p>Now you are ready to restart the server</p>

<pre><code>sudo /etc/init.d/jetty stop
sudo /etc/init.d/jetty start</code></pre>

<p>Now head back over to <a href='http://yourhost.com:8080/solr/admin'>http://yourhost.com:8080/solr/admin</a> And you should see links to all your cores!</p>

<h3 id='step_4_customization'>Step 4. Customization</h3>

<p>Depending your needs you may have different schemas and configurations for each core. You should configure them now. If you need to use the same configuration to each core, you should symlink the main solrconfig.xml to the various stages. For example, you should have the production and staging cores running the same config.</p>

<p>Feel free to hit me up on twitter at @Adman65 with questions or problems! Hope this helped.</p>]]></content>
 </entry>
 
 <entry>
   <title>Cucumber's env.rb &amp; Dry Run Problems</title>
   <link href="http://broadcastingadam.com/2010/12/cucumbers_dry_run_problems"/>
   <updated>2010-12-02T00:00:00+02:00</updated>
   <content type="html"><![CDATA[<p>Env.rb setsup Cucumber&#8217;s execution environment. The generated file from cucumber-rails essentially loads your rails env and setups up Capybara etc. That&#8217;s all well and good but what do you do if you need to add your own stuff. Once you&#8217;ve built up a sizeable cucumber test suite, it&#8217;s probable that you&#8217;ve got some modifications to env.rb. However, they <strong>should not</strong> be there since when you upgrade to a new version of cucumber (mainly cucumber-rails) it wants to regenerate that file. So what you need to do is split up your modifications into sepearate files. Here are some modifications you may have:</p>

<ol>
<li>Modifying your Capybara driver (yay chrome)</li>

<li>Loading blueprints</li>

<li>Customizing specjour</li>

<li>Settings other constants</li>

<li>Insert random code</li>
</ol>

<p>That&#8217;s all well and good but it&#8217;s not the correct way to do it. There are few options. You can split each modification into its own file and drop it in /features/support. Cucumber will autoload <strong>all</strong> files in side this directory. Technically it matches all files using this glob pattern: <code>features/**/*.rb</code>. However env.rb is loaded <strong>before</strong> all other files in features/support. This means you can drop create a file like this for specjour into <code>features/support/specjour.rb</code>:</p>

<pre><code># tell Capybara to start a server on any open port
# since specjour will start multiple workers on the same computer
# and hence Capybara will try to connect to the same port 
# locking up the test suite
if ENV[&#39;TEST_ENV_NUMBER&#39;]
  Capybara::Server.class_eval do
    def find_available_port
      server = TCPServer.new(&#39;127.0.0.1&#39;, 0)
      @port = server.addr[1]
    ensure
      server.close if server
    end
  end
end</code></pre>

<p>That fill will be loaded <strong>after</strong> env.rb when you <strong>execute</strong> your tests. This does create an interesting wrinkle. I use dry run mode a lot in my suite. I refactor my features and steps quite often as I get a better understanding of the domain. I use dry run mode to check to see if all the steps are defined before executing the test suite. The test suite can take over an hour. :( Cucumber does not load env.rb in dry run mode, it <strong>does</strong> load all other files in /features/support. This creates a problem if you have files in features/support that require env.rb to be loaded. For instance the specjour example I posted requires the capybara gem to be loaded. You could add:</p>

<pre><code>require &#39;capybara&#39;</code></pre>

<p>But it won&#8217;t be able to find the gem since the gem environment is not loaded when the file is required. In dry run mode cucumber does not load files that match this regular expression: <code>support\/env\..*</code>. Interestingly Cucumber does not simply select features/support/env.rb since that is the standard file. That means you can name files &#8220;env.specjour.rb&#8221; or &#8220;env.capybara.rb&#8221; to have them execluded in dry run mode. Although, this issue is only present when you run features using the cucumber binary. If you run features through rake then you will not have problems since the complete rails environment is loaded before cucumber is loaded.</p>

<p>tl;dr PROTIP: put things you would&#8217;ve added to env.rb in a file in /features/support/customer_modification_.rb. If you run those features with rake you&#8217;ll be ok. If you run those features with the cucumber command you&#8217;ll be ok. If those modifications required env.rb to be loaded and you run features with cucumber in dry run mode name them: features/support/env.modification.rb.</p>]]></content>
 </entry>
 
 <entry>
   <title>Lessons From a Startup</title>
   <link href="http://broadcastingadam.com/2010/10/lessons_from_a_startup"/>
   <updated>2010-10-31T00:00:00+03:00</updated>
   <content type="html"><![CDATA[<p>Ive been working as the lead developer at Finnish start up for about 9 months now. Were making a cool product that weve got high hopes for. Were getting our first customers now, so Im taking some time to reflect on our progress and what Ive learned.</p>

<h2 id='1_dont_release_unfinished_code'>1. Don&#8217;t Release Unfinished Code</h2>

<p>This seems like a no brainer, but sometimes the excitement about a new feature gets the best of you and you push it out before youve had adequate time to to test it. Im not talking about just integration testing, but letting some test users play with and make sure its working to their requirements and not yours. Last month we had a major feature released, it had already been delayed due to bug fixes. We held off and kept working on it. When we did release the feature it turned out that it still wasnt done and we had to go shock and awe on the bug list. Its better to be late and correct, then early and look like a noob. We learned that lesson.</p>

<h2 id='2_dont_trust_third_parties'>2. Don&#8217;t Trust Third Parties</h2>

<p>Our product integrates pretty heavily with various third party products. At one point we were working with four third parties to provide crucial parts of our product. Their services seemed useful, but we ran into problems when it came into crunch time. Our problem was that our release dates where not inline with their time. For example, we were waiting a month for one company to provide some information/API stuff for us. We wanted to roll out the feature in two weeks, but as time went on, we had to cut the feature because the third party couldnt deliver. We are starting another third party integration. In the planning phase, we just assumed it would take twice or even three times as long as they saythis is simply because theyve got their own business too.</p>

<h2 id='3_have_small_goals'>3. Have (small) Goals</h2>

<p>We are big dreamers. We want our product to be the shit. We want it to be awesome. We want to be a swiss army knife made out of unicorns tears flying around with a gold cape. We also need to sell this thing and develop real features. Its been easy for us to get distracted and not focus on getting useful things done. What we need to do is focus on small features and deliverables. There are quick wins and small steps. Remember to set goals you can makeand be realistic about them! You only hurt yourself by setting unrealastic goals for yourself. Know your limits and work within in them. We learned this lesson as well.</p>

<h2 id='4_have_a_vision'>4. Have a Vision</h2>

<p>The vision is the over arching goal and purpose of what youre doing. Someone needs to have this, or youre just a leaf in the wind. However, dont get your vision confused with your goals! You set goals in order to meet the vision. Your goals build up to a product that fulfills the vision. Also, be realistic about your vision. If youre not making any cash, then your vision must be to make some money and set goals to make that happen.</p>

<h2 id='5_have_a_standard'>5. Have a Standard</h2>

<p>Weve had a few developers come and go through the course of the project. Ive been the only constant. In the beginning, it was wild west. Anyone could commit and features were happening all over the place. We recently had someone new coming a few months ago to do front end work. The front end work is slowly transitioning into backend-ish work. Thats all good if you have people that can wear multiple hats, except there has to be rules. After a while I got fed up and wrote up a standards document. It laid out what would have to be in place for ommits/features to be accepted and what kind of workflow to use. Its published in the repos readme. All current and future developers will be held to the standards laid out. Having standards should increase code quality over the projects lifetime.</p>

<h2 id='6_invest_in_testing'>6. Invest in Testing</h2>

<p>Test. Test. Test. Test. I love testing and you should to. Testing can save your life. Include time for testing in the release schedule. Include time for testing before production deploys. Invest developer time in creating a good test suite. Use tools like specjour to distribute your test suite. Our cucumber test suite took ~1hr. Spent some time setting up specjour, got that sucker down to ~10min. Youre integration suite should run quickly and you should run it often. If the suite takes too long to run, it will not run that often and you lose the benefits of automated testing. Invest time and keeping this process lean. It will pay you back.</p>

<h2 id='7_make_software_that_customers_want_and_will_pay_for'>7. Make Software that Customers Want (and will pay for)</h2>

<p>Duh. But, sometimes its easy to get distracted with stuff you think is cool. Example: you think feature A is off-chain and it should totally be in the project. Customers are lined up waiting for feature B. Feature B isnt as cool but is going to bring in some cash. Work on feature B. Make a product that will sell and bring in money. Our product is a game changer (I know you hear this every time you read about start ups). When customers see what weve got cooking they are completely befuddled, next awe struck, then really interested. The project leader and myself are way past that phase. We are no longer awe struck by what our product can dobut the customers still are! You should focus on developing features that customers want and not (all the time) developing feature for yourself.</p>

<h2 id='8_know_youre_gonna_make_mistakes'>8. Know You&#8217;re Gonna Make Mistakes</h2>

<p>It goes without saying, but understand that youre gonna mess up. When youre working in a startup, the business plan and overall product is not set in stone. Remember to keep this mind and adapt to change.</p>]]></content>
 </entry>
 
 <entry>
   <title>app/observers -- Where They Should Be</title>
   <link href="http://broadcastingadam.com/2010/10/app_observers"/>
   <updated>2010-10-09T00:00:00+03:00</updated>
   <content type="html"><![CDATA[<p>Afer you&#8217;ve been doing Rails for a while you become old and cranky about how you want things. I <em>love</em> my observers in /app/obsevers. I do not understand why they are not their by default. Models, mailers, and controllers all have their own folders, why can&#8217;t observers by default. They don&#8217;t even make any sense in /app/models. #1 They don&#8217;t model anything and #2 They aren&#8217;t subclasses of ActiveRecord (or some other ORM). If all the classes in /app/models are subclasses of AR, then what is an observer breaks the pattern. In Rails 2 if you want to specify another directory to load code from you have to specify add it to the <code>config.load_path</code> variable. This is not the case in Rails 3. If you simply want to shove your observers into /app/observers, jsut make the directory and move the files in there. You will have to move them if you don&#8217;t patch the <code>rails g observer</code> command to generate them in a new directory. That takes care of Rails, but now that we have our observers separated, it&#8217;s safe to assume we want to be able to run <code>rake spec:obsevers</code>. This is not a problem either. All you have to do is create a rake spec task to only run files in spec/observers. So drop this bad boy in /lib/tasks</p>

<pre><code>require &#39;rspec/core&#39;
require &#39;rspec/core/rake_task&#39;
Rake.application.instance_variable_get(&#39;@tasks&#39;)[&#39;default&#39;].prerequisites.delete(&#39;test&#39;)

spec_prereq = Rails.configuration.generators.options[:rails][:orm] == :active_record ?  &quot;db:test:prepare&quot; : :noop

namespace :spec do
  [:observers].each do |sub|
    desc &quot;Run the code examples in spec/#{sub}&quot;
    RSpec::Core::RakeTask.new(sub =&gt; spec_prereq) do |t|
      t.pattern = &quot;./spec/#{sub}/**/*_spec.rb&quot;
    end
  end
end</code></pre>

<p>Now we have our own rake task for testing our observers. But let&#8217;s take it one step further and make our observer specs a first class citizen in Rspec2. You know that when you write controller specs you can call the <code>controller</code> method or in helper specs there is a <code>helper</code> object that represents the object under test. This magic happens because rspec contains special code that runs when initial describe block matches something like xxxController or xxxHelper. If it matches, it loads some special code to make writing specs for these classes much easier. All you have to do is take a peek into the rspec-rails <a href='http://github.com/rspec/rspec-rails/tree/master/lib/rspec/rails/example/'>source</a> to see where the magic happens. I advice you to look at those files and figure out what&#8217;s up. Creating a new observer example group is easy. Drop this bad boy in side /spec/support/observer_example_group.rb</p>

<pre><code>module RSpec::Rails
  module ObserverExampleGroup    
    extend ActiveSupport::Concern
    extend RSpec::Rails::ModuleInclusion

    include RSpec::Rails::RailsExampleGroup

    def observer
      example.example_group.describes.instance
    end

    included do
      metadata[:type] = :observer
    end

    RSpec.configure &amp;include_self_when_dir_matches(&#39;spec&#39;,&#39;observers&#39;)
  end
end</code></pre>

<p>This module adds some sugar to all specs in an observer example group. If your spec is in spec/observers you can now do something like this:</p>

<pre><code>describe AccountObserver do
  it &quot;should send a welcome email&quot; do
     AccountMailer.should_receive(:welcome_email).and_return(mock_mail)
     mock_mail.should_receive(:deliver)
     observer.after_create(mock_account) # notice observer is defined in the observer example group
  end
end</code></pre>

<p>Nice! We no longer have to call AccountObserver.instance in all our tests or set an @observer in a before filter. This also allows us to do some more cool stuff for our observer examples. You can include support modules for certian example by doing something like this in your spec_helper.rb file</p>

<pre><code>config.include ControllerHelpers, :type =&gt; :controller</code></pre>

<p>Now we can do that for observers as well! You may by thinking where the hell did those mock_account and mock_email methods come from? You define then in an obesrver helper module inside the support directory then tell rspec to include them for all observers like so. First create this file: spec/support/observer_helpers.rb</p>

<pre><code>module ObserverHelpers
  def mock_account(stubs = {}) 
    @mock_account ||= mock_model(Account, stubs)
  end

  def mock_mail(stubs = {}) 
    @mock_mail ||= mock(Mail, stubs)
  end
end</code></pre>

<p>Now in your spec helper:</p>

<pre><code>config.include ObserverHelpers, :type =&gt; :observer</code></pre>

<p>Poof! All done. Now you can go on your way running rake spec:observers and treating your observer specs as first class citizens w/Rspec2. Happy testing.</p>]]></content>
 </entry>
 
 
</feed>